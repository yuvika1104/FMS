<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>File Management and Analysis System</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
    :root {
      --bg-light: #f9fafb;
      --text-light: #1f2937;
      --card-bg-light: rgba(255, 255, 255, 0.9);
      --border-light: rgba(255, 255, 255, 0.2);
      --shadow-light: rgba(31, 38, 135, 0.1);
      --placeholder-text-light: #6b7280; /* gray-500 */
      --input-bg-light: white;
      --input-border-light: #e5e7eb; /* gray-200 */
      --tab-inactive-bg-light: #e9ecef;
      --tab-inactive-text-light: #495057;
      --results-bg-light: #eff6ff; /* blue-50 */
      --results-text-light: #1d4ed8; /* blue-700 */
      --error-bg-light: #fee2e2; /* red-100 */
      --error-text-light: #b91c1c; /* red-700 */
      --success-bg-light: #d1fae5; /* green-100 */
      --success-text-light: #047857; /* green-700 */


      --bg-dark: #111827; /* gray-900 */
      --text-dark: #f3f4f6; /* gray-100 */
      --card-bg-dark: rgba(31, 41, 55, 0.8); /* gray-800 with alpha */
      --border-dark: rgba(55, 65, 81, 0.5); /* gray-700 with alpha */
      --shadow-dark: rgba(0, 0, 0, 0.2);
      --placeholder-text-dark: #9ca3af; /* gray-400 */
      --input-bg-dark: #374151; /* gray-700 */
      --input-border-dark: #4b5563; /* gray-600 */
      --tab-inactive-bg-dark: #374151; /* gray-700 */
      --tab-inactive-text-dark: #d1d5db; /* gray-300 */
      --results-bg-dark: #1e293b; /* slate-800 */
      --results-text-dark: #60a5fa; /* blue-400 */
      --error-bg-dark: #3f2222; /* custom dark red */
      --error-text-dark: #fca5a5; /* red-300 */
      --success-bg-dark: #163326; /* custom dark green */
      --success-text-dark: #6ee7b7; /* green-300 */
    }
    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--bg-light);
      color: var(--text-light);
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .dark body {
      background-color: var(--bg-dark);
      color: var(--text-dark);
    }
    .card {
      background: var(--card-bg-light);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-light);
      box-shadow: 0 8px 32px var(--shadow-light);
      transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .dark .card {
      background: var(--card-bg-dark);
      border: 1px solid var(--border-dark);
      box-shadow: 0 8px 32px var(--shadow-dark);
    }
    .gradient-bg { background: linear-gradient(135deg, #667eea, #764ba2); }
    .gradient-text { background: linear-gradient(to right, #667eea, #764ba2); -webkit-background-clip: text; background-clip: text; color: transparent; }
    .dark .gradient-text { background: linear-gradient(to right, #8b9efe, #a47ed1); -webkit-background-clip: text; background-clip: text; color: transparent; }

    .gradient-btn { background: linear-gradient(135deg, #667eea, #764ba2); transition: all 0.3s ease; }
    .gradient-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4); }
    .gradient-btn:disabled { opacity: 0.7; cursor: not-allowed; }
    .dark .gradient-btn { background: linear-gradient(135deg, #5a6fdd, #6b4296); }
    .dark .gradient-btn:hover:not(:disabled) { box-shadow: 0 6px 16px rgba(90, 111, 221, 0.3); }


    .drag-active-area {
      background: linear-gradient(to bottom, #e0f2fe, #c7d2fe); /* Lighter blue/indigo gradient */
      border-color: #667eea !important; /* Indigo-500 */
      border-width: 3px !important;
      transform: scale(1.02);
    }
    .dark .drag-active-area {
      background: linear-gradient(to bottom, #1e3a8a, #312e81); /* Darker blue/indigo gradient */
      border-color: #8b9efe !important; /* Lighter indigo for dark mode */
    }

    .file-icon { transition: all 0.3s ease; }
    .file-icon:hover { transform: scale(1.05); }
    .animate-spin { animation: spin 1s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }

    .tab-btn { padding: 0.75rem 1.5rem; border-radius: 0.75rem; font-weight: 500; transition: all 0.3s ease; cursor: pointer; }
    .tab-btn-active { background: linear-gradient(135deg, #667eea, #764ba2); color: white; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3); }
    .dark .tab-btn-active { background: linear-gradient(135deg, #5a6fdd, #6b4296); box-shadow: 0 4px 12px rgba(90, 111, 221, 0.2); }
    
    .tab-btn-inactive { background-color: var(--tab-inactive-bg-light); color: var(--tab-inactive-text-light); }
    .dark .tab-btn-inactive { background-color: var(--tab-inactive-bg-dark); color: var(--tab-inactive-text-dark); }
    .tab-btn-inactive:hover { background-color: #dee2e6; }
    .dark .tab-btn-inactive:hover { background-color: #4b5563; /* gray-600 */ }

    .input-field {
        background-color: var(--input-bg-light);
        border-color: var(--input-border-light);
        color: var(--text-light);
    }
    .dark .input-field {
        background-color: var(--input-bg-dark);
        border-color: var(--input-border-dark);
        color: var(--text-dark);
    }
    .input-field:focus {
        --tw-ring-color: #a5b4fc; /* indigo-300 */
    }
    .dark .input-field:focus {
        --tw-ring-color: #818cf8; /* indigo-400 */
    }


    .color-swatch { width: 40px; height: 40px; border-radius: 0.5rem; margin-right: 0.5rem; border: 1px solid #ccc; display: inline-block; }
    .dark .color-swatch { border-color: #4b5563; }

    .keyword-bar-container { display: flex; align-items: center; margin-bottom: 0.25rem; font-size: 0.875rem; }
    .keyword-bar { height: 20px; background-color: #667eea; border-radius: 0.25rem; margin-right: 0.5rem; color: white; display: flex; align-items: center; padding-left: 0.5rem; font-size: 0.75rem; overflow: hidden; white-space: nowrap; }
    .dark .keyword-bar { background-color: #8b9efe; color: #1f2937; }
    .keyword-label { min-width: 100px; margin-right: 0.5rem; }

    .metadata-grid { display: grid; grid-template-columns: auto 1fr; gap: 0.5rem 1rem; font-size: 0.875rem; }
    .metadata-label { font-weight: 500; color: #4a5568; }
    .dark .metadata-label { color: #9ca3af; /* gray-400 */ }
    .metadata-value { color: #2d3748; word-break: break-all; }
    .dark .metadata-value { color: #d1d5db; /* gray-300 */ }

    .info-card-placeholder { min-height: 300px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 1.5rem; color: var(--placeholder-text-light); }
    .dark .info-card-placeholder { color: var(--placeholder-text-dark); }
    
    /* Toast Notifications */
    .toast-container { position: fixed; top: 1.5rem; right: 1.5rem; z-index: 9999; display: flex; flex-direction: column; gap: 0.75rem; }
    .toast {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-radius: 0.75rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      min-width: 280px;
      max-width: 400px;
      opacity: 0;
      transform: translateX(100%);
      animation: toast-slide-in 0.5s forwards;
    }
    .toast.toast-success { background-color: var(--success-bg-light); color: var(--success-text-light); border-left: 4px solid #10b981; }
    .dark .toast.toast-success { background-color: var(--success-bg-dark); color: var(--success-text-dark); border-left-color: #34d399; }
    .toast.toast-error { background-color: var(--error-bg-light); color: var(--error-text-light); border-left: 4px solid #ef4444; }
    .dark .toast.toast-error { background-color: var(--error-bg-dark); color: var(--error-text-dark); border-left-color: #f87171; }
    .toast.toast-info { background-color: #e0f2fe; color: #0284c7; border-left: 4px solid #38bdf8; } /* Light blue */
    .dark .toast.toast-info { background-color: #1e3a8a; color: #7dd3fc; border-left-color: #38bdf8; } /* Dark blue */

    .toast-icon { margin-right: 0.75rem; font-size: 1.25rem; }
    .toast-message { flex-grow: 1; font-size: 0.875rem; line-height: 1.3; }
    .toast-close-btn {
      background: none; border: none; color: inherit; opacity: 0.7; cursor: pointer; font-size: 1.2rem; margin-left: 1rem;
    }
    .toast-close-btn:hover { opacity: 1; }

    @keyframes toast-slide-in {
      to { opacity: 1; transform: translateX(0); }
    }
    @keyframes toast-fade-out {
      to { opacity: 0; transform: translateY(-20px); height: 0; padding-top:0; padding-bottom:0; margin-bottom:0; }
    }
    .toast-exiting {
        animation: toast-fade-out 0.5s forwards;
    }

    /* Theme Toggle Switch */
    .theme-switch-wrapper { display: flex; align-items: center; justify-content: flex-end; margin-bottom: 1rem; margin-right: 1rem; }
    .theme-switch { display: inline-block; height: 26px; position: relative; width: 50px; }
    .theme-switch input { display:none; }
    .slider {
      background-color: #ccc; bottom: 0; cursor: pointer; left: 0; position: absolute; right: 0; top: 0; transition: .4s; border-radius: 26px;
    }
    .slider:before {
      background-color: #fff; bottom: 3px; content: ""; height: 20px; left: 3px; position: absolute; transition: .4s; width: 20px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
    }
    .theme-switch input:checked + .slider { background-color: #667eea; } /* Active color */
    .theme-switch input:checked + .slider:before { transform: translateX(24px); }
    /* Icons inside the toggle */
    .slider:after { /* Sun icon */
        content: '\f185'; /* FontAwesome sun unicode */
        font-family: "Font Awesome 5 Free"; font-weight: 900;
        color: #facc15; /* yellow-400 */
        font-size: 12px;
        position: absolute;
        left: 6px; top: 50%; transform: translateY(-50%);
        transition: opacity 0.3s ease;
        opacity: 1;
    }
    .theme-switch input:checked + .slider:after { opacity: 0; } /* Hide sun when dark */

    .slider:before { /* Moon icon will be part of the :before element when checked */
        /* Default state is empty or a generic circle */
    }
    .theme-switch input:checked + .slider:before {
        content: '\f186'; /* FontAwesome moon unicode */
        font-family: "Font Awesome 5 Free"; font-weight: 900;
        color: #c084fc; /* purple-400 */
        font-size: 12px;
        line-height: 20px; /* vertically center icon */
        text-align: center;
    }
    .analysis-status-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.3rem 0.5rem;
        margin-bottom: 0.25rem;
        border-radius: 0.375rem; /* rounded-md */
        font-size: 0.8rem;
    }
    .analysis-status-item.pending { background-color: #e5e7eb; color: #4b5563; } /* gray-200, gray-600 */
    .dark .analysis-status-item.pending { background-color: #374151; color: #d1d5db; } /* gray-700, gray-300 */
    .analysis-status-item.loading { background-color: #ccdbfd; color: #4338ca; } /* indigo-200, indigo-700 */
    .dark .analysis-status-item.loading { background-color: #3730a3; color: #a5b4fc; } /* indigo-800, indigo-300 */
    .analysis-status-item.success { background-color: var(--success-bg-light); color: var(--success-text-light); }
    .dark .analysis-status-item.success { background-color: var(--success-bg-dark); color: var(--success-text-dark); }
    .analysis-status-item.error { background-color: var(--error-bg-light); color: var(--error-text-light); }
    .dark .analysis-status-item.error { background-color: var(--error-bg-dark); color: var(--error-text-dark); }
    .status-icon { margin-left: 0.5rem; }

  </style>
</head>
<body>
  <div id="root"></div>

   <script type="text/babel">
    const initialTheme = localStorage.getItem('theme') || 'light';
    if (initialTheme === 'dark') {
      document.documentElement.classList.add('dark');
    }

    // --- Toast Context and Provider (Simplified) ---
    const ToastContext = React.createContext();

    const ToastProvider = ({ children }) => {
      const [toasts, setToasts] = React.useState([]);
      const toastIdRef = React.useRef(0);

      const addToast = (message, type = 'info', duration = 5000) => {
        const id = toastIdRef.current++;
        setToasts(prevToasts => [...prevToasts, { id, message, type, duration }]);
        if (duration) {
          setTimeout(() => removeToast(id), duration);
        }
      };

      const removeToast = (id) => {
        setToasts(prevToasts =>
          prevToasts.map(toast =>
            toast.id === id ? { ...toast, exiting: true } : toast
          )
        );
        // Actual removal after animation
        setTimeout(() => {
            setToasts(currentToasts => currentToasts.filter(toast => toast.id !== id));
        }, 500); // Corresponds to toast-fade-out animation duration
      };

      return (
        <ToastContext.Provider value={{ addToast, removeToast }}>
          {children}
          <div className="toast-container">
            {toasts.map(toast => (
              <div key={toast.id} className={`toast toast-${toast.type} ${toast.exiting ? 'toast-exiting' : ''}`} role="alert" aria-live="assertive">
                <i className={`fas ${toast.type === 'success' ? 'fa-check-circle' : toast.type === 'error' ? 'fa-exclamation-triangle' : 'fa-info-circle'} toast-icon`}></i>
                <span className="toast-message">{toast.message}</span>
                <button onClick={() => removeToast(toast.id)} className="toast-close-btn" aria-label="Close notification">
                  &times;
                </button>
              </div>
            ))}
          </div>
        </ToastContext.Provider>
      );
    };

    const useToasts = () => React.useContext(ToastContext);

    // --- AlgorithmInfoCard Component ---
    const AlgorithmInfoCard = ({ algorithm, fileType, details }) => {
      // ... (existing AlgorithmInfoCard code - no changes needed for this update scope)
      if (!algorithm || !fileType || !details) {
        return null;
      }
      const effectiveFileTypeForDetails = (fileType === 'pdf' && ['LZ77', 'Huffman', 'LZW', 'RLE'].includes(algorithm))
                                      ? 'text'
                                      : fileType;
      const specificDetails = details[algorithm] && details[algorithm][effectiveFileTypeForDetails];

      if (!specificDetails) {
        return (
          <div className="card rounded-xl p-6 shadow-lg h-full">
            <p className="text-sm italic">Detailed information for the '{algorithm}' algorithm on '{fileType}' files is not currently available.</p>
          </div>
        );
      }
      const { description, pros, cons, expectedOutcome } = specificDetails;
      return (
        <div className="card p-4 border border-indigo-200 dark:border-indigo-700 rounded-xl bg-white dark:bg-gray-800 shadow-lg h-full flex flex-col">
          <h4 className="text-base font-semibold text-indigo-700 dark:text-indigo-300 mb-2">
            <i className="fas fa-lightbulb mr-2 text-indigo-500 dark:text-indigo-400"></i>Insights for: <span className="font-bold">{algorithm}</span> on <span className="font-bold">{fileType}</span> files
          </h4>
          {description && <p className="text-xs text-gray-600 dark:text-gray-400 mb-3 italic bg-indigo-50 dark:bg-gray-700 p-2 rounded-md">{description}</p>}
          {pros && pros.length > 0 && (
            <div className="mb-3">
              <h5 className="text-sm font-medium text-green-700 dark:text-green-400 mb-1 flex items-center"><i className="fas fa-check-circle mr-2 text-green-500 dark:text-green-400"></i>Advantages:</h5>
              <ul className="list-disc list-inside text-xs text-gray-700 dark:text-gray-300 space-y-1 pl-4">{pros.map((pro, index) => <li key={`pro-${index}`}>{pro}</li>)}</ul>
            </div>
          )}
          {cons && cons.length > 0 && (
            <div className="mb-3">
              <h5 className="text-sm font-medium text-red-700 dark:text-red-400 mb-1 flex items-center"><i className="fas fa-times-circle mr-2 text-red-500 dark:text-red-400"></i>Considerations:</h5>
              <ul className="list-disc list-inside text-xs text-gray-700 dark:text-gray-300 space-y-1 pl-4">{cons.map((con, index) => <li key={`con-${index}`}>{con}</li>)}</ul>
            </div>
          )}
          {expectedOutcome && (
            <div className="mt-auto pt-2 border-t border-indigo-100 dark:border-gray-700">
              <h5 className="text-sm font-medium text-blue-700 dark:text-blue-400 mb-1 flex items-center"><i className="fas fa-eye mr-2 text-blue-500 dark:text-blue-400"></i>Expected Outcome:</h5>
              <p className="text-xs text-gray-700 dark:text-gray-300 pl-1">{expectedOutcome}</p>
            </div>
          )}
        </div>
      );
    };
    
    // --- ThemeToggle Component ---
    const ThemeToggle = () => {
        const [theme, setTheme] = React.useState(localStorage.getItem('theme') || 'light');

        React.useEffect(() => {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
            localStorage.setItem('theme', theme);
        }, [theme]);

        const toggleTheme = () => {
            setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
        };

        return (
            <div className="theme-switch-wrapper">
                <label className="theme-switch" htmlFor="theme-checkbox" title={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}>
                    <input type="checkbox" id="theme-checkbox" onChange={toggleTheme} checked={theme === 'dark'} />
                    <span className="slider round"></span>
                </label>
            </div>
        );
    };


    function App() {
      const { addToast } = useToasts();
      // --- STATE VARIABLES ---
      const [file, setFile] = React.useState(null); 
      const [fileType, setFileType] = React.useState(''); 
      const [algorithm, setAlgorithm] = React.useState(''); 
      // const [outputPath, setOutputPath] = React.useState(''); // Replaced by toast
      // const [error, setError] = React.useState(''); // Replaced by toast
      const [isCompressing, setIsCompressing] = React.useState(false);
      const [ditheringNumColors, setDitheringNumColors] = React.useState(16);
      const [dctQuality, setDctQuality] = React.useState(50);
      
      const [analysisType, setAnalysisType] = React.useState(''); 
      const [currentAnalysisBatchResults, setCurrentAnalysisBatchResults] = React.useState([]); 
      // const [currentAnalysisBatchErrors, setCurrentAnalysisBatchErrors] = React.useState([]); // Errors handled by toast or within result items
      const [isAnalyzing, setIsAnalyzing] = React.useState(false); // Overall batch analysis status
      const [analysisProgress, setAnalysisProgress] = React.useState({}); // For individual analysis status: { 'Word Count': 'loading', ... }


      const [selectedFiles, setSelectedFiles] = React.useState([]); 
      // const [archiveOutputPath, setArchiveOutputPath] = React.useState(''); // Replaced by toast
      // const [archiveError, setArchiveError] = React.useState(''); // Replaced by toast
      const [isArchiving, setIsArchiving] = React.useState(false);
      const [archiveName, setArchiveName] = React.useState('archive.zip');
      
      const [decompressFile, setDecompressFile] = React.useState(null);
      const [decompressionAlgorithm, setDecompressionAlgorithm] = React.useState('');
      const [isDecompressing, setIsDecompressing] = React.useState(false);
      // const [decompressionError, setDecompressionError] = React.useState(''); // Replaced by toast
      // const [decompressionOutputPath, setDecompressionOutputPath] = React.useState(''); // Replaced by toast
      const [decompressFileType, setDecompressFileType] = React.useState('');
      
      const [isDragging, setIsDragging] = React.useState(false);
      const [activeTab, setActiveTab] = React.useState('compress');
      
      const [algorithmInfoDetails, setAlgorithmInfoDetails] = React.useState(null);
      const [isLoadingAlgorithmDetails, setIsLoadingAlgorithmDetails] = React.useState(true);
      // const [errorLoadingAlgorithmDetails, setErrorLoadingAlgorithmDetails] = React.useState(null); // Handled by toast

      const [downloadLinks, setDownloadLinks] = React.useState({}); // To store multiple download links if needed

      // --- useEffect to fetch algorithm details ---
      React.useEffect(() => {
        const fetchAlgorithmInfo = async () => {
          try {
            setIsLoadingAlgorithmDetails(true);
            const response = await fetch('http://localhost:5000/api/algorithm_details');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            setAlgorithmInfoDetails(data);
          } catch (error) {
            console.error("Could not fetch algorithm details:", error);
            addToast(`Failed to load algorithm details: ${error.message}`, 'error');
          } finally {
            setIsLoadingAlgorithmDetails(false);
          }
        };
        fetchAlgorithmInfo();
      }, [addToast]);

      // --- HELPER FUNCTIONS ---
      const getFileTypeGeneral = (filename) => {
        // ... (existing getFileTypeGeneral code)
        if (!filename) return '';
        const ext = filename.split('.').pop().toLowerCase();
        if (['txt', 'md', 'log', 'csv', 'json', 'xml', 'html', 'css', 'js', 'py'].includes(ext)) return 'text';
        if (['pdf'].includes(ext)) return 'pdf';
        if (['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp', 'ico', 'tiff'].includes(ext)) return 'image';
        if (['mp4', 'avi', 'mov', 'mkv', 'webm', 'flv', 'wmv'].includes(ext)) return 'video';
        if (['mp3', 'wav', 'ogg', 'aac', 'flac', 'm4a', 'wma'].includes(ext)) return 'audio';
        if (['lz77', 'lzw', 'huff', 'cmp', 'zlib', 'zip', 'gz', 'tar', 'rar', '7z', 'rle', 'dctz'].includes(ext)) return 'compressed';
        return 'other';
      };

      const getFileIcon = (type) => {
        // ... (existing getFileIcon code)
        switch(type) {
          case 'text': return 'fa-file-alt';
          case 'pdf': return 'fa-file-pdf';
          case 'image': return 'fa-file-image';
          case 'video': return 'fa-file-video';
          case 'audio': return 'fa-file-audio';
          case 'compressed': return 'fa-file-archive';
          default: return 'fa-file';
        }
      };

      // --- DATA DEFINITIONS ---
      const compressionAlgorithms = { /* ... existing ... */ 
        text: ['LZ77', 'Huffman', 'LZW', 'RLE'],
        pdf: ['LZ77', 'Huffman', 'LZW', 'RLE'], // Can use text algos
        image: ['ColorLossy', 'Deflate', 'Lossless', 'Lossy', 'DCT', 'Dithering'],
        video: ['HEVC', 'AVC'],
      };
      const decompressionAlgorithmsList = [ /* ... existing ... */ 
          { value: 'LZ77', label: 'LZ77 (.lz77)', extensions: ['.lz77'] },
          { value: 'LZW', label: 'LZW (.lzw, .cmp)', extensions: ['.lzw', '.cmp'] },
          { value: 'Huffman', label: 'Huffman (.huff)', extensions: ['.huff'] },
          { value: 'RLE', label: 'RLE (.rle)', extensions: ['.rle'] },
          { value: 'DCT', label: 'DCT (.dctz)', extensions: ['.dctz'] },
          { value: 'Deflate', label: 'Deflate (.zlib)', extensions: ['.zlib'] },
      ];
      const analysisTypes = { /* ... existing ... */ 
        text: ['Word Count', 'Character Count', 'Keyword Density'],
        pdf: ['Word Count', 'Character Count', 'Keyword Density'], // Can use text analyses
        image: ['Dimension & Size', 'Color Palette', 'Metadata'],
        video: ['Duration & Codec', 'Resolution', 'Frame Rate'],
        audio: ['Duration & Bitrate', 'Format Info'], // Example, backend needs to support
        compressed: ['File Size', 'MIME Type'], // Basic info for compressed
        other: ['File Size', 'MIME Type'] // Basic info for others
      };
      
      // --- API CALLS & LOGIC ---
      const clearAllResultsAndStates = () => {
        // Clears operational states and results, not the selected files themselves
        // setOutputPath(''); setError(''); // Handled by toasts now
        setCurrentAnalysisBatchResults([]);
        setAnalysisProgress({});
        // setArchiveOutputPath(''); setArchiveError(''); // Handled by toasts
        // setDecompressionOutputPath(''); setDecompressionError(''); // Handled by toasts
        setDownloadLinks({}); // Clear any previous download links
      };
      
      // --- EVENT HANDLERS ---
      const handleSingleFileChange = async (selectedFile) => {
        if (selectedFile) {
          const currentFileType = getFileTypeGeneral(selectedFile.name);
          setFile(selectedFile); 
          setFileType(currentFileType);
          
          // Reset states for other operations and manual analysis dropdown
          setAlgorithm(''); 
          setAnalysisType(''); 
          setSelectedFiles([]); 
          setDecompressFile(null); setDecompressionAlgorithm(''); setDecompressFileType('');
          setDitheringNumColors(16); setDctQuality(50);

          clearAllResultsAndStates(); 
          setActiveTab('results'); 

          const allAnalysisTypesForFile = analysisTypes[currentFileType] || 
                                          (currentFileType === 'pdf' ? analysisTypes.text : []) ||
                                          analysisTypes.other;


          if (allAnalysisTypesForFile.length > 0) {
            setIsAnalyzing(true); 
            
            let initialProgress = {};
            allAnalysisTypesForFile.forEach(type => initialProgress[type] = 'pending');
            setAnalysisProgress(initialProgress);

            const resultsAccumulator = [];
            
            for (const analysisOption of allAnalysisTypesForFile) {
              setAnalysisProgress(prev => ({ ...prev, [analysisOption]: 'loading' }));
              const formData = new FormData();
              formData.append('file', selectedFile); 
              formData.append('analysis_type', analysisOption);
              try {
                const response = await fetch('http://localhost:5000/analyze', { method: 'POST', body: formData });
                const resultData = await response.json(); // Try to parse JSON regardless of status for error messages
                if (!response.ok) {
                  throw new Error(resultData.error || `Analysis for ${analysisOption} failed: ${response.statusText}`);
                }
                resultsAccumulator.push(resultData);
                setAnalysisProgress(prev => ({ ...prev, [analysisOption]: 'success' }));
              } catch (err) {
                const errorResult = { 
                  filename: selectedFile.name, 
                  analysis_type: analysisOption, 
                  error_summary: err.message, 
                  category: currentFileType, 
                  file_size_bytes: selectedFile.size,
                  mime_type: selectedFile.type || 'unknown'
                };
                resultsAccumulator.push(errorResult);
                setAnalysisProgress(prev => ({ ...prev, [analysisOption]: 'error' }));
                console.error(`Auto-Analysis error for ${analysisOption}:`, err);
                // No individual toast here, error shown in results list
              }
            }
            setCurrentAnalysisBatchResults(resultsAccumulator);
            setIsAnalyzing(false);
          } else {
             setCurrentAnalysisBatchResults([{
              filename: selectedFile.name,
              analysis_type: "Basic File Info", 
              category: currentFileType,
              file_size_bytes: selectedFile.size,
              mime_type: selectedFile.type || 'unknown',
              info: "No specific automated analyses available for this file type. Basic details shown."
            }]);
            setIsAnalyzing(false); 
          }
        }
      };

      const handleDecompressFileChange = (selectedFile) => {
        // ... (existing handleDecompressFileChange, but remove setError/setOutputPath)
        if (selectedFile) {
            const type = getFileTypeGeneral(selectedFile.name);
            setDecompressFile(selectedFile); setDecompressFileType(type);
            const ext = selectedFile.name.split('.').pop().toLowerCase();
            const suggestedAlgo = decompressionAlgorithmsList.find(algo => algo.extensions.includes('.' + ext));
            setDecompressionAlgorithm(suggestedAlgo ? suggestedAlgo.value : '');
            
            clearAllResultsAndStates();
            setFile(null); setFileType(''); setAlgorithm(''); 
            setAnalysisType(''); 
            setSelectedFiles([]); 
        }
      };

      const handleMultiFileChange = (selectedFileList) => {
          // ... (existing handleMultiFileChange, but remove setError/setOutputPath)
          const filesArray = Array.from(selectedFileList);
          setSelectedFiles(filesArray);
          clearAllResultsAndStates();
          setFile(null); setFileType(''); setAlgorithm(''); 
          setAnalysisType(''); 
          setDecompressFile(null); setDecompressionAlgorithm('');
      };
      
      const handleDrop = (e) => { /* ... existing, no changes needed for this scope ... */ 
        e.preventDefault(); setIsDragging(false);
        const droppedFiles = Array.from(e.dataTransfer.files);
        if (droppedFiles.length === 0) return;

        if (activeTab === 'archive') {
            handleMultiFileChange(droppedFiles);
        } else if (activeTab === 'decompress') {
            handleDecompressFileChange(droppedFiles[0]);
        } else { 
            handleSingleFileChange(droppedFiles[0]); // For 'compress' and 'analyze' tabs
        }
      };
      const handleDragEnter = (e) => { e.preventDefault(); setIsDragging(true); };
      const handleDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };
      const handleDragOver = (e) => { e.preventDefault(); }; // Critical for drop to work

      const handleCompress = async () => {
        if (!file || !algorithm) { addToast('Please select a file and a compression algorithm.', 'error'); setActiveTab('results'); return; }
        clearAllResultsAndStates(); setIsCompressing(true); 
        const formData = new FormData();
        formData.append('file', file); formData.append('algorithm', algorithm);
        if (algorithm === 'Dithering' && fileType === 'image') formData.append('num_colors', ditheringNumColors);
        else if (algorithm === 'DCT' && fileType === 'image') formData.append('quality', dctQuality);
        try {
          const response = await fetch('http://localhost:5000/compress', { method: 'POST', body: formData });
          if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `Compression failed: ${response.statusText}`); }
          const blob = await response.blob();
          const downloadUrl = window.URL.createObjectURL(blob);
          const downloadName = `compressed_${file.name}`;
          setDownloadLinks(prev => ({ ...prev, compression: { url: downloadUrl, name: downloadName } }));
          addToast(`Compression successful! Ready to download.`, 'success');
        } catch (err) { addToast(`Compression error: ${err.message}`, 'error'); console.error("Compression error:", err); }
        finally { setIsCompressing(false); setActiveTab('results'); }
      };

      const handleDecompress = async () => {
        if (!decompressFile || !decompressionAlgorithm) { addToast('Please select a file and a decompression algorithm.', 'error'); setActiveTab('results'); return; }
        clearAllResultsAndStates(); setIsDecompressing(true); 
        const formData = new FormData();
        formData.append('file', decompressFile); formData.append('algorithm', decompressionAlgorithm);
        try {
          const response = await fetch('http://localhost:5000/decompress', { method: 'POST', body: formData });
          if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `Decompression failed: ${response.statusText}`); }
          const blob = await response.blob();
          const downloadUrl = window.URL.createObjectURL(blob);
          const downloadName = `decompressed_${decompressFile.name.replace(/\.(lz77|lzw|huff|cmp|rle|dctz|zlib)$/i, '') || 'file'}`;
          setDownloadLinks(prev => ({ ...prev, decompression: { url: downloadUrl, name: downloadName } }));
          addToast('Decompression successful! Ready to download.', 'success');
        } catch (err) { addToast(`Decompression error: ${err.message}`, 'error'); console.error("Decompression error:", err); }
        finally { setIsDecompressing(false); setActiveTab('results');}
      };

      const handleManualAnalyze = async () => {
        if (!file || !analysisType) { 
          addToast('Please select a file and an analysis type for manual analysis.', 'error');
          setCurrentAnalysisBatchResults([]); 
          setActiveTab('results');
          return;
        }
        
        setIsAnalyzing(true); // For the specific manual analysis spinner
        clearAllResultsAndStates(); 
        setAnalysisProgress({ [analysisType]: 'loading' });


        const formData = new FormData();
        formData.append('file', file); 
        formData.append('analysis_type', analysisType);

        try {
          const response = await fetch('http://localhost:5000/analyze', { method: 'POST', body: formData });
          const resultData = await response.json();
          if (!response.ok) {
            throw new Error(resultData.error || `Analysis failed: ${response.statusText}`);
          }
          setCurrentAnalysisBatchResults([resultData]); 
          setAnalysisProgress({ [analysisType]: 'success' });
          addToast(`Manual analysis for ${analysisType} complete.`, 'info');
        } catch (err) {
          addToast(`Manual Analysis error for ${analysisType}: ${err.message}`, 'error');
          setCurrentAnalysisBatchResults([{ 
              filename: file.name, 
              analysis_type: analysisType, 
              error_summary: err.message, 
              category: fileType, 
              file_size_bytes: file.size,
              mime_type: file.type || 'unknown'
          }]);
          setAnalysisProgress({ [analysisType]: 'error' });
          console.error("Manual Analysis error:", err);
        } finally {
          setIsAnalyzing(false); // Reset overall analyzing state if it was used
          setActiveTab('results');
        }
      };

      const handleArchive = async () => {
          if (selectedFiles.length === 0) { addToast('Please select files to archive.', 'error'); setActiveTab('results'); return; }
          clearAllResultsAndStates(); setIsArchiving(true); 
          const formData = new FormData();
          selectedFiles.forEach(f => formData.append('files[]', f));
          formData.append('archive_name', archiveName);
          try {
              const response = await fetch('http://localhost:5000/archive', { method: 'POST', body: formData });
              if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `Archiving failed: ${response.statusText}`);}
              const blob = await response.blob();
              const downloadUrl = window.URL.createObjectURL(blob);
              const downloadName = archiveName || 'archive.zip';
              setDownloadLinks(prev => ({ ...prev, archive: { url: downloadUrl, name: downloadName } }));
              addToast('Archiving successful! Ready to download.', 'success');
          } catch (err) { addToast(`Archiving error: ${err.message}`, 'error'); console.error("Archiving error:", err); }
          finally { setIsArchiving(false); setActiveTab('results'); }
      };

      // --- UI COMPONENTS ---
      const FileInputArea = ({ forTab }) => {
        let currentFileDisplay = null, currentFileTypeDisplay = '', fileCountDisplay = 0, displayFilesList = [];
        
        if (forTab === 'compress' || forTab === 'analyze') { 
            currentFileDisplay = file; currentFileTypeDisplay = fileType; 
        } else if (forTab === 'decompress') { 
            currentFileDisplay = decompressFile; currentFileTypeDisplay = decompressFileType; 
        } else if (forTab === 'archive') { 
            fileCountDisplay = selectedFiles.length; displayFilesList = selectedFiles; 
        }

        const allowMultiple = forTab === 'archive';
        const inputId = `fileInput-${forTab}`;

        const handleChange = (e) => {
            if (forTab === 'archive') handleMultiFileChange(e.target.files);
            else if (forTab === 'decompress') handleDecompressFileChange(e.target.files[0]);
            else handleSingleFileChange(e.target.files[0]);
        };
        
        const noFileMessage = () => {
            let message = "Drag & drop ";
            if (forTab === 'archive') message += "files here, or click to browse.";
            else if (forTab === 'compress') message += "a file to compress, or click to browse.";
            else if (forTab === 'analyze') message += "a file to analyze, or click to browse.";
            else if (forTab === 'decompress') message += "a compressed file, or click to browse.";
            else message += "a file here, or click to browse.";
            return message;
        };

        return (
        <div className={`border-2 border-dashed rounded-2xl p-8 mb-6 text-center transition-all duration-300 ease-in-out ${isDragging ? 'drag-active-area border-indigo-500 dark:border-indigo-400' : 'border-gray-300 dark:border-gray-600 hover:border-indigo-400 dark:hover:border-indigo-500'}`}
          onDragEnter={handleDragEnter} onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}
          aria-label={`File input area for ${forTab}`}>
          <input type="file" id={inputId} className="hidden" onChange={handleChange} multiple={allowMultiple} aria-hidden="true" tabIndex="-1" />
          <label htmlFor={inputId} className="cursor-pointer block w-full h-full">
            {currentFileDisplay ? (
              <div className="flex flex-col items-center space-y-2"> <i className={`fas ${getFileIcon(currentFileTypeDisplay)} text-4xl text-indigo-500 dark:text-indigo-400 file-icon ${isDragging ? 'fa-beat-fade' : ''}`}></i> <span className="font-medium text-indigo-600 dark:text-indigo-300">{currentFileDisplay.name}</span> <span className="text-sm text-gray-500 dark:text-gray-400">{(currentFileDisplay.size / 1024).toFixed(2)} KB</span> </div>
            ) : fileCountDisplay > 0 ? (
                 <div className="flex flex-col items-center space-y-2"> <i className={`fas fa-file-archive text-4xl text-indigo-500 dark:text-indigo-400 file-icon ${isDragging ? 'fa-beat-fade' : ''}`}></i> <span className="font-medium text-indigo-600 dark:text-indigo-300">{fileCountDisplay} file(s) selected</span> <div className="max-h-24 overflow-y-auto w-full px-2"> <ul className="text-sm text-gray-500 dark:text-gray-400 list-disc list-inside text-left">{displayFilesList.map((f, index) => <li key={index} className="truncate" title={f.name}>{f.name} ({(f.size / 1024).toFixed(2)} KB)</li>)}</ul> </div> </div>
            ) : (
              <div className="flex flex-col items-center space-y-3"> 
                <div className={`w-16 h-16 flex items-center justify-center rounded-full bg-indigo-100 dark:bg-gray-700 transition-transform duration-300 ${isDragging ? 'scale-110' : ''}`}> 
                    <i className={`fas ${isDragging ? 'fa-file-import' : 'fa-cloud-upload-alt'} text-2xl text-indigo-500 dark:text-indigo-400 transition-all duration-300 ${isDragging ? 'animate-pulse' : ''}`}></i> 
                </div> 
                <span className="font-medium text-gray-700 dark:text-gray-300">{isDragging ? "Drop it like it's hot!" : noFileMessage()}</span> 
                {!isDragging && <span className="text-sm text-gray-500 dark:text-gray-400"></span>}
              </div>
            )}
          </label>
        </div>
      )};
      
      const AnalysisResultsDisplay = ({ result }) => { /* ... existing, minor style tweaks for dark mode if needed ... */ 
        if (!result) return null;
        
        const renderMetadataObject = (data, indentLevel = 0) => Object.entries(data).map(([key, value]) => {
            const isNestedObject = typeof value === 'object' && value !== null && !Array.isArray(value);
            return <React.Fragment key={key}><div className="metadata-label" style={{ paddingLeft: `${indentLevel * 1}rem` }}>{key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</div><div className="metadata-value">{isNestedObject ? <div className="mt-1 mb-1 pl-2 border-l-2 border-gray-300 dark:border-gray-600">{renderMetadataObject(value, indentLevel + 1)}</div> : Array.isArray(value) ? value.join(', ') : String(value)}</div></React.Fragment>;
        });

        if (result.analysis_type === 'Dimension & Size' && (result.dimensions || result.format || result.mode)) {
            return <div className="mt-3"> <h3 className="text-md font-semibold text-gray-600 dark:text-gray-300 mb-2">Image Properties:</h3> <div className="metadata-grid"> {result.dimensions && <><span className="metadata-label">Dimensions:</span><span className="metadata-value">{result.dimensions}</span></>} {result.format && <><span className="metadata-label">Format:</span><span className="metadata-value">{result.format}</span></>} {result.mode && <><span className="metadata-label">Mode:</span><span className="metadata-value">{result.mode}</span></>} </div> {result.info && <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{result.info}</p>} </div>;
        }
        if (result.analysis_type === 'Metadata' && result.metadata) { 
            const { EXIF, ...otherMetadata } = (typeof result.metadata === 'object' && result.metadata !== null) ? result.metadata : {};
            const hasOtherMeta = Object.keys(otherMetadata).length > 0;
            const hasExif = EXIF && typeof EXIF === 'object' && Object.keys(EXIF).length > 0;
            return <div className="mt-3"> <h3 className="text-md font-semibold text-gray-600 dark:text-gray-300 mb-2">File Metadata:</h3> 
            {hasOtherMeta && <div className="metadata-grid mb-3"> {renderMetadataObject(otherMetadata)} </div>} 
            {hasExif && <> <h4 className="text-sm font-semibold text-gray-500 dark:text-gray-400 mt-2 mb-1">EXIF Data:</h4> <div className="metadata-grid"> {renderMetadataObject(EXIF)} </div> </>} 
            {(!hasOtherMeta && !hasExif && result.metadata === "No readily extractable metadata found.") && <p className="text-sm text-gray-500 dark:text-gray-400">{result.metadata}</p>}
            {(!hasOtherMeta && !hasExif && typeof result.metadata !== 'string') && <p className="text-sm text-gray-500 dark:text-gray-400">No structured metadata found.</p>}
            {result.info && <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{result.info}</p>} </div>; 
        }
        if (result.analysis_type === 'Color Palette' && result.color_palette) {
            return <div className="mt-3"> <h3 className="text-md font-semibold text-gray-600 dark:text-gray-300 mb-2">Dominant Colors:</h3> <div className="flex flex-wrap items-center"> {result.color_palette.map((color, index) => <div key={index} className="flex items-center mr-4 mb-2 p-1 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm"> <div className="color-swatch" style={{ backgroundColor: color.hex }}></div> <span className="text-xs text-gray-700 dark:text-gray-300">{color.hex} ({color.percentage}%)</span> </div>)} </div> {result.average_color_hex && <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">Average Color: <span className="color-swatch" style={{ backgroundColor: result.average_color_hex, display: 'inline-block', verticalAlign: 'middle', width: '1em', height: '1em' }}></span> {result.average_color_hex}</p>} {result.info && <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{result.info}</p>} </div>;
        }
        if (result.analysis_type === 'Keyword Density' && result.top_keywords) { 
            const maxCount = result.top_keywords.length > 0 ? Math.max(...result.top_keywords.map(kw => kw.count)) : 1; 
            return <div className="mt-3"> <h3 className="text-md font-semibold text-gray-600 dark:text-gray-300 mb-2">Top Keywords (Top {result.top_keywords.length}):</h3> {result.top_keywords.length > 0 ? result.top_keywords.map((keyword, index) => <div key={index} className="keyword-bar-container"> <span className="keyword-label truncate" title={keyword.word}>{keyword.word}</span> <div className="flex-grow bg-gray-200 dark:bg-gray-600 rounded-full h-5"> <div className="keyword-bar" style={{ width: `${Math.max(5, (keyword.count / maxCount) * 100)}%` }} title={`${keyword.count} occurrences (${keyword.percentage}%)`}> <span className="ml-1 text-xs">{keyword.count}</span> </div> </div> <span className="text-xs text-gray-500 dark:text-gray-400 ml-2 w-12 text-right">({keyword.percentage}%)</span> </div>) : <p className="text-sm text-gray-500 dark:text-gray-400">No keywords found.</p>} {result.total_analyzed_words !== undefined && <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Total words analyzed for density: {result.total_analyzed_words}</p>} {result.info && <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{result.info}</p>} </div>; 
        }
        
        const { filename: _f, category: _c, analysis_type: _a, file_size_bytes: _s, mime_type: _m, error_summary: _es, ...specificData } = result;
        const specificDataEntries = Object.entries(specificData).filter(([key]) => !['text_analysis_error', 'image_analysis_error', 'video_analysis_error', 'audio_analysis_error', 'info', 'full_video_stream_info'].includes(key));

        return <div className="mt-3"> 
            {result.analysis_type !== "Basic File Info" && !result.error_summary && <h3 className="text-md font-semibold text-gray-600 dark:text-gray-300 mb-2">Analysis Details:</h3>}
            {specificDataEntries.length > 0 ? (
                <div className="metadata-grid"> 
                    {specificDataEntries.map(([key, value]) => <React.Fragment key={key}><span className="metadata-label">{key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</span><span className="metadata-value">{String(value)}</span></React.Fragment>)}
                </div>
            ) : ( result.analysis_type !== "Basic File Info" && !result.error_summary && (result.analysis_type !== 'File Size' && result.analysis_type !== 'MIME Type') && <p className="text-sm text-gray-500 dark:text-gray-400">No specific details for this analysis type beyond basic file information.</p> )}
            {result.full_video_stream_info && typeof result.full_video_stream_info === 'object' && (
                <> <h4 className="text-sm font-semibold text-gray-500 dark:text-gray-400 mt-3 mb-1">Full Video Stream Info:</h4> <div className="metadata-grid text-xs bg-gray-50 dark:bg-gray-700 p-2 rounded"> {renderMetadataObject(result.full_video_stream_info)} </div> </>
            )}
            {result.info && result.info !== "No specific automated analyses available for this file type. Basic details shown." && <p className="text-xs text-gray-500 dark:text-gray-400 mt-2 italic">{result.info}</p>}
        </div>;
      };

      // --- MAIN APP RENDER ---
      return (
        <div className="min-h-screen flex flex-col items-center justify-start p-4 pt-8 sm:pt-12">
            <ThemeToggle />
            <div className="flex flex-col md:flex-row gap-6 items-start w-full max-w-6xl mx-auto">
            {/* Left Column: Main App Controls */}
            <div className="w-full md:w-2/3 lg:w-3/5 order-1 md:order-1 card rounded-3xl p-6 sm:p-8 shadow-xl relative overflow-hidden">
                <div className="absolute top-0 right-0 w-32 h-32 rounded-full bg-indigo-100/50 dark:bg-indigo-900/30 -mr-16 -mt-16 z-0"></div>
                <div className="absolute bottom-0 left-0 w-24 h-24 rounded-full bg-purple-100/50 dark:bg-purple-900/30 -ml-12 -mb-12 z-0"></div>
                <div className="relative z-10">
                <h1 className="text-3xl font-bold mb-2 text-center gradient-text">File Management Suite</h1>
                <p className="text-center text-gray-500 dark:text-gray-400 mb-6">Compress, Decompress, Analyze, and Archive your files.</p>

                <div className="flex justify-center space-x-1 sm:space-x-2 mb-6 flex-wrap" role="tablist" aria-label="File Operations">
                    {['compress', 'decompress', 'analyze', 'archive', 'results'].map(tabName => (
                    <button key={tabName} onClick={() => setActiveTab(tabName)}
                        className={`tab-btn capitalize text-sm sm:text-base ${activeTab === tabName ? 'tab-btn-active' : 'tab-btn-inactive'} my-1`}
                        role="tab" aria-selected={activeTab === tabName} aria-controls={`${tabName}-panel`} id={`${tabName}-tab`}>
                        <i className={`fas ${ tabName === 'compress' ? 'fa-compress-alt' : tabName === 'decompress' ? 'fa-folder-open' : tabName === 'analyze' ? 'fa-search-plus' : tabName === 'archive' ? 'fa-archive' : 'fa-poll'} mr-2`}></i>
                        {tabName}
                    </button>
                    ))}
                </div>

                {/* Tab Panels Wrapper */}
                <div>
                    {activeTab === 'compress' && <div role="tabpanel" id="compress-panel" aria-labelledby="compress-tab">
                        <FileInputArea forTab="compress" />
                        {fileType && (compressionAlgorithms[fileType] || (compressionAlgorithms.pdf && fileType === 'pdf')) && (
                            <div className="mb-6">
                            <div className="space-y-4">
                                <div>
                                <label htmlFor="compressAlgorithmSelect" className="block text-gray-700 dark:text-gray-300 font-medium mb-2"><i className="fas fa-sliders-h mr-2 text-indigo-500 dark:text-indigo-400"></i>Select Compression Algorithm</label>
                                <select id="compressAlgorithmSelect" className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 focus:outline-none input-field"
                                    value={algorithm} onChange={(e) => setAlgorithm(e.target.value)}
                                    disabled={!(compressionAlgorithms[fileType] || (fileType === 'pdf' && compressionAlgorithms.pdf)) || (compressionAlgorithms[fileType] || (fileType === 'pdf' ? compressionAlgorithms.pdf : [])).length === 0}>
                                    <option value="">Choose an algorithm</option>
                                    {(compressionAlgorithms[fileType] || (fileType === 'pdf' ? compressionAlgorithms.pdf : [])).map(algo => <option key={algo} value={algo}>{algo}</option>)}
                                    {(!(compressionAlgorithms[fileType] || (fileType === 'pdf' && compressionAlgorithms.pdf)) || (compressionAlgorithms[fileType] || (fileType === 'pdf' ? compressionAlgorithms.pdf : [])).length === 0) && <option value="" disabled>No algorithms for this file type</option>}
                                </select>
                                </div>
                                {algorithm === 'Dithering' && fileType === 'image' && ( /* ... Dithering options ... */ 
                                <div className="pt-2">
                                    <label htmlFor="ditheringColors" className="block text-gray-700 dark:text-gray-300 font-medium mb-2"><i className="fas fa-palette mr-2 text-indigo-500 dark:text-indigo-400"></i>Number of Colors (Dithering)</label>
                                    <input id="ditheringColors" type="number" className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 focus:outline-none input-field"
                                        value={ditheringNumColors} onChange={(e) => setDitheringNumColors(Math.max(2, Math.min(256, parseInt(e.target.value) || 16)))} min="2" max="256" />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Reduce colors (2-256).</p>
                                </div>
                                )}
                                {algorithm === 'DCT' && fileType === 'image' && ( /* ... DCT options ... */ 
                                <div className="pt-2">
                                    <label htmlFor="dctQuality" className="block text-gray-700 dark:text-gray-300 font-medium mb-2"><i className="fas fa-cogs mr-2 text-indigo-500 dark:text-indigo-400"></i>Compression Quality (DCT: 1-100)</label>
                                    <input id="dctQuality" type="number" className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 focus:outline-none input-field"
                                        value={dctQuality} onChange={(e) => setDctQuality(Math.max(1, Math.min(100, parseInt(e.target.value) || 50)))} min="1" max="100" />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Higher quality = less compression.</p>
                                </div>
                                )}
                            </div>
                            </div>
                        )}
                        <button className="w-full gradient-btn text-white p-3 rounded-xl font-medium flex items-center justify-center mt-2" disabled={!file || !algorithm || isCompressing} onClick={handleCompress}>
                            {isCompressing ? (<><svg className="w-5 h-5 mr-2 animate-spin" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" /><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" /></svg>Compressing...</>) : (<><i className="fas fa-compress-alt mr-2"></i>Compress File</>)}
                        </button>
                    </div>}

                    {activeTab === 'decompress' && <div role="tabpanel" id="decompress-panel" aria-labelledby="decompress-tab">
                        <FileInputArea forTab="decompress" />
                        {decompressFile && (
                            <div className="mb-6 space-y-4">
                            <div>
                                <label htmlFor="decompressAlgorithmSelect" className="block text-gray-700 dark:text-gray-300 font-medium mb-2"><i className="fas fa-cogs mr-2 text-indigo-500 dark:text-indigo-400"></i>Select Decompression Algorithm</label>
                                <select id="decompressAlgorithmSelect" className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 focus:outline-none input-field"
                                value={decompressionAlgorithm} onChange={(e) => setDecompressionAlgorithm(e.target.value)}>
                                <option value="">Choose an algorithm</option>
                                {decompressionAlgorithmsList.map(algo => <option key={algo.value} value={algo.value}>{algo.label}</option>)}
                                </select>
                                <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Auto-selected based on extension if possible.</p>
                            </div>
                            </div>
                        )}
                        <button className="w-full gradient-btn text-white p-3 rounded-xl font-medium flex items-center justify-center" disabled={!decompressFile || !decompressionAlgorithm || isDecompressing} onClick={handleDecompress}>
                            {isDecompressing ? (<><svg className="w-5 h-5 mr-2 animate-spin" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" /><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" /></svg>Decompressing...</>) : (<><i className="fas fa-folder-open mr-2"></i>Decompress File</>)}
                        </button>
                    </div>}

                    {activeTab === 'analyze' && <div role="tabpanel" id="analyze-panel" aria-labelledby="analyze-tab">
                        <FileInputArea forTab="analyze" />
                        {fileType && (analysisTypes[fileType] || (fileType === 'pdf' && analysisTypes.pdf)) && (
                            <div className="mb-6 space-y-4">
                            <div>
                                <label htmlFor="analysisTypeSelect" className="block text-gray-700 dark:text-gray-300 font-medium mb-2"><i className="fas fa-lightbulb mr-2 text-indigo-500 dark:text-indigo-400"></i>Select Analysis Type (Manual)</label>
                                <select id="analysisTypeSelect" className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 focus:outline-none input-field"
                                value={analysisType} onChange={(e) => setAnalysisType(e.target.value)}
                                disabled={!(analysisTypes[fileType] || (fileType === 'pdf' && analysisTypes.pdf)) || (analysisTypes[fileType] || (fileType === 'pdf' ? analysisTypes.pdf : [])).length === 0}>
                                <option value="">Choose an analysis type</option>
                                {(analysisTypes[fileType] || (fileType === 'pdf' ? analysisTypes.pdf : [])).map(type => <option key={type} value={type}>{type}</option>)}
                                {(!(analysisTypes[fileType] || (fileType === 'pdf' && analysisTypes.pdf)) || (analysisTypes[fileType] || (fileType === 'pdf' ? analysisTypes.pdf : [])).length === 0) && <option value="" disabled>No analysis options</option>}
                                </select>
                                <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">A comprehensive summary is run automatically on file upload. Select here for a specific manual analysis.</p>
                            </div>
                            </div>
                        )}
                        <button className="w-full gradient-btn text-white p-3 rounded-xl font-medium flex items-center justify-center" disabled={!file || !analysisType || isAnalyzing && analysisProgress[analysisType] === 'loading'} onClick={handleManualAnalyze}>
                            {isAnalyzing && analysisProgress[analysisType] === 'loading' ? (<><svg className="w-5 h-5 mr-2 animate-spin" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" /><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" /></svg>Analyzing {analysisType}...</>) : (<><i className="fas fa-play-circle mr-2"></i>Run Manual Analysis</>)}
                        </button>
                    </div>}
                    
                    {activeTab === 'archive' && <div role="tabpanel" id="archive-panel" aria-labelledby="archive-tab">
                        <FileInputArea forTab="archive" />
                        {selectedFiles.length > 0 && (
                            <div className="mb-6 space-y-4">
                                <div>
                                    <label htmlFor="archiveNameInput" className="block text-gray-700 dark:text-gray-300 font-medium mb-2"><i className="fas fa-file-signature mr-2 text-indigo-500 dark:text-indigo-400"></i>Archive Name</label>
                                    <input id="archiveNameInput" type="text" className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 focus:outline-none input-field"
                                        value={archiveName} onChange={(e) => setArchiveName(e.target.value)} placeholder="archive.zip"/>
                                </div>
                            </div>
                        )}
                        <button className="w-full gradient-btn text-white p-3 rounded-xl font-medium flex items-center justify-center" disabled={selectedFiles.length === 0 || isArchiving} onClick={handleArchive}>
                            {isArchiving ? (<><svg className="w-5 h-5 mr-2 animate-spin" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" /><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" /></svg>Archiving...</>) : (<><i className="fas fa-archive mr-2"></i>Create Archive</>)}
                        </button>
                    </div>}

                    {activeTab === 'results' && <div role="tabpanel" id="results-panel" aria-labelledby="results-tab" aria-live="polite">
                        <h2 className="text-xl font-semibold text-gray-700 dark:text-gray-200 mb-3">Results</h2>
                        
                        {Object.entries(downloadLinks).map(([key, link]) => (
                            link && <div key={key} className="bg-green-50 dark:bg-green-900/50 p-4 rounded-xl mb-3"><div className="flex items-center mb-2"><i className="fas fa-check-circle text-green-500 dark:text-green-400 mr-2"></i><p className="text-green-600 dark:text-green-300 font-medium capitalize">{key} successful!</p></div><a href={link.url} download={link.name} className="flex items-center justify-center bg-white dark:bg-gray-700 border border-indigo-200 dark:border-indigo-600 hover:bg-indigo-50 dark:hover:bg-gray-600 text-indigo-600 dark:text-indigo-300 p-3 rounded-xl mt-2 transition-all font-medium" ><i className="fas fa-download mr-2"></i>Download {link.name}</a></div>
                        ))}
                        
                        {/* Display Batch Analysis Progress/Results */}
                        {currentAnalysisBatchResults.length > 0 && currentAnalysisBatchResults.map((singleAnalysisResult, index) => (
                            <div key={index} className="bg-blue-50 dark:bg-slate-800 p-4 rounded-xl mb-4 shadow">
                            <div className="flex items-center justify-between mb-2">
                                <p className="text-blue-700 dark:text-blue-300 font-semibold">
                                <i className="fas fa-chart-line text-blue-500 dark:text-blue-400 mr-2"></i>
                                {singleAnalysisResult.analysis_type || 'Analysis Summary'} for: <span className="font-medium text-blue-600 dark:text-blue-200">{singleAnalysisResult.filename}</span>
                                </p>
                                {analysisProgress[singleAnalysisResult.analysis_type] && (
                                    <span className={`analysis-status-item ${analysisProgress[singleAnalysisResult.analysis_type]}`}>
                                        {analysisProgress[singleAnalysisResult.analysis_type]}
                                        {analysisProgress[singleAnalysisResult.analysis_type] === 'loading' && <i className="fas fa-spinner fa-spin status-icon"></i>}
                                        {analysisProgress[singleAnalysisResult.analysis_type] === 'success' && <i className="fas fa-check-circle status-icon"></i>}
                                        {analysisProgress[singleAnalysisResult.analysis_type] === 'error' && <i className="fas fa-exclamation-circle status-icon"></i>}
                                    </span>
                                )}
                            </div>
                            
                            {!singleAnalysisResult.error_summary && ( 
                                <div className="metadata-grid mb-3 text-sm"> 
                                {singleAnalysisResult.category && <><span className="metadata-label">Category:</span><span className="metadata-value">{singleAnalysisResult.category}</span></>}
                                {singleAnalysisResult.file_size_bytes !== undefined && <><span className="metadata-label">Size:</span><span className="metadata-value">{(singleAnalysisResult.file_size_bytes / 1024).toFixed(2)} KB</span></>}
                                {singleAnalysisResult.mime_type && <><span className="metadata-label">MIME Type:</span><span className="metadata-value">{singleAnalysisResult.mime_type}</span></>}
                                </div>
                            )}
                            <hr className="my-2 border-blue-200 dark:border-slate-700"/>
                            
                            {singleAnalysisResult.error_summary ? (
                                <div className="mt-2 bg-red-100 dark:bg-red-900/50 p-3 rounded-md text-xs text-red-700 dark:text-red-300">
                                    <p><strong>Error during {singleAnalysisResult.analysis_type || 'this analysis'}:</strong> {singleAnalysisResult.error_summary}</p>
                                </div>
                            ) : (
                                <AnalysisResultsDisplay result={singleAnalysisResult} />
                            )}
                            
                            {(singleAnalysisResult.text_analysis_error || singleAnalysisResult.image_analysis_error || singleAnalysisResult.video_analysis_error || singleAnalysisResult.audio_analysis_error) && 
                                !singleAnalysisResult.error_summary && (
                                <div className="mt-2 bg-orange-100 dark:bg-orange-900/50 p-3 rounded-md text-xs text-orange-700 dark:text-orange-300"> 
                                <p><strong>Note from {singleAnalysisResult.analysis_type} analysis:</strong> {singleAnalysisResult.text_analysis_error || singleAnalysisResult.image_analysis_error || singleAnalysisResult.video_analysis_error || singleAnalysisResult.audio_analysis_error}</p>
                                </div>
                            )}
                            </div>
                        ))}
                        
                        {isAnalyzing && Object.values(analysisProgress).some(s => s === 'loading') && ( 
                            <div className="text-center text-indigo-500 dark:text-indigo-400 py-8">
                                <svg className="w-8 h-8 mx-auto animate-spin" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" /><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" /></svg>
                                <p className="mt-2 text-sm">Performing analyses for the file...</p>
                                <div className="mt-2 space-y-1 max-w-md mx-auto">
                                    {Object.entries(analysisProgress).map(([type, status]) => (
                                        status === 'loading' && <div key={type} className="analysis-status-item loading"><span>{type}</span><i className="fas fa-spinner fa-spin status-icon"></i></div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {!isAnalyzing && currentAnalysisBatchResults.length === 0 && Object.keys(downloadLinks).length === 0 && (
                            <div className="text-center text-gray-500 dark:text-gray-400 py-8">
                                <i className="fas fa-box-open text-4xl mb-3 text-gray-400 dark:text-gray-500"></i>
                                <p>No results to display yet.</p>
                                <p className="text-sm">Perform an action or upload a file to see results here.</p>
                            </div>
                        )}
                    </div>}
                </div> {/* End Tab Panels Wrapper */}

                <div className="mt-6 pt-4 border-t border-gray-100 dark:border-gray-700">
                    <div className="flex justify-between text-xs text-gray-400 dark:text-gray-500">
                    <span>File Management Suite</span>
                    <span>v2.0.0</span> {/* Version Bump */}
                    </div>
                </div>
                </div>
            </div>

            {/* Right Column: Info Cards */}
            <div className="w-full md:w-1/3 lg:w-2/5 order-2 md:order-2 sticky top-4 md:top-16"> {/* Adjusted top for theme toggle */}
                {activeTab === 'compress' && file && algorithm && !isLoadingAlgorithmDetails && algorithmInfoDetails && (
                <AlgorithmInfoCard
                    algorithm={algorithm}
                    fileType={fileType}
                    details={algorithmInfoDetails}
                />
                )}
                {!(activeTab === 'compress' && file && algorithm && !isLoadingAlgorithmDetails && algorithmInfoDetails) && (
                <div className="card rounded-xl info-card-placeholder">
                    <i className="fas fa-info-circle text-4xl mb-3 text-indigo-300 dark:text-indigo-500"></i>
                    <h3 className="text-lg font-semibold mb-2">Algorithm Insights</h3>
                    <p className="text-sm">
                    {isLoadingAlgorithmDetails ? "Loading details..." : "Select a file and a compression algorithm in the 'Compress' tab to see insights here."}
                    </p>
                    {/* errorLoadingAlgorithmDetails is now handled by toast */}
                </div>
                )}
            </div>
            </div>
        </div>
      );
    }

    const RootComponent = () => (
      <ToastProvider>
        <App />
      </ToastProvider>
    );

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<RootComponent />);
  </script>
</body>
</html>
