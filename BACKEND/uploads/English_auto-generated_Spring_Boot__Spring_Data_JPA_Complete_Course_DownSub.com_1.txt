welcome to this immersive course on
springing Boot and spring data jpa two
pivotal Technologies in modern Java
development spring boot simplifies the
process of building Standalone
production grade spring-based
applications with minimal effort while
spring data jpa is a powerful tool for
simplifying data access operations in
Java applications seamlessly integrating
with databases Bali Ali designed this
course to provide a comprehensive
understanding of of both
Technologies welcome future spring boot
masteress are you ready to embark on an
Epic Journey Through the word of spring
Boot and spring data jpa join me for an
immens of 13-hour tutorial where we
domestify the complexity and unlock the
full potential of these gamechanging
Frameworks why spring boot well in
today's market it stands tall as one of
the most s after Frameworks mastering it
can truly be a GameChanger for your
career consider this the demand for
skilled spring boot developers is
soaring and it shows no signs of slowing
down top tier companies worldwide are
actively seeking professional like you
picture Landing that dream job or better
yet forging your own path to success
armed with spring boot expertise so how
do you grab these opportunities it's
just straightforward join me on this
course now let's take a sneak peek Into
The Incredible Journey that you're about
to embark on so this course is composed
of two main parts first of all spring
boot where we will discover and unreal
the secrets of spring core spring boot
dependency injection spring profiles
magic restful apis data persistence dto
pattern robust service layer data
validation techniques testing Paradigm
mokito and much much more then embark on
a journey into the heart of spring data
jpa where you'll gain a comprehensive
understanding of repositories
relationships and the Art of playing
with inheritance Del into the
intricacies of embedded entities ID
generation and master the art of
querying data with named queries and
specifications and of course much much
more than that we will dive deep into
the magic and learn the ins and outs of
spring data jpa and raveling the secrets
of repositories relationships and
inheritance from embedded entities to
Advanced querying with
specifications we cover it all get ready
to take your data persistence skills to
the highest level before we dive in I
would like to invite you to join me on
my YouTube channel where I publish
exciting and engaging content every week
join me there and be part of the Great
Community we are building right now you
can find all the links in the
description of this video as well as
this is the ID of my YouTube channel
finally a big shout out to free code
camp for giving me the opportunity to
share this awesome content with you guys
and I'm really honored that my video
will be here to help you improve your
skills now with no further Ado let's get
started what is spring
framework the spring framework is an
open-source framework for building
Enterprise Java
applications spring aims to simplify the
complex and cumbersome Enterprise Java
application development process by
offering in a framework that includes
Technologies such as aspect oriented
programming dependency injection plain
old Java objects and so and so forth
even with all these Technologies spring
is a lightweight framework that can be
used to create scalable secure and
robust Enterprise applications at a
micro level we can consider this spring
framework a collection of subf
Frameworks such as spring web flow
spring MVC spring orur and so and so
forth core features of spring
framework the ioc container or the
inversion of control cont container ioc
container is one of the core features of
spring that provides a streamlined way
to configure and manage Java objects
this container is responsible for
managing the life cycle of a defined
Java object significantly increasing the
configurability
of a spring based application ioc use
dependency injection or dependency
Lookout patterns to provide the object
reference during
runtime aop aspect oriented programming
aop aims to provide more modularity to
the Cross cutting concerns which are
functions that span across the
application such as logging caching
transaction management authentication
and so and so
forth and then data access framework so
spring simplifies the database
communication process by providing
direct support for popular data access
framework in Java such as jdbc hibernate
Java persistence API also known as jpa
additionally it offers features such as
Resource Management exception handling
and resource wrapping for all the
supported data access Frameworks further
simplifying the development
process finally we have spring MVC so
the spring MVC enables developers to
create applications using the popular
MVC pattern it is a request based
framework that allows developers to
easily create customized MVC
implementations that exactly suits their
needs the core components of the spring
MVC is the dispatcher seret class which
handles user requests and then forward
them to the correct controller this
allows the controller to Pro process the
request create the model and then
provide the information for the end user
via a specified
View Spring
beans a spring Bean refers to an object
that is managed by the spring framework
in a Java application the term Bean is
used in the context of the spring
framework the spring framework creates
these beans manage their life cycle and
organizes their dependencies with other
beans it takes care of the instantiation
configuration and wiring up of objects
saving developers from a lot of manual
work also the spring beans can be
configured using XML Java annotations or
Java code life cycle of a spring Bean
first let's understand the life cycle of
an object so the life cycle of an object
means when and how it is born how it
behaves Liv throughout its life and when
and how it dies similarly the bean life
cycle refers to when and how the bean is
instantiated what action it performs
until it leaves and when and how it is
destroyed so the bean life cycle is
managed by the spring container when we
run the program the first of all the
spring container gets started after that
the container creates the instance of a
bean as for the request and then
dependencies are injected and finally
the bean is destroyed when the spring
container is closed now let's see how we
can configure a bean so first we can use
the configuration annotation which
declares a class as a full configuration
class and here you need to note that a
class must be nonf final and
public also we can use The atban
annotation which declares a bean
configuration inside of a configuration
class and the method must be non-final
and non private so it can be public
protected or package private and here is
an example so we see we have the app
config class annotated with the ad
configuration annotation and inside it
we have a payment service which has The
atbin annotation so this will return a
new payment service implementation and
we can pass any other dependency for
example in this case we have the account
repository as a dependency for the
payment service implementation B Also
let's see a full example where we can
declare multiple beans so again we have
the app config class annotated with the
ad configuration and inside that we have
a payment service Bean we have account
repository bean and a data source Bean
so the data source will return the data
source connection to our database for
example or our data source and then we
have in the middle the account
repository which is also a bean that
takes a parameter or as a parameter the
data source Bean that we already created
and finally from the top we have the
bean payment service that takes the
account repository as a dependency and
spring will manage all that so spring
will know that we need to create a data
source first and then pass it to the
account Repository and then we create
the account repository bean and pass it
as an injectable Bean to the payment
Service Spring component sample so the
spring component contains class level
annotation that marks a class as a
spring component using the add component
annotation so the Constructor dependency
injection is automatically done using
the ad a word by injecting the
Constructor parameters
so the autowired on Constructor is
optional if there is only one
Constructor and here we see an example
so we have our payment service
implementation class which is marked as
a component so this means that we want
to mark this class as a spring bean and
then we have a private final account
repository which is refers to another
spring bean and we have a Constructor
payment service implementation with The
annotation Auto and we have or we pass a
parameter of type account repository and
then we assign the local or the the
class instance account repository we
assign it to the account repository that
we get as a parameter from The
Constructor so in this way we are
injecting via the Constructor the
account repository bin into the variable
or the local variable account
repository spring components so spring
provides component stereotype to
classify classes as spring components
the subtypes are available as a
refinement for the standard components
so the component annotation as general
component annotation indicating that the
class should be initialized configured
and managed by the core container also
at repository at service and at
controller as meta annotation for the
components that allows to further refine
components own stereotype annotation can
and should be defined to support General
architecture principles now let's
understand the bean naming so here
assuming that we have this configuration
class that contains the three beans that
we explained already before payment
service account repository and data
source now we see that in the data
source Bean we provided a name we call
it the S so now let's see how spring is
going to name these bein so first when
we talk about the first Bean payment
service which returns a payment service
object so this will give it a name or a
bean name payment Service as for the
method name the same for the account
repository if we don't provide a name
for the Bean spring automatically will
use the method name as a bean name so
the bean of type type account repository
will be named account repository finally
for the data source when we provide the
name so spring will take that one as a
name for the Bean so the data source
Bean name will be DS so Bean naming is
really important in case we want to
fetch or to get programmatically any
bean from our application context so now
we know how spring names the
beans beans injection
when we talk about beans injection we
also mean dependency injection so the
spring framework provides four ways to
inject beans so the spring can configure
dependencies on different injection
elements first we have Constructor
injection so the Constructor parameter
to receive dependencies during Bean
construction so the we call this also
the Constructor injection then we have
field injection and this field
definition to receive dependency
injected with the reflection axis also
called field injection then we have
configuration methods with one or many
parameters receiving dependencies
through method parameters also called
method
injection and finally we have Setter
injection or Setter method injection so
so the Java Setter method are
specialized configuration method with
only one parameter and a defined name
scheme called also Setter injection so
the injection Target can be referred
using two different modes type injection
injects an object of matching type or
name injection injects any object by
name Constructor
injection so here let's first see the
example of uh the case of a service so
we have here a class uh called default
payment service that contains uh a final
account reposit itory and then we have
the Constructor default payment service
so in the default payment service
Constructor we are declaring also an
object or we passing a parameter of type
account repository and like that spring
will be automatically injecting this
account repository being then we have
for example in case we have a repository
so we see that we have a jdbc account
repository implements account repository
so then we have a final or private final
data source and then we have the
Constructor gdbc account repository and
we pass also a parameter which is the
data source and then spring will
automatically inject that using the
Constructor also for injecting beans we
can specify or we can tell spring which
Bean to inject and for this one we can
use the The annotation called qualifier
and here let's see an example so here we
have a class called application config
annotated with a configuration and
inside that we have two beans of the
same type so two beans are of type
account repository and we have a primary
and a secondary so this means that we
will create two beans the first one will
be called primary and the second one
will be called secondary but these two
beans are referred by type which is the
account repository so here we can give a
qualifier for each Bean so the first one
we will call it or we give it a
qualifier primary and the second one we
will give it a qualifier secondary and
when we want to inject one of these
beans we can also on the class level or
for example the service level let's say
we have the default payment service and
we want to autowire or to inject a bean
of type account uh repository and here
we want to choose or we can choose which
Bean to inject so we can use again the
qualifier annotation on the ser service
or the object level and as we can see in
the default payment service Constructor
we are telling spring that we want to
inject the bean that has the name or the
qualifier called primary so this is how
we can use the qualifier annotation to
inject the bean also if we want to to
define a bean as primary we can use the
primary annotation to Define which Bean
should be primary or should be prior or
prioritized for springing to be injected
so in this case we don't we don't need
the qualifier annotation so assuming
again that we have the application
config uh class uh configuration class
and then we have the same two uh beans
but now instead of giving a qualifier
annotation we can choose which is the
primary so for example we have the the
account repository primary and then we
give it the primary annotation and then
when we want to inject a bean of type
account repository all we need to do is
just to inject it using the Constructor
or the field and so on so forth and
spring will know automatically that the
account repository Bean which is called
primary is prioritized Bean so it will
inject that one unless we want to change
for example we can give a qualifier and
then when we use the qualifier so spring
will use that one over the primary
field injection so field injection
allows direct injection into field
declaration without Constructor or
method delegation but here you need to
note that this type of injection is
discouraged because it makes testing of
component in isolation more complex
therefore should only be used in test
classes and here is an example we have
the default payment service which is a
class annotated with ad service
annotation and then we have a variable
or a field of type account repository
and then when using The autowired
annotation this means that we want to
inject this account repository using
field injection method injection so the
method injection allows setting one or
many dependencies by one method so it
also allows for initializing work if
needed while receiving dependencies and
here we see an example we have our
default payment service annotated with a
service annotation and then we have a
method called configure class which is
of type void void and then we have two
variables or two feeds which is account
repository and fee calculator for
example and assuming these two um these
two classes or these two objects are
beans and then all we need to do is to
set The autowire annotation on the
method level and then spring will
understand automatically Al that we need
to inject these two beans so this is
what we called method injection Setter
injection so the setter injection
follows Java bin naming convention to
inject dependencies and here we see an
example so assuming again that we have a
class called default payment service
annotated with the ad service annotation
and then all we need to do is to declare
our field and then use the setter method
to inject this Bean so here we see that
we have a public void set account
repository and then it takes as a
parameter account repository and then
it's just a classic set method annotated
with at Auto wir annotation so spring
will understand that this is a Setter
injection and it will inject the field
using the setter method now let's see
the official recommendation for
Constructor based or Setter based
dependency injection so I copied this
from the spring Cod documentation and
you can see the link down here so here
since you can mix Constructor based and
Setter based dependency injection it's
good rule to them to use Constructor for
mandatory dependencies and Setter for
method or configuration method for
optional dependencies and here like you
can read it uh your on your own and then
here the spring team generally Advocates
Constructor injection so it's always
recommended and it's always better to
use Constructor injection to inject your
beans into a class Bean scoping so first
let's understand what is a beans scope
so beans scope in Spring framework
refers to the life cycle of a spring
bean and its availability in the context
of the application so when a bean is
instantiated or looked up its Scopes
determines its life cycle and which
other beans can in can interact with it
so the spring provides multiple Scopes
to register and configure beans and
scoping has an impact on State
Management of the components also the
default scope model is Singleton means
one instance per application context
shared instance will be accessed by
other components therefore components
must be thread safe so now let's see
what are the bin Scopes provided by
Spring so first of all we have the
Singleton and as we mentioned it's the
default so this is the default Bean
scope in Spring container only one
instance of The Bean Is created and all
requests of that bean will receive the
same instance this is useful for bean
that do not do not hold state or where
the same state is to be shared by all
users or threads then the second one is
prototype so this means a new instance
is created each time a bean is requested
from the container this is useful for
beans to carry state that is specific to
the uh to other user or thread and thus
can't be shared the third type is
request so this scope is only valid in
the context of web over spring
application context for a single HTTP
request a new Bean is created for each
HTTP request then we have session so the
scope is also valid only on the context
of webware spring application context of
an HTTP session so it's it's different
from the request so the HTTP request or
the request scope is available for the
HTTP request and the session is for HTTP
session so this means a new Bean is
created for each HTTP session by the
container then we have application so
this scope is also valid only in the
context of webware spring application
context for the life cycle of a serlet
context so this ban is scoped at the
application Level and finally we have
web socket so this scope is valid only
in the context of webware spring
application context for the life cycle
of a websocket The Bean Is scoped at the
web socket level so Bean scoping is
really important if you want to
correctly manage your beIN and as I
mentioned before by default the bin
scope is
Singleton now let's see how we can
define a scope for specific mean so
whether we can specify it by name so for
example let's say we have B one
annotated with a ban annotation and then
we can give it the scope annotation and
then we just provide the name of the
scope also we can use The annotation to
provide the scope annotation for example
let's say session annotation so we have
a specific annotation for that
personally I recommend using The
annotation to specify the scope just to
avoid mistakes or to avoid
typos now let's talk a little bit about
some special spring beans so first of
all we have the bean environment so the
bean
environment is an environment abstra
abstraction so spring provides an
environment AB abstraction to the couple
application code from the environment
with a support for bean definition
profiles that allow different sets of
beans depending on the environment for
example we have local environment Dev
environment Cloud prod and so on so
forth also it helps resolving properties
for external s sources for example
database settings from the configuration
file or reading cred credentials from uh
CLI arguments and so and so forth
environment can also be injected into
the code if needed and now let's see an
example so here we have the application
config class annotated with ad
configuration and then we can inject the
environment Bean so all we need to do is
to create or to declare a field of type
environment and then autowired and as
you can see we can get for example uh we
have uh in this payment service method
which is a bean we have a profile so we
can read or create a profiles of type
cloud and then we can say this.
environment. accepts profile and we can
pass the cloud profile as an environment
and then for example we can also read
some property so all we need to do is
this. environment. getet property and
then the property name so this is how we
can use this predefined Bean then we
have the bean
profiles so a profile in Spring is a
named logical grouping that may be
activated programmatically or set as
active through configuration so this
feature is particularly useful when you
have beans that should be active or
registered and used in certain
environments or conditions for instance
you may have different configuration for
development testing and production
environment and you want to make sure
that certain beans are only used in one
of these
environments this is how we can use this
profile Bean or the profile annotation
we can use it in three different ways
first of all on a spring component so
here we have the first one is the
default payment service class and I want
this service to be only available for
the profile Cloud then we can use it on
the configuration level so I want this
configuration to be scanned and and
applied by Spring only for the cloud
profile also also we can declare the
profile on the ban configuration so this
means that a specific Bean is only
available for the cloud profile also a
bean can be active or activated
programmatically for example let's see
this code right here so first of all we
create a variable of type annotation
config application context so this is
our application context so it it's
equals new annotation config application
context and then we have the application
context and we have a method called get
environment and then we can set the
active profiles and then all we need to
do is just to provide the profile name
then we need for example if we have a
different package to scan so we said
also application context. scan and then
we can provide the base package and then
of course don't forget to refresh so
spring will refresh its own context and
then for example we can get the bean
which is available for this Cloud
profile so we can get for example the
payment service equals application
context. gbin and then we pass the
service class so also we have another
different way to define the active
profile so using the properties file so
for example we can use the yaml
representation and it will be spring
profiles active and then the profile
name or using the application properties
which is also spring. profiles. active
equals
Cloud so in Spring framework the value
annotation is used at the field level or
method or Constructor parameter level
for expression driven dependency
injection this annotation is commonly
used for injecting values into variable
in a class whether they are Primitives
strings or complex types these values
can come from properties files system
properties or they can be hardcoded and
here is an example how we can inject
values using the value annotations so
assuming that we have an application
config class annotated with
configuration and then we have for
example we want to create a data source
bean and for that we need the the URL
the username and password of our
database and assuming that these
properties are stored in in a file
called database. properties under our
resource folder so first of all we need
to inject or to tell spring from where
we want to read these property sources
and for that we use the property Source
annotation and then we provide the class
path so the class path will refer to the
the resource folder and then we provide
the file name so it's it's it's called
database. properties for example and
then if I want to inject the URL
variable or the URL property which is
called in my properties file jdbc URL I
use The annotation at Value and then
dollar and then curly brackets and
between the curly brackets is the
property name also the value annotation
can also resolve Dynamic expression to
access other beans or well-known beans
like for example system properties so if
I want to get a property from my system
properties Bean all I need to do is to
use the value annotation and then I use
the D
uh symbol and then between the curly
brackets I can use the system properties
and then I read the property called
user. region for example to inject the
default loc or to look up the default
loc from the system properties let's see
now some best practices for the spring
framework so first of all split
configuration so configuration class can
be split into several classes first of
all to avoid large configuration classes
and also to allow splitting classes
based on architecture or other drivers
so the class can classes can import each
other or application context can be
constructed with multiple classes and
here is an example so for example we
have a first configuration class called
server uh service config and this one it
will configure a beIN of type payment
service we have then repository config
and this one it it will contain a bin of
type account repository and then we have
a class which is also a configuration
class called app config and then for
this app configuration we need the
service config and the repository config
and for that we can use the import
annotation to import the two previous
configuration classes so like that we
are applying the best practices and we
are splitting our configuration into
multiple configuration classes and then
we can import only what we need so like
that we will have a more maintainable
code spring initializer provides a
simple web UI to configure the project
to generate uh an endpoint that you can
use via plane HTTP all you need to do is
to go to start. spring. AO website and
you will have this user interface so the
service allows you to customize the
project to generate the build system and
using for example groovy Maven or or
Gradle also you can choose the language
whether you want to use Java cotlin or
groovy and then you can choose the
spring boot version that you want to use
so here like at the time of recording
this course the most recent version the
stable one is
3.1.0 and then we have a set of metadata
where we can provide and give the
information about the group ID the
artifact ID the application name and
description and then the base package
name then we provide the packaging
whether we want to package our
application as a jar file or War file
and the recommended one is always to use
jar file with spring Boot and finally we
have the Java version that we want to
use for example for spring 3 the minimum
required version is Java 17 and if you
want for example to use uh to use spring
2.7 something you can use Java 11 or
Java 8 so the the project generated by
the spring initializer contains a spring
boot application and we will have a demo
application. Java and then if you run
the main method of this demo application
you will see an empty spring boot
application starting at local host and
then the port 8080 which is we need for
that case the web dependency at least to
be able to run the spring boot
application as a web
environment spring boot is an approach
to develop spring based applications
with very less or no configuration it
leverage existing spring boot projects
as well as third party projects to
develop production ready
applications it provides a set of
starters pal or Gradle buil file which
can use to add required dependencies and
facilitate Auto
configuration also spring boot comes
with a lot of Auto configuration so
depending on the libraries on its class
path spring boot is able to
automatically configure the required
classes now let's see why we need to use
spring boot first of all it comes with
Standalone applications and also it
comes with embedded servers such as
Tomcat or Jetty so there is no need
anymore to deploy War files also it it
provides opiated starters pal or Gradle
depending on your project configuration
to simplify the maven or the project
configuration generally
speaking spring boot automatically
configure the spring framework whenever
possible also it provides production
ready features such as metrics health
check and externalized
configurations and finally there is no
more requirements for XML configuration
or any other type of configuration it
only needs configuration whenever it's
required first of all let's start with
creating a new spring Bo project so as
we explained before all we need to do is
to go to the start. spring. website and
you will have this nice looking UI where
you can create a new spring boot project
so first of all let's choose our uh
dependency manager so in this case we'll
be using Maven because personally I
prefer Maven because I'm so familiar
familar with the maven structure and
also the XML structure then we have the
language so we will be using Java as a
programming language for our course and
then let's choose or let's select a
spring boot version so here as you can
see at the time of recording this video
the most recent stable version is the
spring
3.1.0 but we will be using the 3.0
something so make sure you use the
version 3.0 because as for now like the
spring 3.1 comes with with some
deprecations and even for for the future
I assume that companies they will not
migrate yet to the spring version 3 even
or even the spring
3.1.0 I will make a video explaining
why you need to skipe the
3.1.0 all right so let's select the
version here and then let's provide the
metadata of our project so first first
this is the group ID so the group ID
refers to the company if we may say so
for example let's take meta or like the
old Facebook company now it's called
meta so for example for the group ID it
it will be com. meta so this is the
company
name and then the artifact refers to the
project or to the sub company for
example here let's say Facebook or
Instagram
or WhatsApp and so and so forth so here
The com. Meta or like the group ID
refers to the company and the artifact
refers to the project itself so here I
will say com do com. alibu let's use
alibu as a group ID and here let's say
example okay so here it will
automatically use the artifact ID as the
project name so let's also keep it
example and here you can also provide a
description for your project so here
it's a demo project for spring boot
application so this is also fine with us
and also the package name is the
concatenation of the group and artifact
ID and of course you can update or you
can modify the package name and this
will be the base package of our
application and then we have the
packaging what is the the format or the
package format of our final application
whether we want to use jar files which
is Java archive or War file which is War
web archive and then we need to specify
the Java version okay so the Java
version right here if we use the spring
3.0 something or spring 3.1 the minimum
required version of java is Java 17 all
right so now after specifying this we
can move on and add dependencies so as
explained before spring boot comes with
a set of starters and the starter is
already a spring boot application which
comes with a lot of
autoconfiguration which will simplify
our life of coding so here we need to
click on ADD dependency and then we can
filter or we can search for the
dependency that we want to use for
example if we want to create a web
application or restful application we
can filter or like we can search for web
and here you will see that we have the
spring web starter and as the
description says build web including
restful application using spring MVC use
Apache Tomcat as the default embedded
container so for now let's say that we
want to use web so I will select this
dependency and also we can click and add
more dependencies so for example if you
need jpa or if we if we want to
implement a persistent layer on our
application we can choose spring data
jpa or for example if we want to use
post degrees SQL we can also search for
postgress SQL or for example even for my
SQL and so and so forth okay so for now
let's start with this simple dependency
which is spring web and then we will we
will see how we can even add manually a
new dependency so here you can whether
click on this explore button and here
you will see the project structure or
like the future project that will be
generated and as you can see here we
have the pom.xml selected
and I will explain this in the coming
video so now you can close this one and
click on generate and this will download
a zip file containing the project that
we already created so now I will just
place this one in my workspace so it
will be
here and then source code and I will
just save it here so now I have my zip
file downloaded now let's move on and
open this file using anell now start
your anell and then click on open so if
you have already opened project you will
see a button right here called open or
all you can do is just go to file and
then open all right so this will open a
prompt right here and then navigate to
the location of your source code and
then select the pom.xml so here I have
the example dotzip file which is which
is I already unzipped and as as you can
see here we have this list of files and
this SRC folder so all you need to do is
to select the pom.xml file and then
click on open and then say open as a
project and of course trust this one and
then start so this will open a window
like this containing the project
structure that we see right here and as
you can see we have this this structure
right here so in the next video I will
explain everything think but before that
I want to show you something so before
we start exploring our project and
checking the project structure first of
all I want to highlight something
because so many of you have been
requesting and asking the same question
about the theme or the UI of my anti J
so as you can see here for example if I
select this file right here you'll see
that it's really nice looking and we
have all these icons and so and so forth
so this is is part of the newest version
of anj and you need to go and activate
this UI so what you need to do go to anj
and then settings or file settings for
Windows
users and then go to appearance and
behavior and here you will see that you
have a menu called new UI and it's in
the beta version for now so here you can
click on enable new UI and then you have
this compact mode that you see in my
screen right now so like like this you
will have the same UI as me as me and
this might be also helpful for you to
have a better and a nice looking anj or
Nic looking IDE and also it will be
easier for you to follow what I'm doing
right now so I'm going to click on
cancel and now let's go back and and
explore our
project now before we move on let me
show you few things that you might need
to set up also your working environment
and in order to use enj in a in a in a
good way so first let's click on file
and then select project
structure and in here you will see in
the project so here you see the SDK so
here you will have a list of sdks that
you can use within your project so if
you don't have for example the Java 17
all you need to do is to click for
example no SDK or you can click on ADD
SDK and then you can click on download
jdk so so this will provide you a list
of the the available jdks for example if
you want for example let's say Java 19
and then you can select the vendor or
the provider so it's whether Amazon
coretto and so on and so forth so you
can select that one and here you can
keep the location by default so anj will
store it in its location like the
location that anj will choose and then
all you need to do is to click on
download and then you will have it in
the list right here so like this
you won't be prompted or like blocked if
you don't have already the SDK or the
jdk installed all right so this is an
important step for you before we start
coding or before we start diving into
our code so then click on apply once you
download the SDK or or change the
version just click on okay or apply and
then you will have your SDK ready to
use all right now we can start to check
out our project structure so here when
you create a new spring boot project you
will find this IDE idea or uh yeah it's
called idea folder which is uh
automatically created by anj so we can
just ignore that because it depends on
your IDE you will have this folder right
here and then we have this mvn folder
that contains a wrapper and then we have
this Maven wrapper. jar and Maven
wrapper. properties so this means means
that you really don't need to download
manually and install manually Maven
because when you create a new spring
boot project with uh using the using
Maven so it it will create or it will
download automatically a maven wrapper.
Jr file and you can use this one in your
command line to run some commands and we
will see that later on how we can use
this Maven wrapper because for example
for my machine I did not install Maven
or my machine so I always use the maven
wrapper provided by the spring boot
project and I would say this is a good
approach because like that you are not
depending on a specific version which is
installed on your machine but you depend
on the version which is provided by the
spring initializer so then we have this
Source folder which contains two main
subfolders we have this Main and we have
the test so first of all let's check the
main folder the main folder contains
also two subfolders we have first of all
this Java folder where we will have all
the Java files of our applications all
the classes and object of our
application will go into this Java
folder and then we have the resources
folder so the resources folder contains
two subfolders static and templates so
the static is for example if we want to
put some static files like HTML files or
we want to build for example a UI for
our rest API that we will be building so
we can move or put all the files in here
but I really don't recommend that
because we need to think rest okay so we
need to have a rest API and then if we
need we can create a front end using any
front end framework and then we have
this application. properties files so by
default it has the the file extension
Properties or we can also use yaml
representation so the difference between
properties and yaml files is just the
representation and the way we write
things and the application properties
will hold all the properties that are
needed by Spring boot or even custom
properties that we want to read from our
application okay so now let's go back to
this com. alibu example and as you
remember this is the base package or the
concatenation of the group ID and
artifact ID so here we see that we have
this example application which is a
simple class with just a static void
Main and it contains a spring boot
application annotation so this will be
the main class for our application so if
you want to start the application all
you need to do is to run this file by
right clicking and then run example
application or just clicking on here or
also clicking on this button right here
so you have multiple ways to run the
application from your ID then we can
move to the test F test folder so this
test folder this is where we have all
the test files that we will create so
all the unit tests all the integration
test all the end to end test that we
want to create for our rest API they go
to this test folder so next let's have a
look on the pom.xml file so the pom.xml
file looks exactly like this I'm going
to make it full screen so if we start
from the beginning so here is just
providing or specifying the XML version
and here like we we provide also the
project and the XML name space which is
Maven Apache org and so and so forth so
this is some information that you need
and also the schema location and so on
so forth and also this is the model
version of our project and then we see
here that we have a parent tag so the
parent tag contains also group ID
artifact ID version and roll path so
this parent means that this Maven
project extends from this parent okay so
this means that this spring boot
application extends already the spring
boot starter parent having the version
3.0.7 which we already specified and
selected in our spring initializer and
then we have the group ID that we
specified which is com. alibu and the
artifact which is example and then we
have a default version which is
0.0.1 Das snapshot snapshot means it's
still under uh under progress or like in
progress and then we have the name which
is we mentioned before it takes by
default the artifact ID you can also
change it and then we have the
description all right and then it comes
uh a tag called properties and here we
can provide a set of properties for our
application so here for example we have
this java. version and you are
specifying that you are using the Java
version 17 after that comes the the most
important part which is the dependencies
so we see that we have a tag
dependencies and this is a list of
dependency so here we see that we have
this dependency uh tag so also here we
provide the group ID and the artifact ID
so for example here it's or. springf
framework. Boot and the artifact is the
spring boot starter web which is the
dependency that we added when we created
our project and also by default when you
create a new spring boot project you
will have always provided dependency
which is the spring boot starter test
and the scope of this dependency is test
so this dependency will be available
only when we run the tests also there is
something which is really important in
here when we use spring boot so spring
boot really makes it easy to manage
versions so here we don't need to
provide any version because here if we
check we we have already a property
called version and we can provide any
version that we want but when we use
spring boot we don't need to provide the
version because it will automatically
extend the parent version so this in
case of an upgrade or a downgrade of the
spring version you don't need really to
worry about the spring boot starter
starters dependencies all we need to do
is to update this one refresh the
project and then we will have our
project totally and fully migrated to
the newest to the new version that we
provided all right so this is the
application so now let's start our
application and see and try to analyze a
little bit what we have so first just
click on this button right here or this
play button right here and run example
application or right click on this file
and then run example application or
select the file from here right right
click and then run this application so
it it's up to you to choose the way that
suits you the best so here let's analyze
a little bit what we have so here we see
that we have this Banner right here and
I will show you in a few seconds how we
can also change that then we see that we
have a bunch of logs so here we have a
list of info logs and as we can see here
starting application using Java 17 with
process ID sign something and here also
we see that we have no active profile
set so then we later on we will see how
we can work with profiles so here
falling back to one default profile
which is called default and even if you
don't Prof provide this profile name it
will be selected by default then we see
Tomcat initialized with port 8080
starting service and then we see that we
have started example application in 0.5
seconds and then the application or the
Tomcat already started on the port 8080
with a context path which is empty all
right so now this is not the most
important part first I want to show you
how we can change this Banner right here
and to make our service or our
application looks really nicer first
let's go to our
browser and here this is uh a cool
website that I really like or even you
can just Google text Banner generator I
will leave you this this link in the in
the description of this video and then
for example if you type something let's
say alibu and then we can choose the
font so here I will choose uh this one
so I prefer this one this an regular or
you can use Al also an regular with
Shadow and you can use like you can play
with it you can change the character
width you can change the spacing and so
and so forth okay so here for example if
change it to full fitted you will see
that it will change and it will be
different from one one the
other so once you generate a banner just
click on select and copy so this will
copy this text to the clipboard now
let's go back to our application and
also I will stop the application right
now and reduce this and now in the
resources so spring will automatically
scan and look for a file called banner.
txt so I will create a new file right
here and I will call it
banner. txt and I will just paste the
content here okay so now if I restart my
application we will see this Banner
showing up instead of the old one so
here maybe I will CH change a little bit
so let's say spring boot
3.0.7 just something like that and here
maybe let's say all right let's just
adjust a little bit the spacings and now
let's start our
application so now instead of the Old
Spring boot Banner we see that we have a
new Banner which is alibu and we
generally use the Banners To Give the
the service name so when we start the
application we know which service or
what is the service that we are starting
right here so as you can see we have
this alibu and we have the alibu and
then the Springwood version for example
and so and so forth also we have the
same logs as we had before and the
application again started on the port
8080 bar which is the default one and we
have also the application started the
example application Java file in few
seconds so let's create our first ban
class so here in the the package com.
al.ex example right click and then new
and then Java class and let's call it my
first class for example or my first
component or my first service just you
can call it whatever you want so in this
my first class I will just create a
public string it's a method that will
just say
hello so this method will return hello
from the first class or from my first
class for example just to know where the
message is coming from so now in order
to use this first class and call this
method called say hello what we need to
do for example let's go to our main
method and here let's say first or my
first
class let's call it my first class
equals new my first class so all we need
to do is to create an instance and then
I will use
system.out.println just to print out the
message so I will use my first class
instance object and then I will call the
method say hello so now if I run the
application we will see that here we
have the message hello from my first
class but this is not really recommended
when we use the spring framework because
we are not using the power or the the
the core feature of the spring framework
which is dependency injection so to do
that let me show you how we can and
transform this my first class or this
simple class to a spring Bean so now
going back to our example application
class file and here I will create a bean
so this is a ban annotation and then I
will do public my first class and I will
call it for example my first class okay
and then when I need a bean of type my
first class I need to return a new
instance or new my first class instance
all right so I will just keep this line
right here now let's see how we can if I
remove this one so if I remove the
instance or the manual creation of the
my first class and delegate that to
spring so spring will be able to inject
and create a bean of type my first class
okay so now first of all let's see what
this run method is able to return so
this run method method will return a a
class or an object of type configurable
application context so I will just
assign this one to a variable and I will
call it context so
CTX just as a short
name so when we run our application it
will return a context which is the
context of our application so here my
first class now I want to get the my
first class from the context or from the
application context of my spring
container so here I will just go equals
and then
context. get bean so I have a method
called get bean so actually we have uh
three or four uh four or five methods of
type uh called get bean and the first
one for example it takes a class then we
can pass a name and the required types
also also we can pass the required types
and object or just a string or just a
string name and object arguments and the
arguments for example if I say or if for
example I need a string for or to
instantiate my class and so on and so
forth so it's any parameter or any field
required in order to create an instance
of my object but in this case we can use
whether the first one which is just
passing the class or we can use the
second one which is passing the name and
the required type so it will transform
it automatically or we can use also the
get bean with a parameter string name
but after that we need to cast the
object to the required class so here
since I already know the return type of
the type of my bean I will use the first
one and then it will be just my first
class do class as a parameter all right
so here as you can see I did not do
anything or I did not create a manual
instance for my first class object I
just created a bean or transformed this
class to a bean so it will be fully
managed by the spring framework so now
all I need to do is just to restart the
application and see if it still Returns
the same output or not so as we can see
here we have always hello from my first
class so now this is the first way or
like this is how we can create a bean
now let me show you a different way how
we can also tell spring that this is a
bean so now if I remove this Bean
annotation or even if I comment out or
totally remove this method right here
and try to run the application let's see
what will
happen so first we have an exception and
the exception is saying no such Bean
definition exception so this means there
is no qualifying Bean of type my first
class available in the application
context so we are not able to get or to
look up a bean of type my first class so
why because we just commented out this
Bean annotation so when the application
starts spring will not be able to find
or to instantiate a bean of type my
first class so we said or I mentioned
before that I will show you a different
way or a second way how to use or how to
declare a bean in spring so now I will
just stop the application for now and
then to Mark a class as a spring Bean
all I need to do is to add an annotation
so this annotation I can use the
component annotation that we already
spoke about before so when I use
components automatically spring will
consider this class so when the
application starts up and spring starts
scanning all the packages and all the
classes each time it will see this
annotation it will consider the class as
a spring Bean so now all I need to do is
to restart my application so here if I
restart my application we will see that
we no longer have the exception and we
see the hello from my first class all
right so now let me also show you the
other annotations that we can use we can
use The annotation service and The
annotation repositories which as which
are uh uh refinement of the component
annotation as we mentioned
before so we using for example service
and if I restart
again so we see also that the message is
showing up and the application starts
with no issues and also if I go to the
definition of this service and then
click on download source to download the
source code of of this class so we see
right here the first thing this is like
the public interface service and then
this annotation or this interface class
is already annotated with ad component
so in in a different way the service
annotation already extends the component
so both of them are the same thing so
here as also mentioned in the
documentation you can also see component
and repository so it's the same way if I
use also a
repository and I go to the documentation
I will see also that it's a component
all right so whether using service or a
component or a repository these are a
markdown annotations to mark an object
or a class as a spring Bean so I will
bring it back to service if I start
again the application so I will have my
bean and I will also be able to dis
display the message that I already
return in here in this say hello
method as mentioned before splitting the
configuration is one of the best
practices so first let's start with a
cleanup so I will remove this service
annotation and I will optimize the
import to to remove the unused one so
also if I use a shortcut you can use a
popup right here telling you what was
the shortcut I used to do tou action so
now I will go back to my example
application right here and then I will
open the project and I will create a new
application config class so I will call
it application config and then I will
just take this Bean declaration and move
it to the application
config so now I will bring back this
Bean
annotation and of course import it and
then don't for forget to add the
configuration annotation to your class
so spring will scan this class at the
startup so now the
application configuration is ready to
use and again if I start my application
I will see that everything is still
working as expected so we see here that
we have the hello from the first class
so now I will also optimize the Imports
right here so whether you move it
manually or you use the shortcut Control
Alt o for uh Linux and windows or option
control o for Mac
users now let's understand the bean
naming in Spring application context so
here as we mentioned before to get a
bean we can use the class or the object
class or we also can use another method
which takes the the bin name and the
required type so for example here to get
this my first class and just to to
remind you that in the application
config we created a bean we gave it the
name my first class so if I copy this
name and I go back here and pass this
the bin name as parameter and I run the
application so spring will also
understand that we are looking for this
Bean so for example if I change this one
to wrong Bean name and I restart the
ation it will tell me that there is no
such Bean okay so no such Bean
definition exception and it says that
that we don't have any Bean named wrong
be name because by default spring will
use the method name or the the method
that we created here and we annotated as
a bean as the bean name okay so now let
me bring this back or let's see a
different way how we can name a bean so
here we have a bean
and for example let's call it my
bean and now spring when it scans and
and declares this class as a bean it
will automatically give this spring Bean
or this string bean name as the B name
so I will copy this one and now I will
use it instead okay so if I rerun the
application we see that the application
is running and now we are using or we
are showing the message coming from the
say hello method of my first class Bean
okay so now this is how the bean naming
Works in springbot also if I go back
again and just remove this parameter
right here and for example I changed the
name to my first my first Bean so I can
use here my first Bean as a be name and
I can just run the application and it
will show the message that we already
have in our say hello Method All right
so now let's move on and see more things
and more features about how to
manipulate and work with spring beans
now let's extend a little bit my first
class Bean so here first I will create a
private variable it will be a string and
let's call it my VAR for example okay
and now I will add a Constructor
parameter so I'm just using shortcuts
again so so you can see it in here so
here I will select the option add
Constructor parameter and then it will
propose what will be the variable and
say do refactor and as you can see here
it will we have a Constructor having a
string myar and then this myar equals
VAR and just I will adjust the say hello
so it will be hello from the first class
and then let's for example display the
myar so it will be myar
equals and then just my VAR okay so now
we see that we have already one problem
so what we need to do we need to go back
to the application config and pass this
myar as a parameter so here let's say
first been and now if I run the
application the application will be
running correctly and it will display
here the variable or the the value of
the myar that we passed to this my first
ban Bean okay so it says hello from the
from my first Bean class or my first
class and my VAR equals first Bean now
let's move on and dig more and explore
more how we can work with beans to
better understand dependency injection
let's start by preparing the groundup
for for it so first I will create a new
class and I we call it my first service
so my first service as a class and and
this one I will mark it as a service and
then for this my service I will just
create uh a method so I will do
public string and then say message or
tell story for example so this tell a
story it will just use one of the
existing services or the existing beans
that we have which is the my first class
in here to just display the message or
like to to make a call to the say hello
Method All right so here I will just
first need to inject a bean so so all I
need to do is to create a private my
first class and I will call it my first
class so I will make this one full
screen and then I will just return so
the bean is saying or like let's say the
dependency is saying and then I will
just concatenate the my first class do
say hello method okay so when I run this
class and I run this tell a story I
expect to have an output in my console
telling that the dependency is saying
and then we have the hello method or the
say hello method that we have right here
so now let's move on and understand in
deep the dependency injection and the
different types of dependency injection
now if we go back to our example
application class and here let's do some
changes instead of my first class I will
just try to inject my first service and
I will just rename this one to my first
service as a variable name and then I
will tell spring to get bean I can also
remove the name and instead of my first
class I will just change it to my first
service and here I will just call the
tell story okay I will just rename this
one so it's
service and now if I run the application
let's see what will
happen so here we have a null pointer
exception in the my first class. say
hello okay so if I click to check the
trace so the my first class is null okay
so now I will rerun again in the buug
mode so I will just add a breakpoint
right here and I will make the later on
a special video how we can debug in
details so now just click on this debug
example
application and then when the example
application here so first we start by
running the application and then we look
up or we try to load the my first
service Bean which is already a service
right here so that's why we are able to
load the bean and then we try to call
the my first service tell the story and
this is when the break point hits okay
so we are trying to concatenate this
string with the string coming from the
say hello method so as we can see here
in inj we have already a n pointer
exception because the my first class is
null why it is null because it's not yet
injected by spring because we did not
tell spring how to inject this class
okay so that's why we have our null
pointer except so let's resume the
program and now if I go back to the
console we see again we have this n
pointer exception so now let's see how
we can inject a dependency using the
Constructor so all I need to do here I
will use the auto completion and uh or
the code generation and I will ask anj
to create a Constructor using this my
first class so here I just asked it and
now it also anj is is recommending to
make my first class Final so we will
also add this final keyword so now all I
need to do is to add the keyword
autowired and this annotation needs to
be on the Constructor level so like that
when I start the application spring we
know that we need to fetch a bean of
type my first class the one that we
declared right here and it will be
assigned to this my first class so since
here in our application config we have a
bean of type my first class spring will
know that this is a bean and then the my
first service needs this Bean to be
injected so it will automatically
injected so now let's just restart the
application and now I will just restart
it not with debug
mode and here we have the magic so here
the dependency is saying hello from my
first class and my VAR equals first been
as we specify it in our application
configuration right here so now I guess
you are able to link things so this is
how Constructor injection works now let
me show you a little bit of enhancement
that was introduced by the spring
framework so now if I go back to my
first service I can also remove this
breakpoint here with spring boot if we
have or if we want to use Constructor
injection we no longer need the autowire
keyword I will also optimize the Imports
so we no longer need the autowired
keyword or annotation because spring it
will try to inject all anything that is
injectable so when the application
starts and spring start creating this my
first service Bean or uh or service it
will first see that in the Constructor
we need an object of type my first class
okay so it will look up in its context
if it finds a bean of type my first
class if yes it will inject it so now
after removing The annotation I will
rerun again the application and make
sure that everything is working fine so
here as you can see we no longer need
The autowired annotation so this is how
Constructor injection
works now I will go to my application
config and create a second Bean of type
my first class so I will duplicate this
one
and I will call it my second Bean so
this my second bean I will pass a
parameter I will call it second Bean
okay so now I have two beans of type my
first class now if I rerun the
application and try to fetch or to
display the message in here I expect
things not to work and even ndj is able
to highlight this so if I highlight this
one it says could not Auto to wire there
is more than one bean of my first class
type and this is what will happen or
what will be displayed in our console so
I will run the
application and here we see that we have
application failed to start and it says
parameter zero of Constructor my first
service required a single Bean but two
were found okay and here it give H it
gives us more details so we have first
my first Bean defined in my by Method so
defined by Method my first Bean in class
application config and we have the same
for my second Bean so also it gives us
some actions so consider marking one of
the beans as primary or use qualifier so
this is this introduces us to the
qualifier topic so now what I will do I
can just come here and add a qualified
fire annotation and for example I will
say Bean one I will copy this and here I
will say Bean two so I have the first
Bean called Bean one and the second Bean
has a qualifier called Bean two so this
qualifier doesn't mean that the bean
will be called Bean one and bean two no
the bean will stay my first bean and my
second Bean of type my first class but
as an extra information we will give it
a qualifi fire called bin one and Bin 2
now if I go back to my first service I
can just come here and add a qualifier
information to this Bean so for this
Bean here I will just tell it to use the
qualifier for example Bean one or Bean 2
Okay so let's use Bean two because
before we used the bean one and here
let's just make sure that we have second
Bean as a variable all right so now
spring will be able to locate or to load
or to inject the correct Bean using its
qualifier okay so now if I run the
application
again so we see that we have the message
and now the variable my VAR has a value
second Bean which is this Bean right
here okay so this is how we can use
qualifier to inject a a specific Bean if
we have m multiple beans of the same
type so as this example right here we
have two beans of type my first class so
now we just give it a qualifier for the
first Bean and the qualifier for the
second one and then spring will be able
to locate and decide which one to inject
also when working with beans we can tell
spring which one to inject first so
instead of using qualifier so I'm going
to remove this qualifier from here and
then I will go back back to my
application config and I will also
remove these two qualifier annotations
so for example let's say that I have a
third bin right here so I just duplicate
the code and I will say this is my third
bin and then I want spring for example
to inject this third bin so I will just
change also the text here so all I need
to do is to use the primary
annotation so this primary annotation
will give a higher priority to this Bean
called my third Bean now if I go back to
my first service we see that the
Highlight from uh from anj is already
gone because spring will know that there
is a higher Bean of these three beans
which are of the same type so when this
service my first service needs a bean of
type my first class it will look up all
the beans and it will choose the this
primary Bean as a higher priority bean
and it will inject that one so now when
I start the application I'm expecting to
have this third Bean printed as an
output so as we can see here we have
this dependency is saying and the bar
now is saying third bin so this comes
from this primary annotation so like
this we can define a priority or higher
priority to our beans
now let's see dependency injection using
field injection so I will keep my
configuration as it is I will keep my
third Bean as a primary and I will go
back to my service now I'm going to
remove the Constructor so I don't need
the Constructor because I will use field
injection so to inject uh a dependency
using the field all I need to do is to
add the autowired keyword or the
autowire annotation to the the property
or to the bean that I want to inject
also already you can see right here that
it's already also highlighted and field
injection is not recommended as I
explained before it's always recommended
to use Constructor injection or Setter
injection over field injection so also
the the spring Advocates they always
recommend using Constructor injection so
now if I start the application I will
get the same output telling third bin so
as we can see right here so now it's
telling third bin also we can mix this
in the field injection we can mix with
with the qualifier so here I will just
uh comment out the primary and now I
will show you how to use qualifier even
without having the
qualifier um name or the qualifier
annotation on the bean declaration so
here we see that we have three beans and
now I will use the qualifier keyword or
the qualifier annotation and all I need
to do is to provide the bean name so the
qualifier will use or will try to look
up the bean by its name or by its
qualifier name if we provide it so for
example if I want to use my second bean
I will just copy the method name because
as I mentioned before when we don't we
don't provide a bean name it will take
the method as a bin name so now I will
go back to my first service and give it
my second Bean as a qualifier so if I
restart the application I'm expecting to
see this second Bean so this is what we
see already in here so the field
injection also works with qualifiers and
also qualifiers we don't need to provide
them on the bean level all we need to do
is to use whether the method name or the
bean name if we provide it so for
example if I give a name to this Bean so
let's call it for example Bean
one and then for I will copy this name
and I use it as a qualifier and I
restart the
application so here we see that we have
first Bean instead of Bean 2 because the
qualifier will be also using the bean
name the next type of dependency
injection is Method injection so I will
go back to my service right here and I
will remove these two I will just do
command X to keep them in my uh
clipboard and I will create a public
void method and I will call it init or
inject beans for example inject beans or
inject dependencies so this inject
dependencies it will take as parameter
my first class so here my first class
and I will call it my first class and
then all I need to do is this do my
first class equals my first class so now
all I need to do is to add The autowired
annotation and here of course because we
have three uh beans of type my first
class so I need the qualifier keyword
right here so I will just remove this
one and for example let's say I want to
use the qualifier bin one and now when I
start the application this method will
inject the needed or the required
dependencies so let's start let's try it
out
so here as you can see we have the the
message and here we have first been and
for example if I switch to the second
one and I use this qualifier with the my
second bean bean and restart the
application we will see that it will
print out second bean and it will be the
same if also I change the other one so
here what happens is spring when each
time it sees that we have this Auto
annotation it will try to use that that
one whether it's a a simple method a
Setter or Constructor in order to inject
uh the the necessary beans that are
required for this
class the final type of dependency
injection is called the setter injection
so all we need to do is to create a set
method for uh for our dependency that we
want to inject if we have multiple we
need to create a Setter for each so here
for example if I say set my first class
and also I need to provide the auto
method and of course here we need the
qualifier because we have three beans of
type my first class and like this it
will be using the setter method to use
or to inject this my first class Bean so
now if I restart the application I will
see that I have the correct output that
I'm expecting also if I switch to B one
for example it will print out first Bean
instead of second Bean so this is what
we see if we restart the application and
here we have first Bean so this is the
final one and this is called Setter
injection also as I as I mentioned
before always use Constructor injection
because this is the best way and the
recommended way by the spring Advocates
to inject beans or dependencies into a
class
as explained before spring also provides
some special beans so for example we
have the environment Bean which is a
bean that help us to read some
environment properties some environment
uh system and also access the
application properties and read the
properties from there even reading the
command line arguments so let me show
you how we can read the environment or
the system properties using this
environment Bean so first I will create
a private environment and I will call it
environment for that I need of course to
create a set and a Setter and add the
auto keyword so here I will add Auto so
this to inject the environment Bean into
my first first service class and then I
will just create a method I will just
duplicate this one and I will call it
for example get Java version so I want
to return the Java version used for this
project okay so I will remove this one
and then all I need to do is
environment. getet property and then I
know that in the system properties I
have a property called java. verion and
now all I need to do is to go to my
example application when where where I
have the main method and I will
duplicate this one and here I will just
get Java version so now if I run the
application we will see that the
application will print the Java version
okay so here we see that the Java
version that I'm using is
17.0.2 for example if I create another
method let's call it get Os or get OS
name so I want to return the operating
system name so it will be
os. name so this is the property to
return the operating system name and
then I will also just display it right
here so I will use or call the method
getos name and then I will restart the
application and I'm expecting to see the
operating system name which is for my
case the Mac OS
X the environment Bean is also capable
of reading any property defined in our
application properties file so for
example here if I go to application
properties and I will create a random
property or or a custom property so it
will be my custom. property and I will
give it a value hello alibu students for
example okay so now this environment
Bean will allow me or can help me read
the property from the yaml file okay so
here all I need to do I will create um a
new method so I will call it read
property or read prop just to say uh
property
and here I will just copy this property
name and I will paste it here instead
okay so now I will go back to my example
application. Java and I will applicate
this one and I will just call the read
prop method that I just created so here
if I start the application let's see if
spring is able to read it or not so it's
the case so here we have hello alibu
students so this means that this
environment being we'll try to read the
all the properties whether from the
system or even if we provide an
application or a property declared in
our application properties so it will
understand and scan also these
application properties and like that we
can read this custom property before we
move on let's clean up a little bit what
we created so here I will remove the
environment since we already uh saw how
it works so I will remove all this code
and then I will just move this to the
bottom or I will create or inject it in
a Constructor so I will add the final
keyword here and then I will say add
Constructor parameter and here I will
also provide the qualifier uh name so
for my bean so it will be qualifier and
then for example let's say Bean one so
this is one of the beans that we have so
this is my Constructor and I have now
tell story so I will go back here I I
will just remove all this so now I will
go back also I guess we need to optimize
import but yeah I guess we I already did
it so now we have our code cleaned up
and now we can move on and see what
comes
next now let's assume that we have
another application. properties file
where we are storing some custom
properties for example I will create a
new file right here and I will call it
custom do
properties so in this properties file I
will create for example my prop okay
equals alibu let's say okay just just an
example now I want to inject this my
prop into my first service so normally
now you get it if you want to do that
all I need to do is here so here I will
here I will say my custom property y
from another
file and then I will use the value
annotation and for the value an
annotation I just need to use this my.
propop as a property name okay so here
I'll just paste this one and now let's
create a getter method for this
one and now let's go to our example
application and try to read this one
okay
so from another file if I start the
application so here we see that we have
an exception saying that could not
resolve placeholder my. propop okay so
we are not able to resolve the property
or the placeholder called myprop because
it's not in our application. properties
file because spring is able to scan only
the only a file called application do
Properties or yaml so now how to provide
or how to tell spring that I want to
read properties from a different file
okay so all I need to do I go I need to
go to the class level right here and
here I need to use an annotation called
property
source so here we see that we have
property source and property sources so
I will use the first one and here I need
to provide the class path so I'm going
to make it full screen again so it's
class path and then custom because we
called we call the file custom do
properties okay so now if I run the
application let's see what will
happen so we see right here that we have
this message from the previous
implementation and then we have hello
alibu students because the hello alibu
students is coming from the application
properties and also we have this int
which is is 1 to three and now spring is
able to read the custom property from
this customproperties file because here
in this class we told spring also to
load the properties coming from this
file right here so if we provide a wrong
file name of course we will get an
exception so now let's duplicate this
one so let's say
custom file to for for
example and here let's say my prop
do2 and here let's say hello alibu okay
so now I can inject multiple files so
here instead of using property Source I
need to use another annotation so it's
just property sources and this property
Source it takes a table of type property
sources so here I will provide the the
table so it will be a property Source
this one and then the same again but
here I will call it custom- file das2
okay so here I will duplicate this one I
will call it uh read property from
another file to just an example and here
I will just move the value and make prop
do2 because this is the value or the
property that we want to read and then
all I need to do now just to test this
one I will create a getter for this
method so now if I go back to my main
class and duplicate this one and use the
two now if I restart the application
let's see what will
happen so here we have alibu coming from
the customproperties and we have hello
alibu coming from the custom file to so
in this way we can inject multiple
property sources and we can tell spring
to use that one to load the properties
that we
need what we will see now is how we can
inject a property from our application
properties into our Java class so for
example let's say here I have a private
string custom property and I will just
create a getter for this custom property
okay so here create a getter for custom
property and I will use this get custom
property just to display this custom
property in my main class so here I will
just use get custom property if I run
the application right now so by this
custom property I want to read this one
okay so what we see right here we have a
null value because we did not tell
spring how to read or that we want to
read this custom property so I close
this one now I will go back to here and
then what we can do to in order to
inject a value from our application.
properties file into a variable whether
it can be string or an integer or
something like that so we can use the
value annotation okay and the value
annotation it takes as a parameter a
string which is the value so the value
should be in this in this way dollar and
then curly brackets and inside the curly
brackets so I can use my custom property
so like this when the application starts
up and spring starts initializing the
beans and the the components anytime it
sees that we have a value annotation it
will try to read this property from the
application. property or the
application.yml file so now if I restart
the application I'm expecting to see uh
the message coming from here so it's
hello alibu students for example let's
go and let me show you that we can
inject also other values so here I will
just duplicate my custom
properties my custom property and then I
will say it's an INT and here for
example let's say 1 2 3 okay so now if I
go back here and I will just duplicate
this one and I make it as an INT and
here I will say it's an integer okay so
I'm going to make this full screen and
then I will also use the same uh value
annotation and here instead of property
I will say do int because this is what
we created in here and
now I will create a get method for this
one so create getter for custom property
int and here I have the get customer
property int so here again I would just
applicate this one and call this int so
this is just to show you that spring is
able to convert types so if I restart
the
application we see that we have alibu
students and one to three and for
example if I do one to three and with
the string and reside the application
let's see what spring will do so here we
see that we have a number format
exception so here spring was not able to
cast this string to an INT okay okay so
you need to be really careful with that
so if you uh it depends on the property
that you want to inject you need to have
the correct or the exact exact
type spring profiles provide a way to
segregate parts of your application
configuration and make it available only
in certain environments they can be used
to apply certain Bean definitions
conditionally for example different
beans might be registered in development
environment versus is a production
environment so each profile corresponds
to a set of configuration that Define
how the application should run in a
specific environment so an environment
might be a development test staging
production or another similar concept
the beans that are part of a profile can
be registered in the spring application
context only when the profile is active
this capability can be particularly
benefical in several scenarios for
example in environment specific
configuration you might have certain be
that should only be active in
development environment and different
ones that should be active in a
production environment for example in a
development environment you might want
to use a bean that clears and recreates
your database with this data every time
you start your application in a
production environment you would
certainly not want this Bean to be
active also uh profiles can be used for
component switching you can use profiles
to switch out entire entire component or
services for example you may have a
quick in memory database for development
while in production you would use a
fullblown database server also profiles
can be used for toggling features
profiles can be used to enable or
disable features if you're developing a
new feature that's not quite ready to be
deployed in production you can put this
in its own profile until it's ready and
in the next part we will see how we can
work in action with profiles let's see
now how we can work with profiles on the
level of the application properties so
for example here we have our
application. properties containing two
property my custom property and my
custom property int so now in order to
create a profile specific application
property all we need to do is to create
another file called
application- profil name. properties so
what I will be doing I will copy this
one and then paste it so here let's say
for example I will call it Dev so this
application Dash Dev properties will be
available or will hold all the
information for the profile Dev so here
in this application- dev. properties I
will change a little bit the the values
so here hello alibu students in Dev
environment okay so here let's skip this
one or like let's make it 3 to1 so in
order to see the changes now let me show
you how to run or how to set a specific
environment while running the
application from your IDE so here click
on this uh Arrow just to have the list
here and then click on edit
configuration and then you see this is
the configuration of your main class and
then we see here that we have active
profiles so here we can we can set
multiple profiles to be active at the
same time okay so now I want to set my
profile or my active profile to Dev and
then click okay so here spring when the
application starts it will see that we
have an application properties so first
of all it will be loading all the
information in the application
properties and then it will set the
active profiles to the dev okay and then
what spring will be doing it will be
overriding all the properties which are
similar in the application Properties or
and the application dev. properties so
here let me explain it so at the
application startup spring will load all
these properties in its context and then
it will see that it has an uh an active
profile and it will check that this
property already EX exists in here so it
will override the value using this one
okay so now let's go back to our main
application and we know that we have
already something to display this
property so all I need to do is to
Simply run the
application and here we see that we have
hello alibu students in Dev environment
and also we have the value 3 to 1 so
again if I stop the application and
remove the active profile from this
configuration right here click okay and
then if I run again the application it
will be displaying hello alibu students
as you can see right
here also we can change the profiles
using the application properties itself
so here in the main application.
properties so also I want to highlight
something it is always recommended to
have an application. properties that
holds all the common properties of your
application and then you can change and
override all the properties depending on
the environment so here in the
application. properties we can also tell
spring which profile we want to be
active so here all we need to do let's
put it in the first line so here we have
a property called spring. profiles.
active and here this spring. profiles.
active accepts a list of profiles with
comma separation but in our case we want
to set the dev environment as our active
environment and that's all now if I run
the application we will see that spring
will or the our application will be
displaying this message instead of this
one so let's try it out so if I click on
start the application and then we see
that we are displaying this also let me
show you how it's how it will be
displayed in the
logs so here we see that spring is
detecting that that we have one profile
active so it says the following one
profile is active which is Dev for
example if I said if I set another
profile or let's say test for example
and custom all right and if I restart
the application even if we don't have
these environments or these application
properties specific for the environments
it doesn't matter so spring will not
block the application spring will not
throw any exception if it doesn't find
any properties for that environment
because the environment is the developer
responsibility so when you set an
environment here or if you set an active
environment make sure that you have the
properties or like the necessary
properties and configuration for that
environment so here in the logs we see
that the following three profiles are
active Dev test and custom so here let
me show you also something which is
really important
now I will just duplicate this Dev
properties and I will make it test so
since we already set an active profile
test so here I will just save for the
test in test environment so I just want
to show you if the order matters or not
so now all I need to do is to restart my
application and here we want to focus on
the output of this one okay so let's
restart the
application so here we see that test
environment okay we are displaying the
properties from the test environment and
here here here how it works so let me
show you in a different way so I will
set test first and then Dev and then I
will remove test from here and I will
restart my application and let's see
what will happen so here we see it's
displaying in Dev environment so here
spring first of all it will start
loading the properties from the
application. properties and then it will
check the first profile and then it will
override all the properties that can be
overridden and then it will check the
next one and again it will override the
properties and so and so forth so you
need to really be careful about the
order for the
profiles and also this information can
be useful for you in case for example
you set some active profiles and you see
that a property is not correctly
overwritten or is not correctly said so
you may want to check the order of your
properties the active profile can also
be set programmatically so let's do this
I will comment out this property so it
will not override our configuration and
I will close all this and then I will go
back to my example application in our
main method and here I will externalize
a little bit so here I will create a
variable app equals new applic new
spring application
and for this spring application I will
just pass the example application. class
which is our main class and then all I
need to do here is switching up. run and
we need to remove this so here after set
or after getting the application or the
spring application what we can do we can
say up do set default properties and for
this property we need to pass a map of
type
string and object so we can use
collections do Singleton map and here we
can pass the key and the value so the
key is the property spring. profiles.
active and the value is for example
let's say Dev now if I run the
application we will see that it will
display alibu students in Dev
environment and again if I switch it to
test since we have also our application
test. properties and then if I rerun
again I will see student in in test
environment so this is how we can
programmatically set the active profile
in our spring application next we will
see how we can also have beans which are
available only for a specific profile
now let's see how we can make a Bean
available only for specific environment
so let's go back to our application
config I'm going to make this one full
screen and now in order for example to
make this bin one available only for Dev
environment and this being available for
test environment all I need to do is to
add an annotation called profile and in
here all I need to do is to provide the
profile name so let's say this one is uh
sorry it's profile not primary and let's
say this Bean my first Bean should be a
available only for Dev environment and
again I'm going to duplicate this one
and make the second Bean available for
the test environment okay so now if I go
back to my first service and here I'm
using my second bin so if I use for
example this bin one in here so now I
want to inject bin one in the my first
service and then if I go back to the
example application and try to run the
application and here remember that we
have our active profile which is Dev and
again just to remind you before we start
we are injecting the bean having the ID
Bean one so it is this one which is
available for the dev environment so now
if I run the
application we see that we have hello
alipo students in Dev environment now if
I switch to test environment I'm
expecting the application not work
because this Bean will not be registered
for the test environment so spring will
only register the Bean for the profile
environment so now let's restart the
application and let's see so here as I
mentioned before we have an we have an
issue so here it says that the injection
Point has the following annotation we
want to inject a bean qualifier but
these following candidates were found so
we have my second bean and my third Bean
because in the application config we
have my second Bean available for the
test environment and also my third Bean
available for all the environments but
the bean one is no longer and is not
registered for the test environment or
sorry for the test profile which is the
active one so we can say environment or
profile it's also correct so in this way
we understand that spring or if we set a
bean or even a configuration available
for specific profile it will not be
registered for the other profiles so
also let's try it out with a
configuration in here so also we can set
the profile annotation on the class
level and here let's say these all these
configuration should be available only
for Dev so I can remove all the uh all
the profile annotations from here and
this means that I want to inject this
profile or this application
configuration only for the dev profile
so here if I go back to example
application I'm expecting again to have
or to get the same issue but now we
should not also see this one okay so
let's try it out and see what will
happen so here we see that again we have
the same issue or like the same
explanation that injection point this
means that spring is looking for a bean
with a qualifier Bean one but here it
says that we did not find any other Bean
of the same type okay so it's already
mentioning consider defining a bean of
type com. alibu my first class in your
configuration so here if I go back again
and change the active profile to Dev in
here and rerun the application so the
application will be up and running
correctly so here you need to be careful
how you how to define your profiles so
now you understand that when you define
a profile or you set the annotation
profile on the class level this means
that the whole class will not be
registered if you set it on a method
level this means that the specific
method will not be registered when the
application starts
up rest stands for representational
State transfer it's a software
architecture style that defines a set of
constraint to be used for creating web
services these web services are often
called restful apis or restful
application programming interfaces if
they adhere these constraints rest was
first defined by Roy fien in his 2000
doctoral dissertation the main idea
behind rest is to treat networked
resources as object that can be accessed
us using standard HTTP methods such as
get post put delete Etc and here are
some of the fundamental elements of the
rest
architecture first client server
architecture this principle establishes
that the client and the server should
act independently they can interact with
each other but each side can be
developed and updated independently
stateless each HTTP request that happens
from a client to a server should contain
all the necessary information to
understand and respond to the request in
other words the server should not store
any data between requests which keeps
each request isolated and independent
then cachable restful architecture
allows client to cach responses
responses must implicitly or explicitly
Define themselves as cachable or not
prevent clients from reusing outdated or
appropriate data in response to further
request then layered system the
architecture allows for layers within
the system architecture a client cannot
ordinarily tell whether it is connected
directly to to an end server or to an
intermediary along the way which can
include load balancing security measures
and so and so forth then code on demand
this this is the only optional
constraint it allows the server to
extend functionality of a client by
transferring executable code and finally
uniform interface this is a fundamental
to the design of any restful system it
simplifies and decouples the
architecture which enables each part to
evolve independently the four guiding
principles of the uniform interface are
first identification of resources then
manipulation of resources through these
representations and then
self-descriptive messages and finally
the hyper media as the engine of
application state or also known as
haos so restful API have become a very
popular in modern web
application development due to their
Simplicity scalability State
statelessness and compatibility with the
web they are often used to create
interactive applications mobile
applications and web
services however they are not suitable
for all type of applications and other
architectures or protocols such as
graphql or grpc might be used to to
depending on the specific needs of the
application to resume the rest is the
web architecture principles unique
identification of resources or also
known as URI different resources
representation hyper Media Link or link
of resources stateless communication and
finally standard methods such as get
post put delete and responses such as
200 404 and so and so forth when
designing a restful API there are some
standards that we need to follow first
the resource should be always plural
nouns in the API endpoint and if one
instance resource should be retrieved
pass the ID in the URL for example we
can have have get/ accounts or if we
want one single account it should be a
get method SL accounts slash the ID or
for example for deleting one single
element it's delete SL accounts SL2
which is or which represents the ID of
the resource that we want to delete in
case of nested
resources which means resource under a
resource the resources should be
accessible as follows for example if we
want to get the payment from the
accounts it will be accounts SL1 which
is the account id/ payment and then the
payment
ID so use the HTTP methods to specify
what to do with this resource with the
method get post put uh patch delete you
can provide crude functionalities the
crude stands for create read update and
delete use HTTP methods also as known as
verbs to specify what to do with this
resource with the method get postp
delete you can provide crude
functionalities and here this is an
explanation how we can design our
resources for example here if we want to
get the if we have slash accounts and
this means when we have a get method
with slash accounts this means that we
want to get all the accounts post this
means we want to create a new account
put a bulk update all accounts this
means we want to update all the accounts
and delete this means we want to delete
all the accounts now let's see when we
have a single resource so when we have
account slash the account ID then it's
get account with ID one so for the post
this should be an error because we
should not allow that we post a resource
with an with an ID then for the put this
means that we want to update an account
with ID one one and for the delete it's
deleting an account with the ID
one then for for the resource for
example for the nested resources the SL
account accounts SL1 SL payments this
means when we have a get verb this means
get all the payments for the account ID
one post this means that you want to
create a new payment for the account ID
1 and then for the boot this is a bulk
update all payments for account ID one
and the same for the delete this means
that we want to delete all the payments
with the account ID
one when designing restful apis we need
to use HTTP methods all also known as
verbs so here we have the following
verbs that we can use to design our
restful API first we have the get method
or the get verb this method is used to
retrieve data from a server it is a
readon operation meaning it does not not
affect the state of the resource and
then we have the post post this method
is used to send data to the server to
create a new resource the data is
included in the body of the
request then we have the put so this
method is used to update an existing
resource or create it if it does not
exist the update or new data is included
in the body of the
request then we have delete so this
method is used to delete a resource
specified by a URL then we have patch
patch this method is used to apply
partial modification to a resource as
opposed to the put method which is
useful for full updates like post and
put this data for the update is included
in the body of the request then we have
options so this method is used to return
the HTTP methods that the server
supports for the specified URL it can be
used to check the functionality of a web
server then and finally we have head so
this method is similar to get but only
Returns the header of the response not
the actual data for example the body so
this is useful when you want to check if
a resource exists before trying to
download it or check if it has been
modified when implementing restful apis
we cannot skip talking about status
codes so the response status code R HTTP
status codes are three-digit codes
returned by the server as part of the
HTTP response indicating the outcome of
the request made by the client the first
digit of the status code defines the
class of response while the last two
digit do not have any categorization
role the there are five classes ranging
from 1xx which is informational
responses to 5X x x which is server
error response so the first one is
informational the second one which is
2xx means success the 3 XX means
redirection and the 4xx means client
error and then finally as mentioned
before we have the 5xx which means that
we have a server error now let's move on
and check each one of them the first
category is the success category which
is represented by the code two
2xx so this 2xx has some some codes
first of all we have for example the 200
with which means okay so this is the
standard response for the successful
HTTP requests when you make a get
request for example and the server
successfully processes the request and
provides the requested resources in the
response it will return a 200 status
code this status code simply means that
everything went as planned and and the
result data if any exists is included in
the
response then we have two one created so
this 21 status code in indicates that
the request was successful and a new
resource was created as a result this is
typically the response sent after a post
request or something or sometimes put if
you're creating a resource with that
method where a new resource is created
and the server based on the data set to
the
request then we have also a 2004 which
means no content the 2004 status code
means the server successfully processed
the request and there is no additional
content to send in the response payload
body this is often the response to the
delete request put or post request when
there is no particular information to
send back in the HTTP response body but
header is useful in other words
it's a way to for the server to say I
did what you asked where and we're done
so you don't need to go anywhere else
this response may also be used when the
server doesn't want to return any
information like as a result of a delete
request confirming the deletion is
successful the redirection category also
represented by the 3 XX response codes
so the HTTP status code for this
category will we will mainly focus on
one which is the most important and the
most used in in restful apis which is
the 304 not modified so the HTTP status
code 304 not modified is a special type
of response that is used for caching
purposes when a client sends a request
to the server it can include a header
such as if modified sense or if non
match these headers are used to ask the
server to validate if the client's
cached version of the of the resource is
still up to date if modified since uh
use a timestamp to determine if the
resource has been updated since the last
time the client requested also we have
the if non match it also works with e
tags or entity tags which is a token
associated with a specific version of
the resource so if the resource has not
been modified since the given date time
in the case of for example if modified
sense or the entity tag still matches so
in this case if non match so the server
will respond with a 30 or4 not modified
status and not send the body for the
response because the client cash is
still valid by utilizing a 304 response
you can save bandwidth and make your web
application Faster by not unnecessary
resending resources that the client has
already cached so these leverages one of
the main principles of HTTP which is the
idea of being stateless but still
allowing for optimizing through caching
client error category are represented
also with
4xx so here we will check the most used
responses and first we will start with
the 400 bad request this status code
means the server was unable to
understand the request due to invalid
syntax this could be malformed request
or a request with invalid arguments the
client should modify the request before
repeating it then we have a 401
unauthorized so this status code means
the request requires us user
authentication if the user already
included authentication credentials then
the forward the for 4001 response
indicates that the authorization has
been refused for for these
credentials this could be due to a wrong
username password or the user does not
have the necessary privileges this
status is similar to to the 403
Forbidden but specifically for cases
where authentication is expected but has
failed or not yet been
provided then we have the 403 Forbidden
so this status code means the client
does not have the necessary permission
for the request resource in contrast to
the 401 unauthorized response
authenticating will make no difference
this status code can also be used when
the server does not want to reveal
exactly why the request has been refused
or when no other responses is appliable
so for all these status code are part of
the 4xx class of HTTP status code which
indicates that server was likely an
error in the request sent by the client
that prevented the server from
processing it as a best practice the
client should after its request or
authenticate and authenticate
appropriately based on these
responses now let's see an example how a
r API looks like when we implement it
use using spring boot so here for
example we have a payment rest
controller and this is the class where
we will expose the sources for a payment
object for example and in order to make
this class a controller or exposed as a
rest resource we need to add The
annotation rest controller and then as
you can see here we have a method so
this method will will return a response
entity of type payment information so
the payment information will be the
response body of this method called
initiate payments and here as you can
see we have a post mapping which is the
verb or the HTTP method that will be
used to uh in to invoke this endpoint
and then it has a value SL payment as
explained before the way that we need to
name
our endpoints then we see that we have a
body coming within this request and it's
annotated with annotation request body
and then we have our business code and
then we want to return like the result
location
which is for example SL payment slid
which is the ID that was returned after
persisting or saving the payment into
our database and then we return a
response entity dot created so the dot
created this F this method right here
will return an H status code for the
created representation which is the 2011
and then the body we because we can also
return a body within the within the RIS
response of this method which is the
confirmation that we created before also
in addition to that we can specify the
response code to this method and this is
how it looks like so here we have a
response status annotation that we can
use so to specify the response stat
status of a controller method annotate
the method with the response status and
then we can give it the status code that
we want to return so spring only uses
the response status when the marked
method completes successfully without
throwing any exception in the coming
parts we will see in action all what we
discussed
before server error category so for this
class we will see the 500 internal
server error so this is a generic error
message given when an unexpected
condition was encountered by the server
and no more specific message is
suitable in other words it means that
something has gone wrong on the server
itself it doesn't provide a clear reason
because thereor could be for a variety
of reasons such as server
misconfiguration or ancot exception on
the server side code or a server
resource issue like memory depletion
then we have the 503 which is service
and available this status code indicates
that the server is currently unavailable
to hand the request because it's
temporarily overloading or down for for
maintenance generally this is a
temporary state it may include an
optional retry after header indicating
how long to wait before making a new
request so both of these status codes
are part of the 5xx class of HTTP status
codes which indicates situations where
the server is aware that it has
encountered an error or or is otherwise
incapable of Performing the request
these types of error are often outside
of the client's control and may require
attention from the servers
operators that's good you made it this
far so now before we move we move on to
the spring rest let's first clean up our
code so what I will be doing is I will
remove all the unnecessary classes and I
will just leave this example application
which is our main applic ation and
afterwards we will start implementing
our first rest API so what I will be
doing I will remove this classes so just
select them and then click on delete and
then just click okay so you click delete
anyway just also okay and then we will
clean up the code that we have right
here so I will just copy this one and
make this Spring Run and then let's
remove this and also let's remove all
this code and then we need and then we
need to pass the example. class as a
parameter so now we have our application
back as it was and now I will optimize
the Imports and also I will remove these
properties because we no longer need
them we will see them afterwards if we
want to work with profiles so now we
have our application back as it was now
just to make sure that everything is
working fine just try to run the
application and always we need to check
is that the application is up and
running as we can see here so the
application started on the port 8080 and
started example application in some time
like it depends on your machine so now
we are up and ready to continue with our
rist API now let's create our first
controller so here I would just right
click here and then new and then Java
class so here I will call it first
controller and then this is the class
that will represent our first controller
so here in order to make the first
controller as a controller that will be
scanned by the spring boot all we need
to do is to add the rest controller
annotation and in order to have this
rest controller annotation just make
sure that you have the spring boot
starter web dependency in your pom.xml
or Gradle do properties
so now let me first make this one full
screen in order to create an endpoint
first we need to Define what is the verb
or the HTTP method for this point for
this end point so let's assume that we
want to perform a get method so here we
have an annotation called get mapping if
we use this get mapping annotation so
this means that inside this rest
controller we have a get mapping or a
get method method so here let's say for
example a public string this method will
return string and let's say or let's
call it say
hello and then all I need to do is to
return hello from my first controller
for example and then of course don't
forget to give the your endpoint a path
okay so here we can even work without a
path so let's
let's try it like that and then let's
see how we can enhance this so I will
run my
application so here we also see that the
application is up and running now I will
go to the browser and as you saw in the
logs the application started on the port
880 so to access any get end points
using the browser all we need to do is
to access the local host and then the
port number which is 8080 in our case
and then just hit enter so here we have
a 404 because we don't have any end
point defined on this URL so if I add
the slash right here it's also the same
so that's why we need to define a
mapping for our endpoint so let's go
back to our
anj and here in this get mapping so I
will add slash hello for example okay so
this is not respecting the the naming
conventions of course but we will see
that in details later on so now I will
restart my
application again the application is up
and running on the port 8080 with a
context path empty I will explain to you
what is this context path later on so
now let's go back to the
browser and all we need to do is to
refresh and here of course we need the
slash hello so when I hit or when I try
to reach the/ hello endpoint spring will
go and we'll know that we have an end
point Point called /hello available
after or under the default context path
that we have and this is the message
that we provided with within our
endpoint so let's go back to anti J
again so here if for example I duplicate
this one and I create another endpoint
so let's say
hello-2 and here let's say for example
hello to and here say hello to from my
first controller and then if I add a
response status we will see the
difference but before adding the
response status let's go to the browser
again and inspect a little bit more and
see what happens so here if you click on
F12 or right click and then inspect so
you will have you will have uh this
interface and then you can go to network
now if I refresh we see and then you
need to click on all we see that we have
this endpoint hello and here this one
let me make it let me Zoom it in so here
we see that we have a banch of
information so we have the request URL
here it's it it goes to the Local Host
8/ hello and the method is a get because
we in in our endpoint we defined it as a
get mapping and then we have a status qu
200 and also we have the remote address
and the bench of other information we
also have some response headers which
are the default response headers even if
we don't specify them also we have a
request headers which are included by
the browser itself okay so now let's go
back to anj and here for example if I do
response status and here this response
status let me show you how like the
implementation or the code of this one
what we can pass as a parameter which is
the value right here it's an object of
type type HTTP status so this HTTP
status class it's aam actually contains
a bench of methods okay or variables so
for example continue is 100 and here for
example let's go back and here for
example if I search for the 200 2001 you
will see that the 2001 is created okay
or okay is 200 so the default one is 200
if everything goes fine so now let's
play a little bit with with this so
let's say that I want to use accepted as
a response status for my second endpoint
so here all I need to do is to provide
an HTTP status. accepted so it will
automatically go to this one and return
to O2 okay so now let's resp let's
restart the application and see the
changes so again in the browser if I
access the hello -2 and point we see
here that we have a status 202 which is
the one that we specified before so here
it's a get method again and we have a
202 as our status code which is the one
that we already specified as an
annotation in here so like this we can
specify a response status for each
method or we can leave it to the default
one which is 200 but it's always
recommended to specify the Response Code
or the response St status as the verb or
as the method or as the requirement of
our
application okay that's good so now you
understand how we can create an endpoint
and also how we can specify the response
status so now I will just clean up this
one also I will optimize the Imports and
let's create our first post mapping
endpoint so for the Post mapping it's
always the verb and then mapping so the
annotations with spring boot are always
like verb and then mapping so post
mapping get mapping put mapping and so
and so forth so here let's say post
mapping and let's give it for example SL
poost and then I will just perform a
public string post for example and here
I will just return request accepted for
example or saved or like you can say
whatever you want so here for this post
mapping we need and as we mentioned
before when we perform a post mapping
this means that we want to post some
data or to send some data from the
client to the server so the client in
this case is our browser or any other
tool that we want to use to perform rest
requests so here we need to provide a
body for example so the body in here I
want for example let's say string and
let's say message okay so here I I will
just update this a little little bit
request accepted and message is and then
just message we will just display the
message that we get as a parameter okay
so now if I if I start my application
and I go to the browser and try to hit
this post and Point Let's see what will
happen so again let's check the server
is up and running now if I go back to my
browser let me reduce this one and let's
try to access SL poost and hit enter so
here we see that we have an error
message so this application has no
explicit uh mapping for error and so on
so forth and here we see that we have
this post 40 405 and this is because the
browser does not support post requests
so it does not support post request this
means that the browser address bar right
here typically sends get request when
you enter your URL and press enter so
this part of the design and
specification of web browser a get
request is meant to retrieve a resource
which is exactly what you're doing when
you enter a URL you're asking to to
retrieve and view the web page so the
post request on the other hand are
designed to send data to server to
create or update a resource so post data
is sent in the body of the HTTP request
not in the URL this is the part of the
HTTP specification so now since we are
not able to use the browser address bar
to send post requests let's see what is
the alternative for
that now let's see what is the
alternative for using or as a HTTP
client to send request to our backand
server so for this if you are already
familiar with Postman you can skip this
video and move on to the next part but
before that let's first see or let's see
or Define what is Postman so Postman is
a popular API client that helps
developer for build test and debug HTTP
requests it's used for API development
and testing and it simplifies each step
for the API life cycle including design
mocking testing documentation and
monitoring so first let's see how we can
install
Postman so it's so simple just go to the
browser go to Google and then just
search for download Postman you will
find the first link which is posting or
like which is referring to the Post
man.com website and then click on
download Postman and get started for
free so here as you can see we have or
like we can download the app and this is
how Postman looks like so also you can
change the the theme you can make dark
theme or light theme and here depending
on your uh on your operating system you
will see the download button right here
so here for example for my case I have
an apple chip or if you have an Intel
one or if you have Windows or Linux and
so on so forth you can just click and
download Postman and then install it so
the installation is quite easy and
straightforward so now let's go back to
postman and start exploring Postman and
its different features so this this is
how the post manual looks like so first
let's start by defining the theme so how
you can manage and how you can Define
the theme so here you see this Cog right
here then click on settings and then you
have themes so for the theme you for the
theme you can whether choose the system
default so it will be depending on the
system uh layout and and look and feel
also you can make it uh a light version
or also you can use the dark one which
is the developers preferred theme so I
will keep it dark for the sake of this
course
then what we can see in here we have
this plus button this is when and where
we can perform HTTP calls to any backend
so here what we see we have the URL or
we have the URL that we can that we want
or the URL of the endpoint that we want
to invoke and here we have the list of
the supported HTTP operations and as we
can see here here we have get post put
patch delete head and options so these
are the HTTP methods that we already
explained and spoke about before and
here all we need to do is to perform or
like or to paste or type the URL of our
API so here we also see that the the
history of my uh previous uh URLs that I
used in here and so for example if I use
one of these and since our API is also
available on the Local Host 880 and if I
try to reach the hello end point and
click on send so we see here that we
have the response that we also saw on
the browser so also here this is a get
mapping and here let's explore what we
have in here okay so for depending on
the depending on the method or the verb
that we want to do we we have a list of
uh few things here that we can do for
example here we can pass request params
and here for example if I have for
example I want to pass a parameter as
like first name equals Ali for example
you see here that it's immediately
changing and like doing a binding
between this request param or query
param and the one right here so for
example if I add a second one last name
you see that it's also changing in the
in the URL or in the in the uh URL
address bar right here so here for
example if I say bu Ali
as a last name you see that it's also
reflecting in here so here where where
we can pass query params then we have
the authorization tab so here if we have
a secure back end or secure API here
where we can specify the type of the
security we have and we can pass the
values for it for example if my API is
secured with an API key so all all I
need to do is to select API key and then
I paste like give the key name the key
value and where I want to include this
one as a header or as a query param
depending on how you implemented on your
backend then we have the headers tab so
the headers tab by default we have few
few headers which are hidden these
headers are automatically injected and
included by Postman or even the browser
itself as we saw before so here for
example we have the postman token we
have the host user agent and so on so
forth also if I want to specify a
special header that I need for my back
end I can also call it for example here
my header and then value for example and
then we can also specify description so
this is where we can where and how we
can pass extra headers to our back end
and then we have the body so this body
tab is mainly for all the requests like
of type post put patch and and that's it
for the delete I we we don't need to
pass any uh any bodies so for example if
I have a post request and here I can H
or I have different types of uh of
bodies so the body can be know this
means that I don't have a body for this
request which is also valid for some uh
for some apis or for some endpoints so I
will just clean up the URL and then we
have also form data so the form data
it's just a key value and for example we
can pass a text or for a file in case I
want to upload a file all I need to do
is to select file in here and then
select the file from from my
system uh then we have also another type
of body which is the URL encoded which
is a key value
map then we have row which is the part
that we will see and we will use later
on or we can also pass a binary so we
can also select the file and and send it
and even also if we have a graphql we
can pass the query and the query
variables and so on so forth so now
let's go back to to this row and here so
the the body can be whether a text or
JavaScript or Json or HTML or XML and
those are the supported body types then
we have another tab right here which is
the pre-quest script so Postman also
supports scripting so we can before
sending the request we can perform a
script for example I can perform a
script or I can write a script to grab
grab some data or to grab a token from
somewhere and inject it or save it to an
environment variable that that I can use
for example in my authorization or even
in the header and so and so forth also
we have the test tabs so when I run or
when I want to test some um to test my
endpoint and if everything is working
fine I can perform test scripts here so
that the scripts are JavaScript based
and here like you can see for example
that you have some some code Snippets so
for example here if you want to test
that the status code is 200 all you need
to click on that and you will have the
code ready to use so also you can refer
to the official documentation of Postman
and you will understand and you will get
everything you want to get started with
testing with Postman so here I will just
go back to the authorization and move it
back to non because we don't have any uh
security also I will just remove this
test and finally we have some settings
this for example if you have some
specific requirements for uh for your
application or for your backend so this
is where you can specify these settings
but for now it's not something that
which is really important for us and
relevant so we will skip this part also
with Postman we have a bunch of other
features so here we can create
Collections and this is the part that we
will cover later on when we when we
implement the the test part so we have
here collections we can create a set of
collections which is a set or like a
group of the the request that we want to
perform and we can have them for example
this is one one of the requests of a
previous boot camp that I already
animated so here for example we can
specify the order and the flow that we
want to uh that we want to execute
within a single collection and also this
is this can be part of the endtoend
tests later on also we have API here so
we can switch to workspace or like to
like we need to set up a workspace and
here for example we can collaborate with
other teams and so on so forth also we
can Define environments so environments
it's something similar to what we
explained before we can work with
environments on Postman too so for
example let's say I have this uh this
URL right here and I can run it on for
example on a Dev environment on
pre-production on production staging and
so on and so forth so I don't need to
change or to switch every time the URL
from one environment to to another all I
need to do is to set up my environment
and just click or select or set that
environment to the active one also with
Postman we can use mock servers so users
can create mock servers to simulate API
responses which is useful in the early
stages of development when the back end
is not fully built so here you can you
can say for example when you access this
endpoint return this and this is what we
call mock or mock server and also
mocking this is a part that we will be
covering in this course later on also we
have some monitorings and here we see
also the history of all the requests
that you perform on Postman so this is a
global overview for uh for Postman and
now we let's move on and try to test our
post method now we can use postm to
perform this post request so let's open
Postman and let's click on this plus
icon and then all I need to do is to
specify my EUR my URL so I will use just
an old one and then I will clean up so
my endpoint is localhost 880 slost as we
have it in our back end so here it's a
post request so I need to select the
verb or the method which is a post and
all I need to do is to click click on
send so here let's check ah okay so we
did not start our backend so let's start
it and now let's go back to postman and
here because we saw this message uh
could not send request so this means
that the that the server is not up and
running so that's why I had to run it so
now let's click on send again and here
we see that the response or the answer
from our post method saying that request
accepted and message is null so the
message is null because we did not pass
anybody because my post end point is
expecting a string message as a body so
I need to pass that so as I explained
before to pass a body click on the body
and then we have the type Pro because
all we need to do is to pass a text or a
Json uh body or XML it depends on on the
body type that we want to expect but in
this case it's just a message message so
it's just uh a classic test or or a
normal test body so here let's say alibu
for example and I will click on send
again but even if I have my body right
here the value of the message variable
is always null even I have a 200 okay
coming back from my back end so maybe
let's change this one to Json and click
on send it's still always null let's try
with XML or HTML it's always null as a
response so let's go ahead and check why
this is null let's quickly restart our
application in debug mode and let's add
breakpoint to the line 19 and then let's
send the request again and see maybe
there is we receive correctly the value
for this message variable and maybe we
have something wrong with our
implementation so let's jump back to
postman and let's click on send again
so here we see that we have our
breakpoint and don't worry about that
about debagging because I will make a
full video just to cover how to debug
with anj but as you can see here the
value of our message is null so this
means that we don't have any issue with
our implementation this means that we
well no no issue so far because maybe we
missed something but for this case we
are receiving null so this means that we
are not able to map or to transform the
message or the value of the message we
received from Postman or or uh our rest
client and we are not able to map it to
this variable now let me show you and
let me explain why when we work with
spring framework we need always to tell
spring and to indicate for each step
what is the request body what is the
response body what is this what is that
because spring is smart enough is a
complete framework but it will not do
the job for us so in this case we need
to indicate that this parameter we have
right here is a request body or should
represent the body of our request or of
our method we have right here so in
order to fix that what we need to do we
need to add one annotation which is a
request body so this means this is the
body of our request and the request body
annotation is used in the spring MVC to
bind the HTTP request body with the
method parameter it's part of the
Spring's approach to build restful web
services and is used in the controller
layer where the HTTP request is handled
so as you can see here we have our
request body in our method right here
which is already part of our rest
controller so now let's restart the
application in a normal mode and let's
test again and see what will happen so
again in Postman if I click on send now
we see that we have alibu so here let me
explain a little bit what happened so
here when we send alibu as a message or
as a body for our request then here in
anj using this annotation so when we
annotate the method parameter with
request body spring will use the HTTP
message converter to convert the HTT CP
request body into the specified Java
object so here for example it can
convert Json data to the request body
into the Java object or if it's for
example here uh the case of a string of
a simple string it was able to convert
anything coming from the from the re the
body uh of our request to this string
message so here let me show you
something else here we see that the type
of the body or the type of this row uh
object is text now if I transform it to
Json and here so here this is how we map
or rematch the Json representation so
our parameter is called message and then
let's give it a value alibu then let's
click on send and see what is the output
so as you can see so the request
accepted and the message it just
returned back this object so for us it's
a Json because we selected Json as a
type in here and we passed an ad Json
object but here in our implementation
the object is of type string so it it's
just transforms this Json representation
which is also a string to just string
message but if I have a complex object
or a Java object in here it will also be
able to transform this to the Java
object we will see this in details later
on now let's assume that I want to PST
post an object that should hold the
information or the data of an order
object this means I want to post the
customer name the product name and a
quantity to save it or to do whatever
logic we need behind so let's go ahead
and create such class so here on our
base package right click and then new
and then Java class and let's call it
order dto or let's just call it order
for now so click enter and here let's
define some Fields so I will have
private string customer name and then
let's say we have also a private string
product ID or or product name it also
works and then let's have finally public
in quantity and this is the
representation of our object that we
want to post right now because in the
previous example we just so uh we just
saw how to send a simple string as
object now let's let's see how we can
send a complex object to our controller
now if we go back to our first
controller class and let me make this
one full screen and I will duplicate
this method and or for the mapping I
will call it post- order and here
instead of having a string message I
will request or ask to have the order
object which is part of com. al. example
the class that we just created and let's
call it order okay
so here let's say the request accepted
and order is and let's simply say our
object order dot to string so this is
going to be the default to string method
let's see what will be the output but
first of all let's start our application
and go to our Postman and test this one
so first I'm going to start the
application so we will get this new
endpoint ready to use so as you can see
the application is up and ready now if I
go to postman and here here I will
duplicate this tab so just right click
on it and here you have duplicate
tab so here I will just change the url
to post order and then I will change the
body so here we have the type it's Json
and to represent the object that we
created in our backend to ad Json type
all we need to do is the is the
following so here in the this order
object all we need to do is to take
these names right here the f names copy
them and then go back to postman and
here I will remove all this and just
paste this so here the name should be
exactly the same so no type was in in
there and then I will show you how we
can perform the types so here for string
it should be also in double column so
let's say alibu for the customer name
and then for the product name let's see
let's say for example iPhone and for the
quantity since it's an integer so it
will be just one and then don't forget
to add a comma after each field so now
let me format this and now we have this
is the Json representation of our Java
object so the names should match and
then I will show you how we can also if
we want change the Json uh property
names so we can also do that so now
let's go ahead and click on send and see
what will happen so here we have this
com. alibu example so this is the object
now I will restart my application in
debug mode and let's add a breakpoint
and see what's happening exactly going
back to our first controller I would
remove this breakpoint and move it to
line 27 since here we receive the order
object and then I will restart my
application in debug mode and then I
will go back to postman and click on
send again so here we have our order
object so let's check what we have we
see here that we have customer name is
null product name is null and quantity
is null okay so I will resume this also
I will just go back to my order class
and generate the two string method so
here just use the autoc
completion and here we see that we have
this two- string method and I want this
two string method to include all the
fields that I have and then I will click
okay so here this will be the string
representation of my order class so if I
restart again just to make sure that we
uh we see exactly uh these two string
method or what we expected let's go back
to
postman click on Sand and then I will
resume since I have my breakpoint
activated and then let's go back so here
as you can see we have null null null
but we already sent an object in here
okay so we sent values alibu iPhone and
one but we see that we have null values
so let me explain to you why we have
this when when we sent our request
containing this request body right here
with the following values alibu iPhone
and one we saw that the response was
containing null values so as we saw
customer name was null product name was
null and the quantity was there was Zero
which are the default values of the
types that we chose and this is because
we didn't create any accessors for our
order class so coming back to this
order. Java class we see that we has
created private Fields customer name
product name and quantity and this is
without any accessors so the accessors
are Getters and and Setters also known
as accessors are mutator methods they
play a crucial role in the serialization
and deserialization process in the
context of a Frameworks like spring and
libraries like Jackson which are
commonly used for serializing and
deserializing data and
and uh from formats such as Json so
these methods have specific uses so for
example the Getters when an instance of
an object is serialized into a format
like Json the getter methods are called
to access the current state of the
object the values returned by these
methods are then written into the
serialized
format now for the Setters during this
realization Setters are used to populate
the field of a newly created object with
the data from the serialized format so
now to fix the issue all we need to do
is to generate Getters and Setters so I
will click on generate and here we see
that have we have Getters and Setters
and also as I mentioned before each time
I use a shortcut you will see the green
popup right here to to see or to learn
which uh shortcut I used so now I will
generate Getters and Setters for all the
fields that I have right right here so
it will be for customer name product
name and quantity and then I will click
on okay so now we have the accessors so
now if I restart my application I can
also leave this breakpoint I will
restart the application and then I will
go back to postman and send again the
request so here I will click on send and
now let's evaluate this order so we see
that the customer name is alibu iPhone
and we have also the quantity if I
resume the program and go back to
postman we see that we have the object
that we already sent so now I guess you
understand the importance of having
accessors while you use object to
transfer data from a client or rest
client which is in our case Postman or
it can be any other application like a
front end framework like angular or
react or even native JavaScript and you
need accessors to serialize and
deserialize the object so so now as a
Next Step let's see how for example I
can customize the name of this Json
field so for example I want to have a
different name for my Json
representation and another different
name in my Java object now to specify a
different property name and this case
can happen for example in case I want to
consume or I want to send data to a
third party API and the names are not
the same as my Java object for example
we can have a casee of uh a customer
name it might be C name p name for
product name and Q for example just for
quantity and I want to create a decent
and comprehensive comprehensive Java
object with customer name product name
and quantity and also I want to uh I
want Java or my spring framework and
Jackson to correctly map these objects
so all I need to do is to use an
annotation called Json property and this
Json property comes from the from the
package com. faster xml. jackson.
annotation which is the Jackson Library
which is used by the spring framework
for the serialization and
deserialization process so here let's
say that this customer name I wanted to
have a c name for example to reference
or to say that this is the customer name
but before going forward let's quickly
check the Json property annotation and
here in the official documentation of
this annotation it says that it marker
annotation that can be used to define
non-static methods as a Setter or getter
for logical property depending on its
signature and so on so forth so here
this is the most important
part the default value is empty as you
can see in here indicates that the field
name is used as the pro as the property
name without any modification but it can
be specified to nonempty Value to
specify different names so here this is
what we are doing right now and now
let's just duplicate this and specify it
also for the second property and I will
call this one p name and let's say for
example I want to call this as just Q or
let's let's leave this one to quantity
for example okay now if I restart my
application in thebug mode and go back
to postman and try to perform
the the request let's see what will
happen if I leave the properties like
this so I'm going to click on send so I
can also here uh leave the breakpoint
and as you can see we see we have the
customer name is null the product name
is null but the quantity was correctly
mapped so the quantity was mapped
because we have this J this Json
property right here and it's it has the
same name as the Java property of the
Java field okay but for the customer
name and product name the names are
different because we specified this Json
property right here so all we need to do
I'm going to resume the program right
here and I will go back to uh
Postman and all I need to do is to
change this property to C
name and then product name or p- name
and
here also I left on purpose this name
right here with a capital N also to see
if if it's case sens positive or not so
let's try this out also we see that we
have customer name and product name as
null so yes the answer is yes
it's uh case sensitive so you need to be
really careful about that so here we
have C name with uh small letter or
small n or like a lowercase n so I will
change this one and send again and we
will see that we have correctly the
mapping to the correct values that we
sent from our rest client so here I'm
going to resume the program and also I
will show you that we have the correct
output right here so now we understand
how we can map properties with different
names than the Java objects so now let's
move on and see more interesting
Parts since Java version 14 a new type
of objects was introduced which is Java
records we can also use records to
represent our objects so like we did
with this order here it's just a class
we can create records to represent our
uh request bodies so let's go ahead and
try this one so here I will create a new
Java class and then select record in
here and let's call it order record and
within this order record all I need to
do is to create or to declare the same
properties that we have in here so I'm
going to just copy paste them so here
here I will use a shortcut to uh to
select all the properties just copy and
then I will close this one and paste
this in here so and then I need of
course commas and now I have my record
object created so here I have order uh
order record and all I need to do is
between these parentheses all I need to
do is to declare my fields and I don't
need any type of accessories like
private public okay so now we have our
order record ready let's move on and now
and create an endpoint that should
accept the order or the record as a
request body and now if I go back to my
first controller and I will again I will
duplicate this method let me make it
full screen and here I will call it uh
post order record just to uh to make the
difference and here I will call the
method post record and here in this
order uh or request body it will be
order record Okay so so then I will also
use the order. two string method so all
I need to do is just to run my
application again and check what will be
the output of this endpoint so I'm
restarting the application and as you
can see the app is up and running now if
I go back to postman and all I need to
do is to change this endpoint to order-
record and then I will click on send so
here we still we see that we have null
null null because we don't have the same
property names also the Json property
works with records so whether we can fix
it on the Java side or we just rename
this one so what I will be doing I will
duplicate this tab and then in the body
I will just use for example customer
name and also I will just rename this
one to product name so like this I don't
need to change my Java object so I will
click on send again and we see that we
have here request accepted and the
object is correctly displayed okay so
now in this case we saw that we didn't
need to create any Getters any Setters
we didn't need to do anything for our
record okay so here you see that we
created three fields and then we created
we we had to generate Getters and
Setters because we need those ones also
we saw that we have we had to override
the two string method but for the order
record we didn't need to do that let me
explain to you in the next part
what is the difference between uh poos
or plain old Java objects like the older
object right here and Records when it
comes to data transfer objects whether
to use poos or plain old Java objects or
records for data transfer objects in
Java depends on the use case and the
Java version you are using Java records
introduced as a preview feature in Java
14 and finalized in Java 16 so there are
new kind of type declaration in the Java
language a record class is shallowly IM
mutable transparent carrier to for fixed
set of values values which can be
accessed with accessors method that that
have the same names as the fields
records reduce the verbosity of java and
make it make it more suitable for data
Centric applications poos have been used
for many years in Java
for such tasks they are versatile and
work with all Java versions but require
more code to write you have to declare
fields and then you have to write or
generate Constructors Getters Setters
equals hash code and two string method
if you are using Java 16 or later and
your dto are simple carriers of data
without any additional logic records may
be a better choice they provide a
concise and convenient syntax and
automatic implementation of equals hash
code and two string as we saw in the
examples previously also you need to
note that records are final by default
and all their fields are final so they
can't be used with libraries uh that
require mutable beans such as uh some
older versions of hibernate or jpa if
you are using a Java version earlier
than Java 16 or if you need mutable
objects or if your dto need to include
logic Beyond uh just storing data pojos
may be a better choice so as always the
right choice depends on your specific
needs and
constraints now let's see how we can
pass parameter to a method so let's go
back to our first controller and let's
see how I can pass a parameter to a
specific method so here I will just
create or copy this get mapping method
right here and I will put it in the
bottom so this works for any type of uh
of methods whether get post put delete
and so on and so forth so it's it's
appliable
and correct for all of them so here
let's say for example
um path
variable this means that I want want to
pass my parameter or my variable in the
path so to pass it in the path here
let's say for example my value equals
and then let's concatenate this with the
result so then the first thing that we
need to do is in this get mapping right
here so let's say that we have um a
method called hello let's keep it as
hello and now I want to
pass my variable in the path so this
means I want to have something like this
so HTTP and then colon SL slash and then
Local Host and then the port number
slash for example hello SL alibu let's
say so this is or I want this one a
variable so it can be alibu it can be
Ali it can be Buu it can be any variable
that I want to pass so here in this case
first all I need to do is to have my my
variable so it's of type string for
example and let's say usern name just an
example and now I need to tell spring
that this username will come in the path
right here or I will receive it in the
path of my request so to do that just go
here whether you have for example SL
hello or you have nothing all all you
need to do is Slash and then curly
brackets and then for example let's say
use user Dash
name so like this spring will know that
this user- name is a path variable now
all we need to do is to link this one to
this one so here we have two cases so
the first one whether I pass the path
variable exactly within the same name
like the same naming as my variable
right here so it will be just like that
okay so spring will automatically refer
this usern name here to this username
right here so here here I will just
concatenate my username or the best case
which I recommend is to use user-name
for example and here all you need to do
is to say that this is a path variable
okay and this path variable as I
mentioned before whether we use it like
this so the path variable is always
needed you need always to specify or to
add this path variable annotation to the
field that you want to map because like
this we will mention to Spring that this
username right here this variable or
parameter that we want to receive right
here is the same that we have it here
and first we can mention the same name
so the same variable name or for example
if I have a different one so to use it
like this user- name here this path
variable also accepts a parameter it's
called Val so by default it's empty and
by default it will take the variable
name as the variable of as the variable
of the default value so here let's
specify it like that and let's say user
Dash name so the value we put in here
should be exactly the same in here so
what I recommend also try to have like
correct namings so user- name is more
readable than for example username like
this uh or for example example if you
have long complex names always
separating them with a dash is much much
easier to read so now if I restart my
application and go and test this one we
will see that we have my value equals
the value that we will pass in the
parameter so I will just restart in
debug mode and then I will go to my
Postman and in here I will just
duplicate one of these and here I have
for example hello slash and then let's
say alibu and of course it's a get
mapping so let's click on the get so we
don't have anybody so we can click on
none and now all I need to do is to
click Send so here we see that I have my
value equals alibu and if I say for
example hello or even with spaces as you
want it also able to map the value so
here this is how we can pass a variable
in the path we call it also path
variable now let's see how we can pass
request parameters now let's see how we
can pass a variable as a request param
so here I will just duplicate this
method just to keep the code and then I
will just here rename it to param
variable and I will just command this
out to keep the same URL so here I will
just remove this one so it will be just
/hello and here the URL or the final URL
will be hello and then like this and
then it will be param and _ name or like
this is this will be the Pam name equals
and then the value so here param value
and if I have a second parameter it will
be end and param name two for example
equals value two just an example okay so
now let's transform this username to a
Pam or or request param so here all I
need to do instead of using path
variable it will be a request param and
this request param whether we can keep
the request param as the this parameter
or this field right here or uh sorry
it's param not part and or here in the
same way as we did before so let's say
for example user- name okay so if I have
another parameter all I need is to do is
to duplicate it or to add another
request param so for examp example
username and here let's say last name
and here let's say for example last name
and here all I need to do is just to
display this plus user last name and
this is how it will look like now all I
need to do is restart my application and
go back to postman and send this request
again so when we started the application
we have an exception and this is
actually is going to introduce us to the
next topic that I will explain just
later on but for the moment I will just
comment out this get mapping right here
and I will explain that later on so
let's restart the application again and
make sure that everything is up and
running so here the application started
and let's go back to postman and all we
need to do is just change this one and
as I mentioned before we have user Dash
name also you can remark that here we
everything every time we Type A
parameter and the value it will be
reflected automatically in the query
params so here let's say alibu and for
example a end and then for example we
have
user- last name and then equals for
example bu Ali so this is my last name
and then let's click on send so here we
see that we have alibu and then bu Ali
as a last name exactly as we mentioned
in our code right here okay so this is
how you can and pass request params now
let's move on to the next part which is
how we should name or how we can name
our methods and URLs and how spring is
already interpreting that and how
requests are dispatched from our rest
client to the back end so now let's
understand the difference between path
variables and request params so in
Spring boot path variables and request
params are annotation used for
extracting values from the URL of an
HTTP request they are used in the spring
MVC Handler methods and here how they
differ so first when we start with the
path variable right here so this
annotation is used to extract values
from the URI path so it's typically used
in restful web services where the URL
contains a value representing some sort
of resources identifier so the annotated
parameter in the method declaration is
bound to the path variable of the same
name so as we mentioned before so here
if you have weather Spring is capable of
referencing the name that you pass right
here as a path variable with the
parameter name or the field name or when
you use path variable also like you need
to use path path variable and you can
also pass the name right here to match
the name that you have in your url from
the other hand when we use request Pam
so this annotation is used to extract
query parameters from the URL so query
parameters are typically used to carry
context information for the request and
are separated from the URI using the
exclamation mark symbol and are chained
with the end symbol so in summary path
variable is used when a value you want
is actually part of the URI while
request peram is is used when the value
is passed as a query parameter in a
spring MVC or spring boot application
the framework uses annotations to Define
which method should handle which HTTP
request so we have the controller or the
rest controller annotations are used at
the class level to indicate that an
annotated class is a controller so
Springs component scanning mechanism
detects these classes and and create
pins of them in the application context
so then we have the request mapping
annotation or as a shortcut we have the
get mapping post mapping put mapping Etc
so this one is used as the method level
Within These controller classes so this
annotation tells spring that the
annotated method should handle an HTTP
request of a certain type and for
example a post get put and so and so
forth and when when the application
starts up Spring creates a mapping
between the URLs HTTP methods and the
corresponding controller methods so this
is done by a class called request
mapping Handler mapping which scans the
controller classes and builds up a
registry of such mappings so when an
HTTP request comes in the dispatcher
seret which is the front controller in
Spring MVC consults these mappings to
determine which method should handle the
request so then the appropriate method
is then invocated and its return value
is used to generate the HTTP response
next we will see in the diagram how this
is working so now let's understand in
action and even a little bit in details
how this works so in a springut
application or in the rest API
application we have some kind of rest
clients
and it can be a mobile application
another rest API or the internet or even
Postman as a rest client and then the
first step is is sending a request so we
call this an incoming request and the
first thing or the first object that
will receive this request is the front
controller which is the dispatcher
serlet then the dispatcher serlet will
forward the the request to the Handler
mapping class the hander mapping object
and this hander mapping will consult the
mapping registry and it it will tries to
find a mapped controller and this
mapping registry as I explained before
so it will map or it has a registry of
the method plus the path plus the path
variables and types and it will refers
to a specific method of the controller
then when it finds match it will return
the controller and the meth method that
needs to be invocated and then the fifth
step it will forward this request to the
to the required controller and then we
of course have all the business logic
goes uh goes along like uh service
validation database registration
Consulting another API and so on so
forth and after that we have the
response so the response will go back to
the controller and the controller will
send back the response to the dispatcher
surve
and then it will go back to the customer
or to the client of this request and
this is how it exactly works now let's
have a quick look on this so for example
if we have a get method with the
following path SL s path SL string and
then an integer as path variable and for
example we have a get s/ ali1 so this is
correct then if we have the same path
but with a different uh verb or
different method in this case for
example a post so we have post SL
something/ A1 so this is also correct
because we have two different verbs so
that's why I mentioned here that the
concatenation of of the URL should be
unique so the concatenation or like the
composition of the URL is Method plus
path plus path variables and here I
mention type because we need to have
different types so for example here if
in case I have sth SL string SL aner and
then even if I pass a different value
spring will say that we have uh we have
an ambiguity and it it's not able to
determine which one to use so you you
really need to be careful about that and
we will see in action how this works so
this is globally how request dispatching
Works in Spring boot so now coming back
to our first controller class and let's
bring this back so here we have a get
mapping and then it it has a mapping SLO
and in the bottom if you remember we
have a get mapping so also it has the
same URL so it's /hello and here we see
that request perams they did they do not
interfere or they do not make a a method
unique so now if I start the application
I will get an exception telling me that
spring is not able to determine or to
know which is what so here the error
that we have so we have application run
failed and the exception here it says
that error creating being with name
request mapping Handler mapping so this
is the class that we spoke about defined
in the class path blah blah blah and so
on so forth and here it's mentioning
that so here in the end of this
exception we see that we have ambiguous
mapping so cannot map first controller
method and the method is com. alibu do
example. first controller which is our
class and then the method called Pam
variable so this is the method that we
are talking about and then this method
it contains two string uh parameters to
a get/ hello because there is already a
first controller Bean method com. alibo
example and the method is called say
hello which is already mapped so in this
case we see that this method even the
method name is different but spring
doesn't refer uh the method names but
first the ID or the Unicity is about the
parameter and the path so you you really
need to be careful about that and even
if you get such an example or such an
exception you now are able to understand
where this comes from before moving
forward let's first clean up our code so
first I will remove this order record I
will create one later on if we if we
need to and then I will keep um I can
keep this order we might use it but also
let's just clean clean up everything and
let's restart everything from scratch
and for this controller I will just
leave the first get method just to have
our controller up and working so here I
will just leave this get mapping and
this post mapping and now let me also
optimize the Imports and that's it so
now we have our project again clean and
we can start from scratch to introduce
and to dig deep and deep in this
part first of all we need to install all
the required softwares to in order to
correctly and easily communicate and
interact to the database for this course
we will be using post SQL as a database
management system so for you you can
whether uh install postgress SQL on
premises this means you download and
install the the software or you can use
Docker so first let me show you how you
can install go to Google and all you
need to do is to Type download postgress
SQL and then you just select because you
will have two or more links like uh the
sponsor uh sponsored links but then you
need to go to the official website which
is 3w postgressql dorg and then go to
the downloads page so here you will have
the download page for the different
operating systems like Linux Mac OS
windows and so on so forth and all you
need to do is to follow the installation
instructions for example for Mac OS here
you can download the installer certified
by the EDB and so on so forth also for
example if you want to use the postgress
do app or home brew or and so and so
forth the same for Windows just click on
the Windows link and then you have
download the installer also you can see
the versions and what are what versions
are available and so and so forth so
this is how you can install postgress
SQL on premises for your operating
system now in the next part let's see in
case you want to use Docker let me show
you how to install postgress SQL as a
Docker image or Docker container running
on your Docker machine now if you want
to use post agress SQL on Docker all you
need to do is to go to hub. do.com so
this is the dockerhub website and all
you need to do is to search for post
address okay so here we see that we have
the first image and always try to look
or to search for the docker official
image so then in order to install it so
let's say we want to use the latest
version so here we have all the the
information we need and here we see that
we have this Command right here so all
we need to do is to copy this command
and here we see that we have this
environment variable which is important
and which is mandatory in order to make
post agress SQL running correctly on
Docker so here we have post agress
password and you need to provide the
password for your P post agress SQL and
the user will be postag just like this
by default so then I will show you how
we can use this in order to connect to
our database and display all the data we
need so all you need to do just copy
this one and run it on your terminal and
also make sure you to have a Docker
desktop installed on your machine and
then you're good to go so I assume if
you have Docker and a little bit
familiar with Docker so it will not be
an a complex task to set up and install
a Docker container on your machine now
let's see how we can explore our
database so here if you have an DJ with
the ultimate version all you need to do
is to select and click on this database
otherwise you can go to view and then
you will have tool window and then you
will have database right here so just
click on it and it will display this bar
right here so then in this plus so let
me make it full screen so then on this
plus just click on you to select a new
data source so when you highlight this
new data source you will have this popup
right here and then all you need to do
is to search for the database that you
are using so in our case let's search
for post
digress and then when you click on okay
you will have this popup right here so
here all you need to do is like to
provide the name so also you can for
example let's say
test just an example so this will be the
name of of your data source and then so
if you if it's the first time that you
are using this tool you will have a link
right here telling to download the
driver so just go ahead and click click
on it but for my case since it's already
downloaded so I don't have it anymore
then the next step is here we need to
provide the information about the host
and the port so the host it's always
Local Host whether you are running your
postgress SQL on premises or on a Docker
container so it's always Local Host and
the port if you did not change it it's
by default
5432 then we need to provide the
authentication so these are the username
and password that you provided when you
installed postag SQL so for my case it's
alibu and then alibu as a username and
password and now all I need to do is to
click on test connection for the
database just leave the datab as a
database by default which is the
postgress so you don't need to changes
to change it or if you have different
ones all you need is just to select
database that you want to connect to so
here we see that we have this URL right
here and we will need this one later on
so I will show you again how we can also
retrieve it again so now all we need to
do is to click on test connection to
make sure that we are correctly or we
can correctly connect to our database so
make sure you have this succeeded
message otherwise you need to check the
information or the inputs that you
provided in here so now all I need to do
is to click apply and then okay so here
let's explore together this UI so here
this this is the the data source that we
call test and here we see that we have a
postgress SQL it's one of three and then
we have the public schema so here also
we can select all the databases that we
have or that we will create in this okay
so now for the moment we don't have any
database selected later on when we
create our first database we will be
able to select it and display it in here
okay so that's it now I will show you if
you don't have the anj ultimate version
what is the alternative to connect and
to explore the
database for the students that they
don't have the ultimate version of anti
J and you want to have a different tool
that will help you exploring any
database you want so I recommend using a
tool called Deaver so this Deaver is an
open source and free crossplatform
database for developers database
administrators and so and so forth so
all you need to do is to whether to
Google D Beaver or just go to D beaver.
and when you click on the link you will
have this interface and then you can
click on the download link but before
going to the download all you need to do
like let's first uh explore the the UI
so it looks a little bit similar to the
UI that we are using on anj so here you
have the databases that you can select
or the data sources also like U even to
connect to a database like you can
change the theme from light to dark also
uh you can see the diagrams you can see
almost everything and even to connect to
the database it's pretty much similar as
the steps that we follow together this
is uh something that I recommend for
people that they don't have the ultimate
version of antj but for me personally I
prefer having everything in one place
and in one UI so that's why I I will be
using anj for the database but for you
it should be the same exactly the same
way even if you don't have the ultimate
version to work with spring data J jpa
and data persistency in Spring boot
project all we need to do first of all
is to add the required dependency so to
add a new dependency we need to go to
our pom.xml and then let's make this one
full screen and let's add a new
dependency in here so after the spring
boot starter web here open um a new tag
and then you will have the autoc
completion dependency so I will click on
it otherwise the dependency look looks
exactly like this so it's a dependency
tag and it contains a bunch of
information so we have first of all the
group ID and the artifact ID so the
group ID for for most of the spring boot
starters it's always or. spring boot
framework. boot sorry it's or springf
framework. boot so then I will paste
this one in here and then the artifact
is the starter name and all the starters
or or the all the spring boot starters
they always start with spring Das Boot
Das starter and then the starter name
and here as you can see in this list we
already see that we have data jpa so
this is the dependency that we need for
our project so let's select this one and
then of course it will suggest the the
group ID since it's the same one we can
also double click it or even ignore that
and also don't forget to right click on
this uh on this pom.xml and here we have
you have Maven and then reload project
so this will allow and will tell Maven
to download all the dependencies and as
you can see here so now anj is
downloading all the required
dependencies including this spring boot
starter data jpa so now if we uh
integrate and add the spring boot
starter data jpa we can now run the
project and see what will happen so
let's also explore the logs together and
see what will happened so the first
thing the application is not running
because we have an issue and the issue
is fail to configure a data source or a
URL attribute is not specified and no
embedded data source could be configured
so I will explain this in the next video
so now we added the dependency and now
we can start configuring our database as
we mentioned before spring boot starters
they leverage Auto configuration
whenever it's possible and after adding
the dependency for the spring boot data
uh starter data jpa we saw that when we
started the application we had a failing
so here the mention on of the
description says failed to configure
data source and the attribute URL is not
specified this means that we need at
least to give some configur uration and
some details to this starter in order to
autoconfigure the connection to the
database and this is what we will be
doing in this phase and first of all
let's go to our application properties
file and here as I mentioned before so
let me first clean it up and as I
mentioned before and in this course I
will be using the yaml representation so
to do so you have two options whether to
remove this application. properties file
and create another one with the yaml
extension or all we can do is just
rename it using this shortcut and change
the properties to
yaml so you can use whether yaml or
yml okay so here I will click on
refractor so now my application file is
using the yaml representation so now
let's start configuring the connection
to our database and to start the
configuration first of all we start with
providing the data source configuration
so with the data source configuration is
uh located under
spring and then colum and then here you
need to be careful so this is a tab it's
not a space or it's not three spaces or
two spaces but you need to use the tab
okay so here for example if I remove it
I need to use the tabulation as you can
see in the shortcut here and then data
source and you see here that we have
this autoc completion already so it's
spring. data source and then we need to
specify the URL as mentioned in the
exception that we have so here also we
will type URL and we see here already in
the description it's jdbc URL of the
database so it's not Hikari it's not DBC
cp2 and so on so forth so you need to be
sure and to be careful choosing the
right property so here I will choose URL
and then where can I where can I get
this URL from so here we can go back to
the database and then rightclick on this
data source that we uh created before
and then click on
properties and here we will see that we
have this tab again and this window to
configure the connection and then the
URL is exactly this one so let's copy it
close this one and we can also close
this and then paste this this one here
now let me explain to you what is or
like how this URL is composed so here is
the connection type so we want to have a
jtbc connection which is Java database
connectivity and then this is the the
database type which is in our case is
postgress SQL because we want to use
postgress SQL for example if you are
using MySQL or Oracle or something like
that it will be the exactly that one and
then we we need the the host name of our
database and in our case since we are
using locally uh our database it's not a
remote one so it's local host or even
you can provide the machine or like the
remote machine uh address or IP address
and then the port by default it's this
one and if you have a different one you
can also use it and finally this is the
database name and for the database name
I will create a database later on and I
will call it demo underscore DB and this
is will be our database so in the next
next phase we will create this database
so first of all let's continue with the
configuration and then of course within
the data source we need to provide other
information which is the username and
password which are the credentials for
uh our database or for spring data jpa
to be able to connect to the database
and it will be exactly the same as we
provided here when we try to connect the
first time to our database
which is in our case uh in my case sorry
it's alibu as a username and alibu as a
password so here I will also provide
this information so use uh choose
username and again be careful it's not
Hikari it should be ex directly data
source. username and in this case it
will be alibu and then
password and also choose the second one
not hiar okay and it will be also alibu
and then we need to tell uh spring data
GPA which driver to use in order to
connect to the database because as you
know to connect to any database we need
a driver so here if I choose also driver
class name it is under spring.
datasource driver class name and here I
need to provide the class name for our
postgress SQL and in this one we just
need another dependency to add to our
configuration so let's let's go ahead
and add it to add the postgress SQL
driver we need to go again to our
pom.xml file and then we need to add
another dependency so here I will click
and add dependency and then the
dependency it has an artifact ID which
is called postgress SQL or postgre SQL
and then the group ID is org. postgre
SQL also we can add a scope which is in
our case it should be runtime so here
this is the scope of this uh of this
dependency so it's available on the
runtime and then I click on this popup
right here or as I mentioned before just
right click and then Maven and then
reload project to reload and download
all the necessary dependencies so now we
have our postag gr SQL driver available
let's go back and continue with our
database
configuration so now if you go back to
our application. yaml and in this driver
class name name if I just type command
uh space and here we will see that
automatically anj will propose driver
coming from org. postre SQL package as a
driver class name otherwise you can just
manually type orpos SQL do driver and
then you will have the driver and in
case you don't include or you forgot to
include the driver it will be
highlighted as uh as a nonf found or a
class notfound exception or error right
here so don't worry about that in case
you forgot to add it uh anj will
highlight it automatically so now the
first part is ready and now I can start
the application and see what will happen
so here let's start the application and
check if spring will be able to locate
and start the application so yes the
first part is done so let's check right
here and here only thing that we have
the database demod DB does not exist so
it was able ble to locate the database
using the the username and password but
it didn't find any database called
demoore DB also I want to show you
something for example if I change the
username and the password or just
username or password to provide wrong
credentials and restart the application
we will see a different exception so
here it will say that enable to
authenticate so here it says password
authentication failed for user alibu DDD
so even if I fix the username and
provide a wrong password we will see
again the same exception uh fatal
authentication as you can see right here
but this time it will say that password
authentication failed for the user alibu
so here like we know now we understand
that spring is able to connect to the
database now let's move on and create
our database and restart the
application so in this step let's let's
go ahead and create our database so in
here click on database and on your data
source that we created we called it test
right click and then we have new and
then so let me just make it wider right
here so again right click and then new
and you see here database so select
database and then let's provide the
database name as we mentioned before
demo andore DB and even you will see the
SQL uh query command that it will be
executed which is create database and
then the database name so click click
okay so here we see that we have this
demod DB but it says here that no schema
selected so all we need to do is to
click on zero of three right here and
select the public schema which will hold
our database later on and the list of
the tables that we have so in here we
have empty schema for now and we don't
have any tables so let's move on and
check that so now let's create our first
first Java class which will represent a
table in our database so I will explain
everything later on but first let's
start with creating a new class and
let's call it student for example and in
this case so here the student will hold
the information of our student so let's
say first our student has a private
integer ID so this will be the
identifier or the unique identifier of
our student also it has a string first
name and then a private string last name
so let me make this one uh full screen
and string last
name and then let's say also our student
has a private string email and finally a
private string H uh sorry the AG should
be an
INT so here this is the representation
of our student so again let's go ahead
and generate create some Getters and
Setters because as we mentioned before
we need Getters and Setters let's click
okay and then we need for for example a
Constructor if you want to so let's
create a
Constructor and for this Constructor you
let's use all the parameters except the
ID so this is how we can construct a
student uh using all the fields that we
have right here also you can just uh
ignore that and we can use Setters later
on to create our user so now we have our
object student or student class ready
let's move on and let's see how we can
transform this student class to an
entity which will be persistent entity
into our
database before transforming our class
to an entity let's first Define what is
an entity so in Spring data jpa the term
entity refers to a Java object that is
meant to be persisted in a relational
database using using the jpa or AKA Java
persistence API so any entity represents
a table in a database and each instance
of an entity represents a row in a table
so the entity Fields represent the
column of the table and the state of an
entity represents the data in a row so
to map an object to a database with the
jpa we need to annotate with enti and
the class must have a no arcs
Constructor which can be public or
protect protected also it should contain
an identifier ID and it's a best
practice also to include the table
annotation to specify the table name if
the table is not specified so the table
name default to the class name so spring
data jpa uses these entity classes to
generate SQL queries and to convert the
results of those queries back into
objects that you can use in your Java
code so the actual database interaction
is performed by the underlying jpa
implementation such hibernate in our
case so in the next next phase let's
move on and transform our student Java
class to an
entity so as mentioned in the previous
video we need within uh spring data GPA
and if you want to transform a Java
class to uh to an entity first of all we
need to have an empty Constructor or a
default Constructor with no arcs so
let's go ahead and generate that one so
here let's generate a Constructor and to
generate a an empty Constructor just
click or select the class name right
here and then click okay so now we have
our default Constructor let's move on
and transform this student class or
student Java class to an entity so as we
mentioned and explained before all we
need to do is first of all to have the
entity annotation on the top or on the
class level and here be careful the
entity is coming or comes from the
Jakarta persistence if you are using the
spring uh version three also if you are
using uh a lower version it will be Java
x. persistence so here let's select this
one and here directly we see that anj is
highlighting the class name and if I
highlight and check what is the error so
it see it says that the persistent
entities to student should have a
primary key so we need to specify a
primary key every time you create an
entity and to provide a primary key it's
so easy just go ahead and choose what is
the primary key of your class or of your
entity and add the ID annotation it's
all also coming from the jackart
persistence package and now we have our
student entity so now let's go ahead and
see if we are able to uh generate or to
manipulate or to start the application
Within These small changes so if I click
here to start the application we see
that the application is up and running
and also let's see if we have any um any
logs that we can use uh also we see here
like starting the application and we
also see that we have some uh some
annotations or some logs from hibernate
so here it's hibernate version uh
6.1.7 and also it's using the dialect
post SQL dialect and the JTA platform
implementation which is the no JTA
platform and so and so forth so here the
application is up and running and if I
go to my database and I try to refresh
this one and check the public schema
also if I refreshed again I don't see
anything spring and jpa and the the
hibernate implementation of jpa they
provide a tool and config configuration
to autocreate and to autogenerate the
tables within the database so in the
next part let's go ahead and see how we
can tell spring and tell spring data at
jpa to be specific to generate or to
autogenerate our
database so now to to define the extra
properties first I will stop the
application and then I will go back to
our application. yaml let me make it
full screen
and then we need to provide few
properties so here within the properties
we see here that we have spring. dat
Source now at the same level of data
source it will be spring and then jpa
and then we can specify some information
so here within jpa we have hibernate and
then within hibernate we have this
information or this property which is
called ddl Auto so this ddl AO or like
this mode it stands like the DL stands
for data definition language and this is
the behavior or like what we want
exactly hibernate to do when we start
the application so here we have uh five
options first we have create this means
that it will create the schema and
Destroy previous data so you need to be
careful when choosing this option this
means that every time you start the
application hibernate will create a new
schema and destroy the previous data so
you it's okay on on the development
phase or like on the early phases of uh
your application development since you
don't have the schema fully implemented
you can keep it as create otherwise I
would say you keep it to uh validate or
to update so the next option is create
drop so create a drop it will create
this schema and then at the end of the
session it will destroy the schema so it
will remove the whole database so it's
like you don't have any database at all
so we have also none so this mean that
we want to disable this ddl Auto and
this is valid uh for example in
production mode if we want to use um a
database migration tool like Flyway uh
or liquid base to manage our database we
have update so it will update the schema
if necessary so if we don't have a
schema it will create it and every time
we make changes it will try to update
the schema if there is CH changes and
the final one is validate so it will
validate the schema and it will make no
changes to the database so assuming that
we are managing our database using a
database migration tool like Flyway for
example and this option validate it will
try to compare the existing database to
the representation or to the Java
representation in our code and it will
validate this one so here let's go ahead
and choose create since we still in
development mode also we have other
properties under jpa so for example we
can also show the SQL queries so here
when I choose jpa do show sqlquery uh
show SQL here we see that by default
it's false and then we can change it to
true so this means when we run uh the
application and we try to execute any
query or any method that will interact
with the database we will see the we
will see the query displayed in the
console then under jpa we have also
properties and within these properties
we have hibernate and format SQL so if
we have an SQL query if we don't add
this uh format option it will be
displayed as a full line otherwise we
can format this SQL query and it will be
nicely displayed so the property for
this one is uh spring jpa properties and
then
hibernate and then we have format SQL so
this format SQL all we need to do is to
set it to True also we we have another
property which is available again under
jpa so it's spring. jpa and here we have
database so it's the second option so
here this is the target database to
operate on so it it's autodetected by
default if you want to so hibernate will
try or jpa will try to autod detect what
is the database that we are using and
also we can see it here in the logs so
as mentioned here before so here as we
can see using the dialect hibernate
dialect and then post agress SQL direct
so I will also copy this one and then we
can even provide provide it manually so
we can tell uh jpa that we are using
this database to be more specific and
more precise also we have another option
which is called database platform so the
database platform uh it's also so this
property specifies the hibernate dialect
for the Target database so the dialect
defines the specific SQL syntax and
features supported by the database in
this case we will use this one just the
one I just copied from uh from the
console and to set it to indicate that
the postgress SQL dialect should be used
so now we have everything and all the
properties that we need for jpa now
let's go back again and restart our
application and see what will happened
so just click on start again and let's
check what will happen within our table
so first of all if we check the log
right here so we see that since we used
this show SQL true we see that we have
the SQL query right here so this is the
SQL query for creating the student table
also we have this format SQL true so we
have a formatted query all right so now
if I go back and check my database in
here so select public or the schema or
even the database right here and click
on refresh and here if we expand we see
that we have one table right here so we
have a table student and the table
student contains all the information or
all the properties that we provided ID
first name last name email and age so
the age is of type integer same for the
ID and we have email first name last
name of type varar which is the the SQL
representation for the string type so
now let's move on and see how we can
again play more and more with the
hibernate on the or the annotations for
our
entity what if we want to change the
table name so by default this entity
annotation it will use the class name as
a table name but what if we want to have
a different one so let's say for example
I want to call my table students not
just student so in this case we can use
the table annotation and it always comes
from the Jakarta persistence package and
and here we can specify the property
equals name and let's have a look on
this annotation so here it says that
specifies the primary T table of
annotated entity so we need to have the
entity annotation so additional tables
may be specified using secondary table
and so on so forth so here if no table
annotation is specified for an entity
class the default value applies so here
for example we have entity and we have
the name cast for example for cast
customer and the schema we can also
specify the schema so by default if we
don't add this table annotation it will
take or the entity annotation will use
the entity name or the class name as a
table name so here let's say for example
T and score student just to T to say
table student and if I rerun the
application we will see that the
database will change and the table will
be again changed so here we see that
create table even in this SQL query
create table T underscore student so
here if I refresh my tables we see that
we have a table now it's named the
student and also we have the same
columns ID age email and so and so forth
so this is the use case of this table
annotation we also can have extra
control on the different fields so for
example if I want to change a column
name there is an annotation called
column
and this colon annotation has a bunch of
properties so we have name and here the
name of the colum so defaults is the
property of the field name we have
unique notable insertable updatable
colum definition table length and so and
so forth so here we can specify many
properties for the specified colum so
for example let's start by changing the
name so for example for this first name
I wanted to have ccore F name just C to
say colon and then F name again like we
can use the same annotation for the
other fields but let's just try on on
only one so here if I restart my
application and check again the database
here even in the SQL query we see that
we have again CF name so if I refresh my
table right
here we see that we have the first name
is now called ccore f name as we
mentioned in here so now we have our
first name named to ccore F name also we
have other properties that we can
specify so in case for example I want to
have extra or like I want to have some
Precision or size so I can also use the
length so as you can see here by default
so let me make it full screen and as you
can see the length of uh of a string by
default is 225 so h I bernate will
detect that automatically but I can
specify for example the length of my
first name should be exactly 20
characters and if I restart my
application just to recreate everything
from scratch we see that here the CF
name or the column first name it's a
type varar and now the the length is 20
instead of 225 you can increase it or
you can even decrease it to have for
example if you have some specific cases
where you need for some spe specific
field or colum to have uh a specific
length so you you can use this property
length to specify or to provide more
Precision to that so here if I if I
refresh my
table and in the columns and again if I
go to C name we see that the CF name is
of type varar and the length of this
varar is 20 characters so now let's say
let's see if we want to have a unique uh
um entry for specific column so for
example for this email we know that
emails should be unique per user or per
student or per person so again I can use
the colum annotation in here at this
level and here there is a property
called unique and the unique is by
default equals false this means that we
can have duplications for this specific
colum but if we if we uh change it to
Unique true and if I restart the
application
and let's first check the logs we see
that we have here the email is of type
varar 225 and after that we see that we
have alter table if exists T student and
add constraint this is the constraint
name it's UK and this is generated uh
value and we have this unique constraint
for the column email and again if I
refresh my table right here let's see
what are the changes that we
have so we see that we have an email
right here and then we have the keys so
first we have the T student P key p
means primary and key it's uh for key
and then we have the unique constraint
applied on the email column right here
so this is what exactly the result of
this SQL query we can also add some
extra uh some
extra properties and constru brains
let's say for example I have right here
private string uh let's say just some
colum just like that and now I will use
the colum annotation and I can specify
if this some colon is insertable or
updatable let's say for example let's
make it updatable true so by default any
column is updatable true by default and
then I can make it updatable false and
we we have a specific or we might have a
specific use case for uh a field that
should not be updatable which is for
example the creation date so we can have
a creation date for any field or for uh
for our entry in the database and we
want we don't want this creation date
field to be updatable every time so we
can just make it updatable to false and
also we have another property which is
insertable and by default it's true we
can make this insertable false so this
means that we cannot create or we cannot
insert value for this specific field so
now let's stick with this updatable and
here let's again restart the application
and we will see that we might have
another constraint so here if I refresh
my table and for the T student we see
that we have Sam column which is a varar
and then we don't have any keys but
hibernate will manage this automatically
and will at and it will make this field
called Sam colon not
updatable in this part we will see how
we can play a bit more with the IDS so
when it comes to the identifiers of
tables and especially when we use uh the
type or the the the digit uh digits type
which is integer uh float double um also
long and so on so forth we can tell
spring and hibernate to automatically
generate the ID for us and to do that we
can use an annotation annotation called
generated value and this generated value
again it's from Jakarta persistence API
and let's have a look on this annotation
so if I go to the definition of this
generated value and have a look on the
on the documentation for it so it says
provides for the specification of
generation strategies for the values of
primary keys so the condition here it
works only with primary keys so the
gener ated value annotation may be
applied to a primary key property or
field of an entity of maid super class
in conjunction with the ID annotation so
we we need to have the generated value
always within the ID annotation so the
use of the generated value annotation is
only required to be supported for the
simple primary Keys use of the generated
value annotation is not supported for D
derived primary keys so we cannot use um
the generated value annotation on
derived primary keys for example like
strings or composed keys so here also
there is an important property which is
the generation type so the generation
type as you can see it's optional and it
has a default value which is Auto and
then the primary key generation strategy
that the persistence provider must use
to generate the annotated entity primary
key and then let's have a look on the
different types of the generation type
so here if we go to the to the enam
generation type we see that first we
have table so the table indicates that
the persistence provider must assign
primary keys for the entity using an
underlying databased table to ensure
uniqueness so this means that hibernate
will create a table within our schema
and it will use that table to store the
the IDS of the entities that we want to
use again we have another property which
is sequence so this indicates indicates
that the persistence provider must
assign primary keys for the entity using
database sequence so database sequence
it's something related to a database and
it's like somehow like a table where we
have a sequence of
values then we have the identity so this
means that indicates that the
persistence provider must assign primary
keys for an entity using data database
identity column so the database or like
the provider will use a database
identity column to
autogenerate the IDS also we have
another property which is called uu ID
and The UU ID is for Unique uh Universal
unique identifier and this indicates
that the persistent provider must assign
primary keys for the entity by
generating an RFC of type 4122 which is
a unique Universal unique identifier and
finally we have this one this AO which
is always uh recommended and this
indicates that the persistence provider
should pick an appropriate strategy for
the particular database so this means
that when we when we set it to AO which
is the default one hibernate will check
within the within the database provider
or the persistence provider and in our
case for example it's postgress SQL and
it will choose the appropriate and the
best uh generation strategy for our
database and here there is something
which is really important so the
autogeneration strategy may expect a
database resource to exist or it may
attempt to create one so it will attempt
to create the resource for example let's
say it uses a sequence so the auto uh
the auto strategy will try or will
attempt to create this resource if
possible if not it will raise an
exception telling that it's not able to
create this one and for example I can
give you an example from my my previous
experience so Oracle databases they work
with sequences and you need to manually
create the sequence in order to use it
as a generation type so now let's go
back to our code and let's restart the
application and see if we have any
changes so first let's check the logs
and as you can see first we have this
hibernate uh query that was executed
which is create sequence T student
sequence starts with one and increment
by 50 so here hibernate created a
sequence called it tore student uncore
sequence or seek to uh and it starts
from one and the incrementation is done
by 50 and then we have the table and we
have the unique constraints that we that
we added so now if I refresh again my
tables we see that we have the student
and now we have one sequence packet or a
folder that was created if I expand it
we see that we have a t student sequence
which is of type big int and this is
just a sequence as as you can see in the
icon right here so now let's hit with
this with the annotations that we can
use within our entities now let's move
on and see how we can persist data into
the database and how we can perform uh
queries like inserting reading updating
deleting and so and so forth
so when it comes to data persistence and
to persist data in uh in a database
spring provides us with a list of
interfaces that we can use to simplify
the life of developers so spring
provides an interface called repository
and this interface is extended by
multiple other interfaces and we have
here for example we have this repository
and we have the crude repository and
list crude repository and also on the
left hand side we have the paging and
sorting repository and list paging and
sorting repository and all of them like
the the basic one or like the first one
is jpa repository which extends all
these interfaces so if you extend or if
you use the jpa interface or the jpa
repository interface you have access to
all these interfaces right here and all
we need to do in order to to access or
to have a data access layer in our
application is to create an interface
and extend one of these five interfaces
that we see right here which is whether
jpa repository list crude list paging
and sorting crude repository or paging
and sorting repository so each one of
them comes with a list of methods
predefined methods that we can use to
operate or to to execute some SQL
queries so the jpa Repository uh is
designed to simplify the development of
access layer code by abstracting away
the common data persistent operations so
it provides methods such as save find
one find all delete and more allowing
you to interact with underlying database
without writing explicit SQL queries so
this is the important thing and the
important part of using jpa repositories
or using the repositories from the
spring data jpa and the jpa repository
interface comes with some features first
we have the crow operations Crow stands
for create read update and delete which
inherit inherits from the basic crud
operations from these interfaces we see
right here enabling you to perform
standard database operations like saving
entities retrieving entities by ID
deleting and finding all entities and so
and so forth also so we have query
methods so jpa repository supports the
creation of query methods based on
method names by following name and
Convention you can Define method
signature that automatically generate
the appropriate SQL queries for example
if we want to have a method F find uh by
first name and we provide the string
first name as a parameter or find all by
age uh greater than in age and so and so
forth both so this can be implemented
without writing explicit queries and we
will see later on by example how we can
implement this also we have the derivate
query methods so along with query method
based on method names jpa repository
supports the creation of more complex
queries using derivate query methods so
this method derive the query based on
the structure of the method signature
and the names of the parameters so this
allows you to Define queries with
conditions and join multiple entities
together we can also have a custom query
definition so in addition to the query
method the jpa repository allows you to
Define custom queries using the at query
annotation or the query annotation and
you can write J jpql which is the Java
persistence query language or native SQL
queries and map the query result to The
Entity or a custom dto that you want to
return
so by utilizing this the features
provided by the jpa repository you can
significantly reduce the amount of
boilerplate code required for data
access operations and Leverage The Power
of query derivation and handle p
pagination and sorting with ease in your
spring data jpa based application so now
let's move on and see in action how we
can create uh repositories and how we
can generate methods and how we can even
persist data to create a repository all
we need to do is to create a new
interface so select new and then Java
class and select interface right here
and let's call our interface student
repository so in this way we are
creating a new interface and to
transform this student repository
interface to jpa repository all we need
to do is to extend the jpa repository
and the J APA repository is a generic uh
interface and let's see here click
always on download source to see
everything and all the source code and
here we see that we have a t and ID so
the T represents the entity and the ID
represents the identifier of our entity
so let's go back here and provide these
types so here this is a jpa repository
for our student entity okay so this is
like from the name but here like our
goal is to create a repository for our
student object so select the student
here and then comma and the type of the
ID so in our case the type of our unique
ID of this student table is integer as
you as you can see here so we have Inger
ID annotated with the ID annotation so
this is how you can identify or you can
check the ID and that's it that's pretty
much it and here even you don't need to
add any repository or any component
annotation because spring data jpa will
automatically understand that this is a
repository and it will transform this uh
this interface to to a managed be or to
a component or to a repository all these
names are valid for the jpa repository
so now let's move on and use this jpa
repository and try to persist some data
now in order to use this student
Repository all we need to do is to
inject it somewhere in some class or in
another spring bean and let's inject it
in this first controller so I will make
it full screen and here I can also even
clean up this one and here I will create
a private final student repository and
let's call it repository or even student
repository and then we need to generate
of course a Constructor
parameter and here we see that we will
use the Constructor injection so as I
mentioned before we no longer need to
use The autowired annotation so here we
have our repository available and now we
can just use it so here in in this post
method so let's say slash students and
like to follow the namings so now we
have our first controller and I want to
use the post for the Post mapping SL
student and here as a request body let's
change this one to type student okay so
here we have the student and I will just
rename this one to student so then it
will not return a string but I wanted to
return the student object instead so
here it will return the student so I we
will go back to this later on and here
all we need to do after receiving the
student object all we need to do is to
call the repository instance that we
created and then we have a method called
save save so the save it takes an S of
type entity so here if I pass student so
this means that the student will be
persisted and as you can see this method
it will it takes the entity as parameter
and it will return the same entity of
the saved one so all I all I need to do
is to just return repository Dove and
now let's start the application and go
to postman and start this and test this
method so this is our Postman interface
again let's change the url to
students and then we have a body and for
the body it will be exactly the same way
as the student object right here so we
need the first name last name email and
age so first name last name email and
age and I will copy these ones and then
I will just create an object of type
student so let me remove this and then
adding The Columns everywhere so here
and also for the AG and here for the
first name let's say Ali and for the
last name let's say bu Ali and for the
email so this is my email if you want to
get in touch with me so it's contact at
alibu coding.com and age let's say I'm
34 years old I'm getting old but it's
totally fine so here we have our Json
representation for the student object
now if I click on send let's see what
will happen so first we see that we have
this 200 okay and we persisted our
object and now we have the ID equals 1
so if I go back to my
database click on here let's refresh the
tables and if I open this student we see
that we have an object that that got
persisted in the database so here we
still have the is uh some colum colum
that we added but we can ignore it for
the moment and here we see that we have
the object or the user or the student
that we just inserted so let's go ahead
and insert another one and see the
changes so here let's
say John John
do and here for example let's say John
at alibu coding.com and let's leave the
age as it was and hit enter so so here
we see that we have a different ID and
we return the saved object so if I go
back to my
database and refresh so here you have
the icon to refresh or to to reload the
page and now we see that we have this
user again inserted so here let's just
check again um our entity and we see
that the email is unique okay so now if
I go back to
postman and try to insert the same
object click on send and we see that we
have a 500 internal server error so if I
go back to anj and inspect this one
let's see the type of the exception so
here we see that we have an error
duplicate key value violates unique
constraint for this constraint that we
created before so just to remind you
this is the constraint that we created
for the Unicity of the email so it's
this one and now we see the except that
we have a violation and even we have
more details it says that the key email
like the field called email and the
value John alibu coding.com already
exists so hibernate is performing all
the checks and checking that the email
should be unique within our database so
this is how we can persist an entity now
let's see how we can update an entity
and how we can delete fetch all and the
operations that we can use now let's
Implement another method that will
return a student by its ID so here we
have student and then I will pass as a
path variable and let's say
student- ID and here it will return just
a single student so let's change the
type and here find student by ID so this
will be the method name and of course we
need our path variable and here let's
call it student - ID and then tiger ID
so here we have our method ready and now
all we need to do is to use the method
find by ID and here this find by ID it
will return an optional of type student
so here let's pass first the ID and then
let's say or
else for example null okay so if we
don't find the student with a specified
ID it will return a null object or let's
say even some new student okay like an
empty student object so let's restart
the application and let's go to our
Postman and try to test this endpoint so
first let's insert uh an object or like
few a few elements so this one and this
one and we have three elements so here
if I test again the/ student we see that
we are returning three elements with the
specified uh object and values that we
provided and now if I say SL students
SL1 so it should return this first
object and if I click on send so we see
that we have only one object and here
before it was a list so just to make
sure and as you cane can see it's a list
in here and it's a list of objects so
now SL students
SL1 and if I try to find an object that
does not exist so for example a student
with the ID number 10 which which we
don't have in the database we see that
we have an empty object with n values
and this because when we retrieved the
the student we say or else new student
or we can just say or else null or
whatever you want so this is how we can
retrieve and this is the the method find
by ID that we can use to retrieve an
object by its ID so now in the next part
let's see how we can create a custom
query and for example find a student by
the first name now let's see how we can
retrieve the list of students that are
persisted in the database so I will
duplicate first of all this method and
instead of post I will just use get so
here it will be get mapping and I will
use the same URL students and here like
I will say find all students and here
instead of returning a single student I
need to return a list of students so
here I will use list as a return type
and then I will just give it the type
student so here list of students and
here we don't have any request body
since it's a get and we don't have any
parameters and now instead of saving we
have a method called find all so this
find all method will return all the
students that we have in the database so
let's restart the application and go to
our Postman and test this one so
opening Postman first I need to persist
few data so this is the first one second
one and let's say this is the third one
and again I will duplicate this tab and
here I will change this one to get and I
don't have a body and all I need to do
is to click on send so here we see that
we have this 200
okay and we see that we are fetching and
displaying all the students or all the
objects that we have persisted in the in
the database so it's Ali B Ali and we
see that the email is changing and this
is contact one and contact 31 the one
that we just inserted so this is how we
can retrieve data from the database and
as you can see here I did not create any
SQL query for that but all these methods
they come from the spring data jpa or
from the jpa repository that we extended
right here so if I open this one we see
that we have a bunch of method right
here and even this find all it comes
from other uh from other interfaces so
here we have the save all we have this
find all method that we just used so
click on download source and this is all
the methods that are available so let's
see more and more methods and try to
perform the crow operation so then so
here we have the create and you have the
read here so let's check the delete op
operation and the update operation so
again let's duplicate this method right
here and here it will be SL student SL
search for example and then let's say
student name okay so here it will return
also a list of students so I'll just
copy this one and replace it in here so
here we will say find students by first
name or by name it's also okay and here
we need to stent name instead of student
ID and the type should be of type string
but here as we can see we don't have any
method that will return uh student by
name or by first name so what we need to
do we need to go to our student
repository right here and let me show
you how we can create a method that can
filter or behind that hibernate will
generate the query for for us so what we
want to do is searching for the list of
students so first we need to provide the
type which is list and the object which
is our entity or a d or any other object
that hibernate can be able to map it so
we have list of student and then our
method should start find all by and find
all because we want to have a list if
for example we just we want to return
only a single student we can use find by
instead okay but in this case we want to
use find all by and then after the find
all by all I need to do is to specify
the colon name like the Java colon name
like from the class that I want to use
it as a filter so for example here I
want to use first name so you don't use
the ccore F name but you use the Java
field of the Java class okay so I want
to use the first name as my filter so
all you need to do is to
use a capital letter for the first uh
for the field name so as you can see
here already anate so this this uh is
part of the ultimate version this Auto
completion and as you can see hibernate
uh sorry anj is already suggesting first
name as a filter okay so now I say first
name and also I can add like Okay so
this means that the first name so
contains this value or I can say
containing so containing this means any
string I pass it should be part of the
first name so for example if I have a
first name Ali if I pass just L it
should return and filter all the
students containing this L letter so
here all I need to do is to pass my
string P so here I P me uh means
parameter so I'm um on on purpose I
mentioned P because I don't you don't
need to specify first name for example
so because the type what really matter
so the type of the first name here
should match the type of the parameter
that you are passing right here okay so
now we have our method let's go back to
our controller and call this method to
return the list of students so here we
have find all by and here we have first
name containing and then when we start
the application and when we execute the
query we will see what is the output of
this query so here instead of this
string ID let me just change it to name
and here pass name as a parameter now if
I restart the application and let's go
back to postman so here I can clean the
console so we can see the query that
will get executed I will go back to
postman first I need to insert some data
so this is the first one and let's call
the second one John and let's let's call
uh C for
example and now let's go back in here
and now instead of passing this um this
ID I can pass for example SL Ali okay
and if I click on send we see that first
we have a bad request let's check why we
have that so we have a bad request
because in enj here when we created this
method we added SL search and with
within the ad and the object or the
value Ali so spring is trying to map the
Ali to an integer and as we can see here
let's check the exception and it will
say that it was not able to map or to
convert the value Ali to an integer ID
so now let's go back to uh to our enj
and also I need to insert some other uh
data and here let's click on send and
then also John for example and let's
change this and click on send again
because I guess I uh it was it was not
inserted before so now if I go back to/
students SL search and now if I pass Ali
as a parameter and click on send so we
see that we have a list containing this
object which is Ali B Ali and so on and
so forth now let's go back to the
console and see the query that was
generated so here we have select and we
have the fields from from student where
the CF name so hibernate was
automatically capable of transforming
this first name to use the colon called
ccore f name and here we have like and
then so this is the value because it's
an interrogation Mark and then escape
the the back slashes so this for example
in case we pass a back slash as a value
so this is the query that was generated
behind and all this came from just this
method that we created right here so we
just told spring data jpa to search the
list of students by first name
containing so any first name or like the
first name contains the a portion of the
string that we pass right here all right
so now you understand how we can create
queries now let's move on and see how we
can delete objects for example now let's
create another method to delete student
so here I will use a delete mapping and
then for the delete for the delete
mapping it will be/ students slash and
then I will need the student ID so it
will be student- ID and then I will have
a public void and then I will call it
delete so here of course we need a path
variable and then let's call it student
ID as you mentioned before and then I
will need the tiger ID and all we need
to do is to call our
repository. delete and then we have a
method to delete whether to pass the
whole student entity or just delete by
ID so the delete by ID we can just pass
the ID and here we can also use as
explained before the response status
annotation and here for example let's
say accepted or or just Okay so for
example let's say HTTP status and of
course we need to import the HTTP status
so now let's restart the application and
let's go ahead and try deleting student
by the ID so now the application is up
and running again so let's go back to
postman and of course I need to insert
some
students and I will insert another one
so here we have two students Also let's
check in the database so let's open the
student table and we see here that we
have two students created and now if I
try to delete the second one or the
student with the ID number two let's see
what will happen so now let's duplicate
this tab so duplicate Tab and then
instead of post I want to send a delete
and then SL student
slash2 and all I need is to do is to
click Send and we see that we have 200
okay and also let's go back and check in
the database so if refresh we see that
the student with the ID number two was
successfully deleted all right so we
performed all the crud operations we saw
how to filter we saw how to create um a
custom method using the jpa repository
and now let's see how we can
perform and add relationships to our
entity so here we have our student
entity and let's try to create other
entities which will have some relation
and mapping between
them so in order to uh create mappings
and relationships with different
entities first we need to create the
entities that we want to uh to create
the mapping for so here let's assume
that a student is part of a school or
studies in a school and a student has a
profile so first let's start with
creating uh The Entity school so I will
create an entity called school and then
of course we need the entity annotation
so we don't need the table because we
can leave it just to school and then we
need the ID so this is will be the
identifier and then generated value and
let's say private integer ID so this
will be the ID of the school and simply
let's say this school has a string
school name or just a name okay so this
is our school entity and of course we
need to generate Getters and Setters so
let's select both of them and generate
Getters and setters for the ID and the
name and also let's generate a
Constructor and this Constructor we can
say a Constructor using just the name
and Another Empty Constructor because if
you remember we need that so here we
have our school entity ready now let's
move on and create the profile entity
and then we will start implementing
relationships now let's create the other
entity which is will be the student
profile so the student profile again we
need the entity annotation and we need
also the ID so this will be the
identifier and it will be a generated
value managed by hibernate and then we
will need a private aner ID and then
let's say the the student has a private
string bio so this will be like just a
bio or description for the student we
can also add many other fields for the
profile but for now let's just keep it
simple and let's generate now Getters
and Setters so let's select both of them
and then again let's generate a
Constructor let's generate an empty one
and let's also generate a Constructor
using the bio so we can just create or
in instantiate user uh student profile
just using the bio so now we have our
student profile and stent School ready
to use let's move on and understand the
class diagram that we need to implement
and the relationships between these
three entities this is how our class
diagram looks like so as mentioned
before we have one student and a student
has a student profile so the student has
only one profile so that's why we see a
onetoone relationship between the
student and the student profile and then
a student studies in one school so here
that's that's why we have a relation
from the student to the school which is
mapped with the one right here and then
the school has many students so one
school has zero or many students so this
means that we can have a school but
without any students yet but what if we
have a student the student should be
assigned to one school so this is how
our class diagram looks like now let's
start implementing the relationship
between these three entities and we will
start with student and student profile
which will be one to one
relationship now let's create the first
mapping one to one between the student
and the student profile so I will move
this to the right so I'm going to split
it and move it to the right to have both
classes open at the same time so first
what we need to do so let me first
remove this column because we don't need
it anymore and first thing we need to do
is to create an object or a field of
type student profile inside this student
stent class so let's go ahead
private student profile and let's call
it student profile okay now in the from
the other side we need also to create an
object or a field of type student in the
student profile but we will come back to
this just in a few moments so now to
declare and to tell hibernate that this
is a onetoone uh relationship between
the student and the student profile or
we need to do is to add the one to one
annotation and this one: one annotation
comes with some properties first we need
the property mapped by and this mapped
by should reference to the field of type
student in the student profile so let's
say here student and then I will explain
later on and that's it so here we have
one: one and also we can add the cascad
type A cascad type. all so this means
this cascading type this this means if I
perform or if I delete a student this
means automatically I will remove the
student profile at the same time without
even performing a delete operation on
the student profile itself now from the
other hand on the student profile I need
to create a field of type student so
here let's call it student and here be
careful this student should be exactly
the same as the object mapped by because
the mapped by will look for an object of
type student called student so for
example just an example if I say St and
I start the application so the
application will fail because here in
the student profile we don't have any
attribute or field called student so you
need to be careful about this one and
then we need to add one to one
annotation also from this side and now
let's define where to add the join
column so this means because you know in
class diagrams where when we have a
relationship we need to have a foreign
key in one of the tables so here our
primary entity is student and then we
have the student profile so we can
create a student but we can Skip and
update the student profile later on so
this means that the student is the
primary entity and the student profile
is the secondary one so in this case we
need to add the join colum annotation so
here we have a join colum so this means
that we want to declare a join column
let's give it a name for example student
andore
ID so this means that when we start the
application we will have an extra field
in the student profile class or table
having the name student ID so let's
start the application and check that all
right so the application is up and
running let's check the logs first of
all so here we have first we are
creating the school the table school so
this we will come back to this one later
on and then we have a student profile
and after that we have the table called
the student so here for the student we
have the primary key which is the ID and
in here we have the student profile and
the student profile we see that
hibernate created a new field called
student ID and it chose an integer as
the type so the integer it chose it from
the ID or the ID type of our student
class so now let's go back let's go
ahead and check the tables right here so
if I refresh we see that we have three
tables so here if I open the student
profile we see that we have one foreign
key and if I expand this one we see that
we have this foreign key with these
constraints so FK for foreign key and
this is the key or the ID for this
foreign key and this one it's the field
student uncore ID which is the field
that we defined already and it refers
the table called tore student with the
ID or the field or the primary key
called ID so in this way we performed or
recreated our first relationship one to
one between student and student profile
so now let's go ahead and create the
mapping between the student and the
school all right now let's move on and
create the relationship between the
school and the student so we said that
the relationship between the school and
the student student is one too many this
means that the school has many students
and students can study in one school so
let's start from the school side here we
need to create first of all a list of
students so because here we have one
school can figure out many times in one
in multiple students so this means like
this the school has multiple students so
I will create a list of students let's
call it students and then we need to add
The annotation one to many so this means
one school can figure out or can be uh
or can exist in many students lines or
many students Row in the students table
that's how or that's why that's how we
can determine what is the type or which
annotation to use so then within the one
to many we need an the attribute Mapp it
by and the Mapp by should be exactly the
same like the one to1 should be for
example in this case school and the
school should be an attribute of type
School in the student. Java class or the
student entity so the first thing is to
create a list of students when we have
one to many so here from the school side
just as I mentioned before we have a
list of students and then this list of
students so any time or every time you
have a list here just go ahead and don't
think twice and use the one too many
annotation and also use the ma by
attribute to map this list of students
to the school from the other side and of
course let's not forget to generate
Getters and Setters so let's generate
Getters and Setters for the for the
students let's click okay and now we
have students Getters and Setters so let
me just move them to the bottom and now
we have our student list so this is how
we can create a one too many mapping so
now let's move on and create the many to
one mapping from the other side so now
let's perform the the link and the
mapping from the student side so here
let's create a
private school field let's call it
school as exactly the name right here so
then soic colon and here so this means
that we have many students to one school
so many students can study in one school
and every time you have the Min to one
annotation always think about adding the
join column so here let's give it a name
so here let's say school ID school
uncore ID so now if I restart the
application we will see all the changes
that we will have within our database
and of course let's not forget
generating getter and Setters so I will
generate the Getters and Setter and also
the student profile which I guess we
forgot the last time so let's click okay
and also let me move them to the bottom
and now let's restart our application
and see the
changes so here first we can also check
the check the logs so here we have alter
table student profile if not exist and
then we have alter table to student and
we are adding all the references and the
links and the relationships so here
let's open this again and let's refresh
the tables so we see that we still have
three tables but let's let's check now
the school uh sorry the student table we
see that we have two foreign keys so
here we have the t uh two keys for sorry
and then we have one foreign key which
is this one which is called school ID
and it's referencing the school and the
ID from the school it and here from the
school we have again the ID and the name
and we don't have any other foreign keys
because the foreign key belongs to the
student table and the same here for the
student profile we have again our
student ID which is reference the T
student ID so like this we are able and
this is how we can perform and create
mappings between the different entities
using annotations from the jpa and Hyper
Nate and using spring data jpa now let's
move on and see how we can insert Data
before we move on to implement the
controllers let me first show you a way
how you can check that you implemented
correctly the mappings between the
different entities so here open the
database and let me make it a bit full
screen and then on the on the schema
that you have or the database that you
created right click and then you have
this diagram menu and then you can click
on show show diagram so here it will
show maybe two options maybe not for you
but click on database schema if it shows
the diagram type so then let me close
this one we see here that we have two
the three tables that we already created
we have the student we have the school
and we have the student profile so let
me just organize a little bit and here
let's move this
one and then also you have this um this
link right here and then when we make
when you make for example like when when
you move entities and so on so forth and
to organize these lines right here all
you need to do is to click on apply
current layout and it will adjust itself
in a smooth way so here we have our
student table which also named tore
student and also if you highlight it you
will see also the the script or the SQL
script script for it and then we have
here the student profile and we see that
we have the student ID as a foreign key
so the the primary key will be with um
with this golden key and the foreign key
it will be with blue one and the same
here for the student and we see also
that we have the school so now let's
move on and start creating the
controllers for the the school and let's
Implement few methods to insert some
school and then insert students and
assign them to school school and see how
we can do that now let's create our
school controller so right click and
then new Java class and let's call it
school
controller and then of course we need
our rest controller annotation and now
let's create our first post mapping and
then it will be slash schools and then
it we have a public school and it will
be create or save for example and here
we have our request body and then we
need the school object so request body
it will be object of type school and
then let's name it school so after that
we need of course to inject our
repository so it will be private final
School repository which we don't have
for for the moment but we will create it
in just a few seconds and let's call it
school Repository and now even if you
don't have it so here just highlight it
and use the autoc completion and it will
suggest you to create a class cor
repository or an interface or enam and
so on so forth so in our case we want to
create an interface School repository
and we want to create it in the same
package so let's just hit enter and here
we just made a typo so let's rename this
one so let's call it school repository
and then of course we need to extend the
the jpa repository and we need to pass
this schol as an object and integer for
the ID then let's go back to our
controller and here we need of course to
add a Constructor so let me make this
one full screen and now we have our
school repository and now we can use it
so here in this method all we need to do
is just return School repository Dove
school not save all just save and then
this schol that we get as a parameter so
then I will just duplicate this one and
instead of Opp post mapping I will
create a get mapping so now you are
familiar how we create controllers how
we return objects and so on so forth so
we don't have anybody and we need to
return a list of schools so here we have
a list and then let's import this list
and then let's say find all and here
instead of save let's say find all all
all right now let's start the
application and insert some schools and
since we also have our student
controller which is already named uh
first controller so let's go ahead and
just rename it and call it student
controller to be consistent so now let's
start the application and go to postman
and start our new API and see how we can
insert schools and assign students to
schools so our application is up and
running now let's move to postman and
test the the school controller and try
to insert some schools and then let's go
and insert also some
students now let's duplicate this tab
and then instead of students it will be
schools and in the body we will need
only one attribute which is the name so
let's just change this one and let's
call it alibu school and here all I need
to do is to click on
send and here we see that we have a 200
okay so this means that the school was
inserted and we see that we have the ID
and the student for now it's not because
we don't have any students assigned to
this school yet also let's go to the
database and check that so here if I
refresh my database and open the school
table we see that we have the school
that we just inserted called alibu
school now if if I want to insert a
student so let's see the structure we
have right here we have the first name
last name email and age and also we have
an object called school so let's go to
postman and structure and create an
object of type student to insert the
student and assign it to the school that
we just created so here let's go back to
the first tab where we have the school
the students to insert and here I all I
need to do is to add another attribute
mute of type school and this one is an
object so here and all I need to provide
is the ID because spring data jpa uses
the ID to insert an object as you can
see the school that we inserted has the
ID equals 1 so this is all we need to
provide so here we have the school and
the ID you can also provide the name and
so on so forth but it will not affect
anything because hibernate and spring
data jpa only needs the ID so now let's
let's click on send and we see now this
is the result so first we have a 200
okay and here we have the ID with the
first name last name and the student
profile for now it's null and we see
that we have the school which is ID
equals 1 name student and the name and
the student is null so this is also is
not a problem now if I go back and
duplicate the school request and change
it to a get and of course for the body
we don't have anything and I click on
send and here we see that we don't have
a response yet and this is because here
we have let's let's understand the
structure let's go back to the code and
let me open the student and the school
so here we have the school object and
the school object it has a list of
students okay and then it will try to
get the school and the students list and
then from the student it will try also
to load the the school information and
then it will go back to the school and
it will try to load the list of students
and so on so forth so we have here an
infinite Loop and this is because
hibernate will try to load all the
information Al together so let me show
you how we can fix that before fixing
the problem let's have a look on the
exception so here I will use this uh
soft trap just to have everything
wrapped and here we see that we have
this main exception and failure trying
to resolve exception from this uh spring
framework and call send error after this
response and this means that we encount
encountered uh an infinite recursion
with with the Json mapping so here when
Jackson tries to map the the object so
when it tries to map or to transform or
to create adjacent response for the
school it has a list of student and then
as I explained before it will go to the
student and then the student has also an
object of type school so it will try
also to um to serialize the school and
back again so we have an infinite
recursion Loop so or an infinite Loop
and let me show you how we can fix that
using the Jackson annotations so for
this one we will be using two
annotations one on the parent level and
the second one on the CH on the child
level so the the parent level is where
we have the list so the school is the
parent of the student
students I'm going to make this one full
screen and here on the list level we we
need to use an annotation called Json
managed
reference and this Json managed
reference so this tells Jackson that the
parent is in charge of serializing the
child and it prevents the child from
trying to serialize the parent now so we
need the Json managed reference on the
parent level and then we need to go to
the child level which is the student
right here and we need to go to the
field of type school and here we need an
annotation called Json back reference so
this is the back reference or this will
tell that this entity the student entity
or the student object doesn't need to
serialize the parent which is in in our
case the school so now let's restart the
application again and let's go back to
postman and try to insert the data once
again so here the application is up and
running so also let me keep it like this
I will clean up the console so here
again we need to insert this school and
insert the student and assign it to the
school and now if I try to fetch all
schools and I click on send we see that
we have a response and we have the
status 200 okay and here we see that we
have the ID and the school name and then
we have the list of the students so for
example if I insert a new student so
here let's say uh contact to and within
the same school ID and here let's say
Ali B Ali and I will click on send so
the school the student is correctly
inserted and now if I fetch again the
list of schools we see that we have the
school with the ID number one and we
have the list of students we have this
id2 it's the student we just inserted
and we have the first one which is John
Bali and with this email address so now
we have our application functioning but
there is one thing which is a little bit
uh not okay with all that is because we
are exposing almost everything and even
when we want to insert a student we have
or we need to provide the full School
object and imagine that we have other
relationships within the school within
the student like for example the student
profile and imagine we have subjects and
so on so forth so this will make our
object or our student object more and
more complex and it will prevent us and
it will add more complexity when we want
to save or to interact with the student
entity so this is introducing us to a
really important topic we will see just
in few moments so let's move on and
explore the next topic of our course dto
stands for data transfer object which is
a pattern often used inof Ware design
the main purpose of a dto is to
encapsulate and structure data that
needs to be transferred between
different parts of a system or different
systems entirely a dto typically
includes only simple data fields or also
called attributes and lacks the behavior
of the model or entity it represents so
here if we take the example of our
application we have a student and we
have a school we have also a student
profile which will hold some sensitive
information about the student like the
address like phone number date of birth
and so and so forth and mainly we don't
need to expose this information to the
outside word and also even for example
if you want to ret the retrieve the
information of the school we only need
to expose the school information and
since these information are represented
by entities and stored into a database
system which which is secured system so
we need to expose only what the user or
the end user is expecting and no more
extra information so for example as I
mentioned for the user we for the
student we don't need to expose uh
sensitive information such as address
date of birth phone number even if if
the if the student has a password so we
don't need to expose that so then what
we need to do we need to include a a
mechanism in the middle in between
between the entity itself and the
outside word so we need to to add a
mapper and this mapper is just a simple
mechanism you can use many
implementation or many tools and
libraries to map objects and then if we
use a mapper we can have multiple
representations for the same object for
example for the student we can have a
representation one only to expose first
name last name and we can have another
representation to expose or to receive
data from the outside world in order to
create a new student and for example we
need only first name last name and email
and so and so forth so this is one of
the advantages is we can have multiple
representations for only one object or
only one entity and this also appliable
for school student or the student
profile in our case and generally
speaking it's appliable to any kind of
ENT entity and the rest API should
communicate with the client through
these representations and we can have
one representation for the read and
other representation for the write for
example to create a student we can have
one representation which holds the
information or like the minimum required
information to create a student and for
the read represent representation we can
have a different one or a different
object that will be responsible for
exposing only the necessary and
non-sensitive information to the outside
board so when building a restful API dto
play a crucial role and now let's give
you some reasons why they are important
first of all we have data separation so
the data transfer object pattern helps
to separate the internal domain model
from what is exposed exposed through the
API this way you can change your
internal model without affecting the
external representation it also helps in
not exposing exposing sensitive or
unnecessary data to the API customers
then abstraction dto provide an
abstraction layer they give you a clear
structure of what your API will provide
to the client abstracting the complexity
of the domain model then performance
improvements instead of sending entire
entity over the network you can instead
send a dto which include only the
necessary information these can
significantly improve the performance of
your API as you can control the size of
your response payload then we have
flexibility since dto are separate from
your domain model they allow you to
tailor your API response to exactly what
your client need even if that does not
exactly match your domain model and here
we are talking about multiple
representations for the same object and
finally versioning so dto make it easier
to maintain different versions of your
API by using different sets of dto you
can support multiple versions of an API
simultaneously and then in the next part
we will see how we can use this dto
pattern in our
application now let's go ahead and
create a new object that will represent
a student request for example so let's
start with a student and here we have in
our student controller we have the bunch
of methods that we created to persist a
student to fetch a student and so and so
forth now let's see what are the changes
that we need to apply after creating our
student dto object so I will close
everything and here right click and then
new and then Java class and for this
example and for the dto we will be using
records as I explained before what is
the difference between records and
normal poos so let's say
student dto for
example and here for this student dto it
will be a similar representation to The
Entity itself so here to create a
student we need the first name we need
the last name and we need let's say just
the email and the age is not mandatory
to create create a new student so I will
copy these fields right here I will copy
them and then let's paste them in the
student dto so here I will just paste
these fields and I will add the comma
and now we have our record ready to use
so also since we have a relationship
within the school so a student is linked
to a school all we need to do is to pass
a school ID instead of the whole object
so let's imagine that the information we
have within the school is uh address uh
location and like a bench a bench of
information about the school but for
hibernate and for persisting the data
all we need to do is the ID of the
entity so here within the student dto
after the email I will add also an
integer school ID so I will create an
object and then we call it school ID
like this so now we have our student
record or student object ready to use
now let's move on and create an object
for uh for school Al also and let me
show you how we can use these dto to
persist data and to send back
information so now if I close all these
classes right here and if I go back to
the student controller let me make it
full screen and here in the post mapping
or when we want to create a student so
here we are requesting an object of type
student which is our entity but let's
change this and instead of requesting
the student uh entity let's request
student D object so now we are asking
the the the rest client to send a
student dto which is represented by the
first name last name and and an field
called school ID which represents the
identifier of our
school so then we see that the
repository. save is now not working
because here it's expecting a type
student and we are passing a student dto
so here as you can see in this error
method so infer Type S of type parameter
s is not within its bound so it should
extend com. al. example. student so we
need to pass an object of type student
so now let's see how we can use this dto
to save an object so as we explained
before here we need to transform this
student D object to a student object so
here let me just let me create a private
student method and let's call it two
student okay and this two student method
will receive exactly this object so
let's call it dto right here just for
clarity and here what I will do I will
create a VAR student equals new student
so here I just have a new student so I
can use also this Constructor that we
that we created before or we can use the
Getters and Setters so it's actually up
to you to choose which way you want but
let's go ahead with with sets and
Getters so here let's say student. set
first name and then the first name is
the one coming from the dto doget or do
first name and then we have student.
last name so here it's a set instead of
a get and then we need the dto do last
last name and then we have student. set
email and then again from the dto doget
email so here it's not a get like within
records we don't have gets but we have
methods representing like with the field
name so now we have all the three fields
that you specified for this student D
first name last name email and now we
need to set an object of type school and
Link it to this student object so here I
will create a VAR School equals new
school and then for this school I can
just use D dto and just set the ID so
here just school and then
dto so here I need to set the ID sorry
so it will be my dto do school ID so
here I have or I prepared my school
object now I need to assign the school
object to the student so here I will say
student do set school and then the
school object I just created right now
so now we have our two student method so
again let's just return the student
object so here we have our two student
method so all I need to do here is just
replacing this method code right here so
we will create a variable and here I
will just rename this one to dto or
student dto you can name it as you want
and here I will create VAR student
equals to student from my dto Okay and
like this I will be able to persist the
data okay so let's go ahead and try this
so now the application is up and running
also I will just do a small change here
in the application. yaml instead of
using Create drop I will use just update
so because I don't want to lose the data
each time I restart the application and
now I will just restart again and let's
go ahead to postman and try to create a
new
student so here in Postman first we need
to create a school so let's just send
this one and we have the ID number one
and here we have the the method that
will allow me to create a new student
okay so it's a post and then student so
here we said that we no longer need the
age since it's just a requirement from
us and here instead of passing the
school object all I need to do is to
pass a school ID right here and this
school ID I will give it the name one uh
sorry value not name and then let's
click on send and see what will happen
so here we have 200 okay so this means
that the student was persisted and it
was linked to the school that we
recently created so let's go back to the
to our database and check if we have
everything persisted and working as
before so here let let's go to the
database let's
refresh and then here we have our school
and if I open the student we see that I
have the student that I just created
with the name Ali B Ali and we have also
the school ID equals one so like this we
saw that we using the dto we are no
longer requiring all the information or
all the fields from all from the entity
but it's just a representation that
suits our need but we still have one
small issue we are returning again the
student object so we are returning or
exposing the student entity and here as
you can see in Postman and the response
we have the age which we don't want uh
to expose and also have this object uh
student profile which is null and so on
so forth also we have the ID and maybe
we don't want to expose that so now
let's see how which dto we need to
create in order to return a proper uh a
proper object and a proper response to
the user so now let's create another
record and it with this one we will call
it so it's a record and we will call it
Student Response or student
representation dto so let's say Student
Response dto and exactly as we did right
here so we need the first name last name
and email for example so these are the
information that we want to expose to
the end user or to the to our client uh
to our RIS client so let me stop the
application
and here all I need to do I need to go
back to my controller and then instead
of returning a student I will return a
Student Response dto okay but here again
we see that this repository. saave is
returning a student object and I need to
return another type so again we need
another meth method right here so we
need a private
student response dto and let's say to to
Student Response dto and this to Student
Response dto should receive student
object as a parameter okay and then all
I need to do is return New Student
Response dto and then I need to pass all
the information that I need so it will
be student. get first name and then so
let me inline this
one so it will be student. getet first
name and then student. last name and
finally student. getet
email and like this we have our Student
Response dto and here semicolon and now
we have our representation ready so here
I will say just VAR saved
student equals this one or like the
result of saving the student and and
then all I need to do is to return to
Student Response from the saved student
and like this I have again a new object
or a new representation of the response
that I want to expose to the customer or
to my rest client so let's go ahead
start the application and let's try this
out so now if I go back to postman and
let me duplicate this tab and let's use
a get in here and let's search student
by its ID so let's say for example
student SL1 or or let's save another
student again and we will come back to
that method later on so here for example
if I say Ali or like John do and here
let's say it's John do alibu coding.com
and now if I click on send we see that
we have the response or a different
response from our back end and we do not
expose extra information so here the
response is really encapsulated and an
abstract response without any further
information that we should not Expos to
the outside word so here we are exposing
only the necessary information even if
you see for example that this email is a
sensitive information all you need to do
is just remove it from the dto and
adjust the
mapping now for our school object let's
create a dto for that so again just new
and then record let's say school dto and
here in this record all we need to do is
a string name so or string school name
you can name it as you want so now we
have our school dto record or School dto
object and we can use this one now in
the school controller in order to save
and expose information about our schools
so again let's move go ahead and
Implement that let's now introduce all
the necessary changes to our school
controller in order to receive a school
dto and expose also a school cool dto so
here let's check back again here if I go
back to postman and let me start the
application I will explain to you what I
mean so now if I go back to postman and
here if this is the the school or like
to retrieve the school with all the
students we see how we see here that we
have the information of the school and
we have the list of the students so now
it's it's okay to have it like this
because in this case and so far we have
only students assigned to this uh to
this school but imagine the case we have
hundreds and even thousands of students
assigned to the same school when you
request the information or like you need
just a light information about the
school we will be loading the school and
all the students and imagine also we
have other relationships for the
students and like the response will be
really really heavy and it will take
time until it gets from the back end to
the rest client so what we need to do
again we need to just use dto and expose
only the information that we need and I
will then show you how we can expose or
like fetch the students for a specific
school so now let's go back to our code
and let's adjust our controller to only
Expose and receive all the ne only the
necessary information for the school
object so here for the Post mapping or
to create a school first I need to
return a school dto again I just want to
remind you that the school dto takes
only as a parameter the school name and
then here we also need to get a school
dto as an input or as a request body so
here all I need to do is just to have
VAR
school so here let's call this one dto
and school equals to school for example
because I need a method that should do
or make uh or perform the mapping and
the object transformation from school
dto to an object school so here we don't
have yet this method so let's create a
method School in school controller so
here it should return school and that's
it so now all I need to do is just
return a new school and for this new
school it will be d.name since our
school contains only one attribute which
is this one and we don't really need to
pass any students
then we need to perform saving or like
we need to save the school and all I
need to do so in this case I can whether
return or like have for example saved
School equals school. repository and
then I will do VAR and then I need
another method to transform this school
dto uh this school object to a school
dto but here as you can see it's just
for this case the school object is the
same as as the for the input as the
output so all I can do is return dto
again so this also valid and this
will allow me to have or to save some
time on the execution level so here we
have our our method right here it's a
post mapping and we receive the school
dto and then we save this the school and
return the object back so let's go ahead
let's restart and let's try out this so
if you go back to postman and here this
is the tab for posting a school so let's
say alibu School 2 and then if I click
on save so we see that the the school
was persisted and here I have the
response that I already get from my back
end now if I go back and check the
database and here let's
open our school table we see that we
have alibu school and alibu school to
sorry not do which is was persisted into
our table now for fetching the list of
schools that we have in the database we
don't need to expose the school but we
need to return a school dto object so
here I will just change this return type
to school dto and then we need to
perform also a mapping so we need to do
a transformation for each element of the
list to a school dto object so here
let's create private and then school dto
and let's call it to school dto and
these two school dto will receive a
parameter of type school and then all I
need to do is to return a new school dto
and then it's will it will be School
dot get name now we have our method and
this method it will transform like it
will take a school object as a parameter
and then it will return a school dto out
of it so here what we need to do so
first let's have a
stream and then let's perform a mapping
so then stream so it will this will
return a stream of schools and then a
map so we can do this and then we can
use the method reference and then we can
call this method to school dto and then
of course we need to collect and return
a list so here now we have a
transformation so after finding all the
students which will return a list of
schools then we open a stream so this
will transform our list to a stream of
schools and then we will do a mapping so
we will do a transformation of object so
this means for each element of this list
of schools or of this stream of schools
we can or we will perform a
transformation and then it will we will
call the two School dto method which
will return later on a stream of school
dto object and then we call a reduce
meth method which is collect and then we
want to collect all of this as list so
now let's go ahead and try this one and
see the output so let's open again
Postman and here we have the method or
like the request to call or to get the
list of schools if I click on it we see
that we have now an object name alibu
school and then name alibu School 2 so
we don't expose anym the list of
students or any extra object or any
extra information that we don't want to
expose it to the outside world or to our
rest customer all right so now we have
everything uh we need so let's move on
and and talk about a really interesting
topic so see you in the next lecture as
the application and the business
requirement grows we see that the code
that we are producing in here in this
controller student controller and also
in the school controller has grown
significantly and for that we need to
introduce another layer in order to make
our code more you more reusable and we
we need to create a separation of
concerns so for that we need to create
another layer which is called the
service layer so the service layer in
rest API plays a crucial role in
separating the concerns of handling
business logic and application specific
operations from the presentation layer
which is the controller and the data
access layer which is the repository so
it serves as an intermediary between the
controller and the repository
encapsulating the business logic and
providing a reusable modular and
testable code base and here are some key
reasons why the service layer is
important in RIS apis first we have
business Logic on capsulation so the
service layer is responsible for
implementing the business logic and
Performing complex operations required
by the API it encapsulates the logic
that goes beyond simple data retrieval
or modification such as validation
calculation transformation or
coordination of multiple operations so
by centralizing the business logic in
the service layer you promote code
reusability maintainability and
readability also the service layer
provides a separation of concerns so the
service layer helps to maintain a clear
separation of concerns within the API
architecture controllers are responsible
for handling incoming HTTP requests and
providing appropriate responses while
repositories handle the data persistence
and retrieval the service layer sits in
between ensuring that the business logic
and application specific operations are
decoupled from the other layers so this
separation improves code organization
makes the code easier to understand and
allows for independent changes and
testing of each layer and finally
testing and maintainability so the
service layer provides a boundary of
unit testing as you can test the
business logic independently for the of
the controllers and repositories by
mocking or stabbing the dependencies you
can for Focus solely on testing the
logic within the service methods so this
makes it easier to write comprehensive
and targeted tested enhancing test
coverage and ensuring the correctness of
business logic Additionally the
separation of concerns achieved by the
service layer improves the
maintainability of the code base as
changes to the business logic and can be
isolated to the service layer without
affecting the other layers so in the
next part let's go ahead and create the
service layers that we need for our
application so now let's start with
refactoring the student controller and
create and extract the code for each
layer so here let's first start with
this two methods the method that can
convert and map an object student dto to
an object student and also we have
another method which converts a student
to a student response dto so for that
let's go ahead and create a new class
and let's call it student mapper so this
class or this service is responsible for
mapping or creating mapping for our
students so first to make this class
service all we need to do is to add the
service annotation on this level right
here and then let's go back to our
student controller and let's copy or
let's cut this two methods right here so
I'm going to use command X to cut these
two methods and then we go back to the
student mapper and then just paste the
code right here and don't forget to make
these methods
public and again here let's make the
second method public so now we have
these two methods available in this
student mapper service so now in order
to use the student mapper and the
student controller all we need to do is
to inject our student mapper so let's go
ahead and do it so here we have private
final student
mapper and then let's call it student
mapper and here of course we need to
include that or to add this to our
Constructor so let's go ahead and do it
and now we have our student mapper
injected I'm going to make this one full
screen and now let's fix the test so
here instead of calling directly the two
student we need to call student mapper
do to student and here we see that the
code still works and we don't have any
compile issues and the same here so for
the other method to Student Response dto
so here we started or we extracted our
first service and we have our student
mapper service which can handle the
mapping and the objects transformation
so now let's move on and create another
service for this student controller in
order to make our code more and more
reusable and make our code maintainable
and uncapsulated
so now we extracted the code and we make
we made our
code less complex on the student
controller but we still see that we have
more logic which is happening around
here so here we have like mapping saving
and then returning the mapped object so
the idea is always to make the student
or the controller layer responsible only
for receiving the requests and sending
back the responses and all the logic and
all the business logic needs to go to to
a separate service so for that let's go
ahead and create a a new class and let's
call it student service so here student
service class and again to make the
student service a service we need to
give it The annotation service so here
we can use whether the annotation
service or just a component but since we
decided that this is a service layer so
we can annotate it with a service
annotation so then we see here that we
are using repository and mapper so we
need to move these two dependencies to
the service layer so I'm going to close
this one and then I will just cut this
student uh these two dependencies and I
will paste them here and again let me
make it full screen and now I need to
create or to add a Constructor with
these two objects or two dependencies in
order to you inject them using
Constructor injection and here let's go
back to uh to this one and now instead
of injecting the repository and the
mapper all we need to do is to inject
the service that we just created and we
will come back to this in a few seconds
so here we see that we have this post
method so first I'm going to uh change
this one and make it save student so I
will just re rename the method and here
in the student service I need to create
also a method that will perform these
three operations this means transforming
a student dto to a student and then
saving the student and then finally
mapping the student to a student
response dto so I'm going to cut this
one and here I will go back to my
student service and I will create a
public method so I will call it or like
it should return a student response dto
so let's call it also save student if
you want to and this save student needs
to take as a parameter the same object
that we have right here so let's pass
our student
dto as an input and then let's open this
and just paste the code that we we
copied from the controller so now if I
go back to my student controller and
then I will just remove this constru
Constructor and again I will inject my
private final student service the one
that we just created and let's call it
student service and of course we need to
create or inject it through the
Constructor and here we have our student
service so here in this save student
method let's just do this do student
service do saave student and then we
pass this the dto as an object so for
this method we see that we have only one
line and of course we need the return
keyword and how here we have only one
line which is calling the student
service in order to perform all the
business logic that we need so here
let's go ahead and also migrate and move
all the logic for the other methods also
to the student service so now before we
move on I want to give you a small
exercise and I'm pretty confident that
you will handle it your own so here I
want you to migrate and to move all the
logic in this controller to the student
service so this means you need to create
a method find all student in the student
service and the same for find student by
ID and find student by name and the same
for deleting a student so go ahead and
do it and I will give you the solution
just afterwards that's good so now let's
correct this exercise so first of all
let's create a method in our service and
let's call it find all students so we
can just copy this
one and then move it to the student
service so here I will have my method so
find all students and now if I go back
here instead of repository and I will
call this the service so here I have
student service do find all students
and now we migrated the find all
students to the student service so in
case we need to perform any other
operations on the student on the find
all students we can just do it on the
service layer and we no longer need to
update or to change anything on the Ser
on the controller layer so again let's
do or let's migrate this one and then of
course I will give you another exercise
just to transform or to return the
Student Response dto instead of the
student for this controller so let's go
ahead and let's do this so here we have
we need the integer ID and then all we
need to do is just to return this one so
let's copy this code from here and then
paste it here and now instead of calling
the repository so it will be the student
service doind student by ID and then we
need to pass the ID as a
parameter so we Mig ated also the fine
student by ID and now let's go ahead and
migrate this method
to so let's copy it and then let's go to
the service and here we need the string
name as a parameter and then also we can
just go back and copy this line of code
and paste it in here so again let's go
back to the controller and here instead
of returning the repository so it will
be student service do find all by name
or find students by name so here find
students by name and then we need the
string name so now also we migrated this
method and finally we need to migrate
this delete method so let's make it also
a void so let's go back to student
controller and let's spacee this one and
we need our integer
ID and then we need just this line of
code so let's just copy
it and then paste it in here so then we
know we go back to the student
controller and instead of calling the
repository let's just call student
service and then just the method called
delete so now we migrated all the code
to the service and as you can see here
in the controller methods we see that we
just making a call to the student
service so we have no logic in here so
that's good now we migrated everything
and The Next Step let's see what we need
to do
again now I want to give you another
exercise so as I mentioned before here
we see or we need to return always the
dto or the dto representation and we
want to do the same for all the other
methods so here instead of returning the
student object I want you to return the
Student Response did you object instead
so now I will leave it to you and just
go ahead fix this and change the return
type and I will see you in the solution
for this exercise that's good you made
it this far so now let's correct
together this exercise so here instead
of returning a student we need to return
a Student Response Toto so let's first
change the type of this list and here in
this find all method let's start an open
a stream and then let's make a map and
then we need our mapper so so student
mapper and then we can make a method
reference to Student Response dto and
finally we need to collect our objects
so here we have collect and then
collectors as list and of course we see
that we have still one related problem
which is the student controller or the
return type of the student controller so
we need also to change that so now we
have our Student Response dto for the
find all student methods so next next
let's go ahead and also migrate and
change the the return type for the find
student by ID so let's go back to our
student service and here in the find
student by ID let's just paste this one
so we change the return type and here
this find by ID as you can see it
returns an optional of student So within
the optional we have also the map method
so we can also perform a transformation
and return turn the transformed object
so for the transformation we need also
the student mapper and then to Student
Response D otherwise here we need to
return a new student or we can just
return null for the moment and then I
will show you in the in the future
sections how or how to deal with this
kind of objects in case we don't find
any student with the specified ID so now
let's go back to the controller and also
change the return type for this method
so here it should be Student Response
dto and now let's move on and also
change the return type for the find
students by name so again let's go back
to the service and here instead of
student we need to return Student
Response dto and here also we know that
this find all by first name returns a
list of student so it will be exactly
the same thing as in here so we can just
copy this code to make it faster and
just paste it in here so we have the
find all and then stream and then we
perform the mapping and then we collect
the response and of course don't forget
to change the return type in the
controller so here I will just use the
content to paste so here I want or I
need my Student Response dto and we have
the issue fixed once and for all so now
we have everything fixed in the student
controller and we migrated and moved all
the business logic to the student
service so here as you can see if we
need to perform any operation or to
apply any business logic we just do it
on the student service and also for
example if we need anything or a new
method on the M for the mapping or if we
want to return another type or another
representation of the student all we
need to do is to perform and do this
transformation on the student mapper
level so now we have our student
controller clean let's go ahead and also
migrate the business Logic for this
school controller to a school service
that's good you made it this far now I
want to give you another exercise so now
let's move to the student controller and
I want you to extract all the logic that
we have in here to separate services so
just to give you a hint just I want to
remind you that we have mapping methods
right here and we also we have some
logic in here and also we have some
logic in here so just go ahead and do
this and extract all this code to
separate services and I will see you in
the solution for this exercise good you
made it this far and I'm pretty sure
that you correctly implemented the
services and extracted the services for
the school controller so now let's fix
that together first we need to create a
new class so let's call it school mapper
so this school mapper of course we need
the service annotation to make it a
service and to make it injectable and
first let's move these two methods right
here so I'm just going to cut them so
let me make it full screen and then
let's paste these two so here also we
need to make these two methods public in
order to be able to use them from
outside this class and now also let's
create another class and let's call it
school service so here we have school
service class and again we need the
required or the sorry the service
annotation and again we need to create
two methods since we have just two
methods right here so I'm going to just
copy this one or like I'm going to copy
the whole method and I will paste it in
here so here we don't need this request
body and we can also make the
code a bit cleaner and I'm going to make
it full screen screen and here of course
we need to inject our mapper so private
final school mapper and then let's call
it school mapper and of course we need
our Constructor for that so add a
Constructor and here instead of using to
school I'm going to use my school mapper
do to school and the same in here so
here we need also the school repository
so let's go ahead and inject it so we
have private School repository and let's
call it school repository and also let's
make it final and inject it and add it
as a parameter into our Constructor so
here we extracted the create method so
let's go back to the controller and
instead of calling this we need to
return the call from the school service
so here I will just change this one to
school service and also I will rename
this one to school service so let me
just remove the controller and inject it
again so here let's call it school
service and let's create a new
controller with a school service so here
I will just remove everything and
instead of REM just returning the dto I
will just return my school service.
create and then I need to pass the dto
as a parameter so now we just
successfully migrated and extracted the
code for the create let's do the same
within the school or the find all method
so I will copy this one so or I can just
copy everything and here I will go to my
school service and I will paste this
method right here so here instead of
this for the mapping part instead of
this I need to call my school mapper and
then the method to school dto and of
course let's not forget to change or
make the changes in the school
controller so here let's call our school
service do findall method so again we
ALS also need to optimize the import and
now we have our code migrated and
extracted to separate services so here
we see that the code is more and more
readable and maintainable so if we need
to again to perform any business logic
we only have one place to perform it and
we don't need to make everything in one
place or in the controller and this will
make our life easier later on when we
move to the to the unit tests part you
will see the impact and the advantages
of extracting the code to service
layers as our application grows we see
that each time we need new classes new
interfaces and new objects to create and
this
is too much and makes our code really
not easy to Target and for example if
you search a specific class or specific
object to update or to perform any
operation on it it's really Prett a bit
hard to to to find it and here it's just
a simple example imagine if you are
working on on a bigger application and
let's say for example an e-commerce
application within the same codebase so
this makes our life a bit complicated to
find and identify the correct class and
the correct object to update so for this
I want to introduce you to a topic which
is the best way to organize your code
within your application and for for this
one we have several approaches and I
will walk you through each one of them
and explain how to organize this the
code using each of these approaches and
then we will choose together the best
approach or I will give you my
recommendation for the best approach to
organize the code but you are always
free to choose the best approach that
suits you so now let's first start
explaining the approach the first first
approach is called by feature in this
approach the code is organized around
the business capabilities of features of
the applications for instance if you're
developing an e-commerce application you
might have packages like product order
customer and payment and each of these
packages would then contain all classes
related to that particular feature such
as controller Services repositories and
models so this organization style is is
benefical for large teams and project
because it's easy to locate code related
to specific feature the second approach
is the layer approach so in this
approach the code is organized around
its architectural layers common layers
might include controllers Services
repositories models and utils for
example so these Styles is benifical
when the focus is more on technical
roades classes rather than they their
business roles so however one downside
is that change to a single feature could
affect multiple packages and the next
approach is by domain so in a domain
driven design or also called DDD
approach the focus is on the business
domain packages so packages are formed
around different bounded context of
subdomains within the large domain so
for instance in a Health Care system for
example there might be packages like
patient management billing scheduling
and medical records and finally and the
Final Approach is by component so in a
more modularized approach you may have
top level packages for each highlevel
component or of your system within each
of these packages you can further
organize code by feature layer for
example if we have a user component we
can have Sub sub packages like
controllers Services models and so on so
forth same for product component we can
have controllers Services models utils
and so and so forth and personally I
prefer the layer approach so here we can
have packages for product order customer
and payment and inside of each package
we will have all the related classes to
the product so in this in our case we
will have a package for school a package
for student another package for user
profile and so and so for forth and if
we need a common package like for
example let's say validators or
exception handlings or like custom
exceptions and so on so forth we can
create a specific package for that so
now let's move on and organize our code
together so now in order to move all
these classes to the appropriate
packages there are several ways and let
me show you how you can use your IDE to
do that here in the first line of each
class you will see a line called package
and it refers to the package that holds
the this class so here for example if I
want to move the school class to a
package that I want to call school all I
need to do is to add dot school and then
anj will say that we don't have a
package for that and if I open this one
this small popup right here we see that
we have set package name to com. alibu
example since entj is is considering
this as a typo or it will propose also
to move to package. al. example. school
so let's go ahead and choose this option
and here if you uncheck this button
right here you see that inside this
example package it will ask to create a
school package so let's go ahead and
click on okay and see that here we have
this school package okay but this will
come with some related issues because we
need to import now the appropriate
classes but first let's move all the
school related uh classes to the school
package so here we can just perform a
drag and drop so let's just drop this
one here and ask an to refactor same for
school dto and then refactor and also
school mapper so here and finally we
need the school repository and the
school service so it's easy to do it
within the within the ID so here let's
check if we have another school object
so we don't here if I go back to the
school I need again just to import the
student but let's do it for later and
then what I can do also like a different
way I can just create a package like new
and then package and then let's say for
example student so here this package
will hold all the information about the
student and now I can select multiple
classes so student student controller
student dto student student repository
and then Student Response dto and
student service and finally student
mapper and then I all I need to do is
just to drag and drop them to the
student package and then click on
refactor and let entj take care of the
rest and finally we see that we have the
student profile so let's also create a
new package for that so let's call it
student profile and finally we need to
move the student profile to this student
profile package and then let's go back
to here and let's check everything so
here we see that the school we need just
to import this one and if you just type
or uh open the auto uh code completion
it will propose that to import the
school from this package so just select
this one and now we have our school
object ready to use so then if I go to
the school and also open let's import
our student object here and now we have
everything fixed and if I go back to the
school we see that our application is
compiling successfully and also to make
sure that everything is compiling just
go to build and then build project and
let's see if our project is successfully
built so we still see that we have one
issue is with the student mapper so
let's click on this one and again we
need to import this school from here so
now let's check back again and we see
that we have in this school mapper and
the student mapper sorry not the school
mapper because we are using the school
object in here so we need to import it
from the appropriate package since they
are now in different packages so again
let's check if our application is
building and then click build on and
build project so now the project is is
successfully built and everything looks
bit nicer and pretty much nicer not just
a bit so here we have our code organized
if I need something school related all I
need to do is to go to the school
package and here we have all the classes
related to the school the same for the
student so now let's move on and check
what comes next now after all this
refactoring and the code organization
let's go ahead and check if our
application is still working so let me
close all this and then let's start the
application and go to postman and make
sure that the application is still
working so here we see that we have the
application is up and running and
everything is totally okay so let's go
to our Postman and make sure that
everything is working fine so here in
Postman so for example if I go to
schools and try to retrieve the list of
schools we see that we have the response
and we have 200 okay and now for example
in case I want to insert uh a new
student let's say alibu and I will just
provide the first name and the school ID
and let's click on send we see that we
have our student persisted and we
receive a 200 okay but here we see that
we have the last name and the email are
null and also let's go check in the
database and see the changes so here I'm
going to make this full screen and now
let's open the student class or the
student table we see here that this is
the the latest student that we inserted
and we inserted it with the first name
alibu but we see that the email and the
last name and even the age are null so
the age is zero because it's of type in
so by default the int is zero but we see
also that we have the email and the last
name they are null and this is not
really appropriate when it comes to
database and for the data we want to
persist there we can accept null values
uh for some Fields but for other fields
we cannot accept null values for example
when we talk about the email or the
student so the email can be also a
unique identifier and important and
sensitive information for student so we
need always to have the email and the
last name for the student so this also
introduces us to the next section of
this course so let's go ahead and
introduce that and let me explain to you
the issue and how we can fix
that data validation is crucial in RIS
API for several reasons First Data
Integrity data validation ensures that
the data being received and processed by
API meets certain rules and restrictions
this helps maintain the the consistency
and real reliability of your data for
instance validating an email address
format ensure that you won't have
invalid email addresses in your
database preventing attacks and
validated data can expose your API to
security vulnerabilities malicious users
can send harmful input to your API in an
attempt to perform SQL injection
cross-site scripting also known as xss
and other types of attacks proper data
validation can significantly reduce
these risks error preventing by
validating Data before it's processed
you can prevent errors that might occur
during string processing if you receive
a number where you expect a string it
can cause errors in your code data
validation helps detect these issues
early user experience validating input
on the server side and providing clear
ER message can greatly improve user
experience it lets users know what they
did wrong and how to correct it rather
than leaving them guessing performance
receiving large amount amount of
incorrect or poorly formatted data can
affect your API performance validation
can serve as a first line of defense
against unnecessary processing such data
and finally business logic compliance
often business rules determine the
acceptable values or formats for certain
data fields validation ensures that the
data your API receives and processes
complies with these business rules now
now let's see in action how we can
implement this in a spring boot
application the first thing that we need
to do is to add the required and the
needed dependency for validation and
spring boot provides already a starter
for validating objects so let's go to
our pom.xml file and here after spring
data jpa for example I'm going to make
this one full screen let's add a new
dependency so here we need the
dependency called Spring boot starter
validation and it comes from the same
group ID which is org. springframework
dop put and then all you need to do is
to click on this button to load the
maven project or the maven changes or
right click and then reload project and
like this Maven will download this new
dependency and now we are ready and able
to use this dependency within our
project so the next step let me show you
how you how we can validate objects just
using some annotations and use the power
of spring wot starters to delegate
almost everything now the question that
you need to ask is where to add the
validation so we mentioned before that
validation within spring boot starter
validation it's just a bunch of
annotations that we need to add to some
fields and then spring will do the rest
for us of course it will not do it by
itself self but we need to tell spring
that we want to validate this object
that contains the validation annotations
so the answer is we need to add the
validation on the first entry point
object that we use to interact with our
rest API so now I guess you get what I
what I mean and this is on the on the
dto level so for example here if we go
to our student controller and go to the
Post mapping the method that helps us to
create or to save a new student we
request a student dto object so the
validation needs to be done on this
level all right so let me show you how
we can validate this object so first as
I mentioned we need to add some
annotations telling spring boot stter
validation what are the validations or
what are the controls that we want to
add on each field of our object and
these annotations are valid whether you
work with records or if you work with
only simple classes or simple poos let's
first start by validating for example
our first name and let's say that we
want to make sure that the first name
should not be empty okay so here we have
an annotation called not empty and here
to make sure that this is the right and
the correct annotation it comes from
Jakarta validation. constraints or if
you are using spring 2.7 something or
like a pror version before the spring 3
it will be Java x.v validation.
constraints so now let's use this not
empty annotation on the first name so
I'm going to make this one full screen
so this not empty annotation let's go
and check the documentation and the code
of this annotation always don't forget
to download the source code so you have
everything think clear and and complete
so here it says that the annotated
element must not be null or empty okay
so if we add um the not empty annotation
to a field of type string or here we can
see the lists or the support types for
this annotation so here the supported
types are so here we have char sequence
so this means the length of character
sequence is evaluated or a collection so
the collection size is evaluated a map
the map size is evaluated or an array
this means that the array L length is
evaluated so here it will make sure so
this annotation will make sure and
ensure that the first name is not null
and is not empty this means that the
length should be greater than zero so
also I will add this not empty
annotation to the last name just to make
sure that the first name and the last
name are not empty when we try to create
a new student so now let's move on and
let me show you how we can make or how
we can tell spring to validate the
student dto when we receive a request
body from the user or from the rest
client sending us an object and we want
to transform it to student dto so let's
see how we can validate that so this
student dto is used to interact with the
student controller so as we can see here
we have in the post mapping for the
method save student we have a request
body of type student dto so we need to
tell spring that this object should be
validated so now how to do that all we
need to do is to add an annotation
called valid and this annotation valid
comes from Jakarta do validation so it's
the same package as the the not empty so
here this one is Jakarta Dov validation.
constraints so these are the constraints
that we can use and here is is the valid
comes from the Jakarta validation
package so you need to be careful about
that because if you import the wrong
annotation the application might not
work so now let's start our application
and test these changes so let's start
the application and then let's go to
postman and send an student dto object
but with the first name and the last
name with n values so here this is our
post request and here we see that we
have only first name and the school ID
so here we don't have the last name so
I'm expecting to have an exception or an
error or validation error raised by
Spring if we don't pass the last name so
let's go ahead and click on it so here
let's say Katherine as a student name
and let's click on send so here we see
that we have a bad request so our back
end raised automatically a bad request
response so let's go and check what we
have as exceptions or what we have as
logs so now let's check this and here we
see that we have nothing like but we see
just one warning so here we have a Warn
and we have a default exception Handler
resolver and it says here resolved an
exception of type method argument not
valid exception and here validation
failed for argument zero in public
Student Response dto and so on so forth
so save student controller and here we
say that field last name rejected value
null all right so here we have an
exception raised and rest client
received a 400 response 400 means bad
request as we can see right here so it's
a bad request but with no further
information about what happened exactly
and here we are missing one something
important that we explained before which
is the user experience so the so the
user that doesn't know what happened or
what he missed exactly so he needs to in
this case he needs to recheck the
everything and then try to send a new
request so let's see how we can catch
this type of exception and how we can
handle and return a proper response to
the to the end user as we can see here
in the logs spring validation through an
exception of type method argument not
valid exception so I'm going to copy
this one and now what we need to do is
to handle this exception inside this
student controller so what I will be
implementing right now I will explain it
in details really in deep details just
in the next lecture so now I just want
to show you how we can handle an
exception inside the controller and then
we raise a proper and clear message for
our end user so now I would just scroll
down and here I will create a public
method so a public and then response
entity and then this response entity
will be of any type and then so here I
will say handle and then the method
argument not valid exception and here as
a parameter I'm expecting an exception
of type method argument not valid
exception so we need to import this one
so let's import it and then let's write
the logic for this one and of course to
make this method a Handler method or an
exception Handler method we need to add
an annotation called exception Handler
and this exception Handler takes a list
of classes or a single class as value so
here we want in like within this method
we want to handle the exception of type
method argument not valid exception so
each time we receive or this controller
the student controller throws an
exception of type method argument not
valid exception this exception will be
handed inside this method so as I
mentioned don't worry about that I will
explain all this in details in the next
lecture so for now let me create a uh a
map let's call it errors equals new
hashmap and this hashmap will be of type
string and string so the first string
will hold the field name and the second
one will hold the message name okay and
then what I need to do I need to get the
exception or the validation exception
from this method argument not valid
exception and then transform them and
send back a map of Key value and the key
is the field name and the value is the
message that was raised by the
validation so here all I need to do is
exp like or my exception and then that
do get binding result and then we have a
method called get all errors and as you
can see it will return a list of object
error so let's do that and then I will
do for each so for each element or for
each error which is returned by the get
all errors here so like the these errors
that we have are coming from the
annotations that we used in here so for
example if we use multiple annotations
even on the same level name here so we
will get all the errors then so now what
need to do is I need that my object
which is let's call it error and then I
will use the Lambda expression and for
each element what I will be do doing is
I want to extract the field name and the
error message so I will have here a VAR
field name equals and then I need my
error and then I need to get the field
but I need to cast this error object to
another type so it should be casted to a
type of type field error so then it will
be field error and then I have a method
called get field so this will return the
field name and then I need another
variable which is the error message so I
will call it error message equals again
we need to we need to go to error. get
default message so this will return the
default error message that will be
thrown by the exception and also get we
get this error message from this
annotation right here so now once we get
the field name and the error message all
I need to do is to store this in the
errors map and then put and the key is
the field name and the value is the
error message and like this we gathered
or like we captured all the error
messages and we formed a proper object
that we can expose to our customer and
now of course we need to return a new
response entity and then for this
response entity we will pass the errors
object and then a bad request so it will
be HTTP status do bad request so now
every time a method argument not valid
exception will be raised inside the
student controller this method will
intercept this exception and try to
extract and transform the error message
messages that are coming from the
validation process and transform them to
a proper response that we can send to
the user so now let's restart the
application and see what happens all
right our application is up and running
let's go back to post none and let's
just click on send so here we see that
we have a proper response so here we see
that last name must not be empty and
even if I remove for example the first
name we will see that we have two error
messages because for now we have two
annotations one is on the first name
level and the last one is on the last
name level so now let's let's move on
and explore more annotations and how we
can validate and give proper validation
and proper control on the fields that we
have for each object all right before we
move on and explore more annotations
first let's see something or a property
which is really important and let's see
here we have first name and then we have
a message must not be empty so this
message is the default message coming
from the spring boot starter validator
and then what we need to do or what we
can do we can customize this message so
instead of having first name must not be
empty we can set our proper or our
custom error message so let me show you
how we can do that so here on the
student dto level where we have the not
empty annotation here we have a property
called message and as you can see here
by default it's just carta. validation.
constraints.
empty. message but we can provide our
own proper message and here for example
let's say first name should not be empty
and this should not be empty and this
message will be returned to the user
also I can copy that and add this
message to the last name and here I will
say instead of first name I will just
say last name so now let's restart the
application and see the impact or how
this is going to be displayed on our
postm now all I need to do is to click
on send again and here we see we have
first name should not be empty and last
name should not be empty and in this
case we can even enhance a bit a little
bit the code that we created so we no
longer need to expose the field name
that we have in our back end all right
so let's go ahead maybe UND do this or
we can just for now leave it as it is
because I will show you a better way how
to validate objects so now we can move
on and explore the rest of the
annotations that we can use to validate
the different type of objects and the
its different boundaries so in the
project if you go to external libraries
and then scroll down it's almost in the
middle and you will see a dependency
called Jakarta validation so this is the
dependency that we added already in the
pom.xml file and then if you if you
expand this one you will see a package
called Jakarta validation and then you
have a sub package called constraints
and here we we see the list of all the
annotations that we can use to validate
fields in a class and now let's walk
through these annotations and see what
are the use cases for each one so for
example here we have the first one
assert fals and and from the
documentation the annotated element must
be false and the same for us or true
this means that the annotated element
must be true for example if you have a
Boolean field and you want to add the
validation that this Boolean field
should be true or false you can use The
annotation assert true or assert false
now we let's move on to the decimal Max
and this one this annotated element must
be a number whose value must be lower or
equal to the specified maximum so if you
want for example that a field or a value
should not pass the value equals 100 for
example you can use the decimal Max and
give it the value 100 and then the
validation will take care of the rest
and make sure that the value we that the
value we receive should not go beyond
100 and the same for the decimal Min so
this will check and validate if this
decimal or if the value should not be
under that value we specified and here
also you need to check the supporter
types so here we have so for the B
decimal Max and decimal mins so we have
it applies to Big decimal big integers
Char sequence bite short in long and
their perspective wrappers so wrappers
means the integer class and the long
with with uh an uppercase or a capital L
and so and so forth the next one we have
digits so this annotation the annotated
element must be number within accepted
range so here we have a message group
and we have fraction and we have a list
of properties that we can specify when
we use this annotation and the next one
is email so as the name mention so this
one it will make sure that an email
address or string email address should
be well formed and here we have by
default or we have a default rejects for
the email so this is the one provided
already by the Jakarta validation but if
you want to provide your own email
formatting rejects just use the the
property called rejects p and you will
be able to format or to give the rejects
for your email then we have the future
annotation so this annotation is a
appliable to all the date types as you
can see here so here this annotated
element must be an instant date or time
in the future so when for example when
you have a field date let's say for
example uh event or event date or
something like that and we want to make
sure that this event date should be in
the future we can annotate this field
with the future annotation and then of
course the spring boot starter validator
will take care of the rest so also if we
want the DAT to be future or present we
can use this future or present
annotation to validate that then we have
the Max and Min so the Max and Min so
this annotated element must be a number
whose value must be lower or equal to
the specified maximum and the same for
the minimum and here we see also the
list of the supported types then if we
want a value to be negative or you need
to do is to an annotate the field with
the negative annotation so this
annotated the annotated element must be
a strictly negative number for example
zero is considered as an valid value so
it will should be or the value should be
lower than or strictly lower than zero
and then we have if we want to accept
zero values for example we have The
annotation negative or zero and it will
do the same except that that this
annotation accepts the zero value then
we have the not blank annotation so this
annotated element must be not null and
must contain at least one nonwhite space
character so this is important so for
example if I pass a white space and I
use the not blank annotation to validate
the field so this will throw a
validation exception as we saw before so
here we have the not empty and the not
empty we already used and we saw in
action so this will just ensure that the
element must not be null or empty but it
accepts white spaces and then we have
the not null so for the not null it just
checks that if the value or if the
element must not be null and then we
also of course have the null so since we
have the not null we have also the null
so this checks or um specify uh that the
annotated element must be a null Val
value and here it says accepts any type
so we can use this null or not null on
any type so then we have we go back
again to the to the date annotations so
here it's exactly the same as future and
uh and future or present we have also
past or past or present so for example
past we can apply it to date of births
to uh a date that we wanted to be in the
past also we have the past or present
where we can use this annotation to make
sure that the date should be in the past
or we also accept a present date so
present date means today's date then we
have the pattern annotation so this
pattern annotation is appliable on
annotated uh or a field of type chge
sequence must be a match for the
specified regular expression so here we
have like 100% freedom to specify the
regular expression that we want to to to
use it to validate the this field and
then we have positive so this ensures
that the the annotated element must be a
strictly positive number so zero is Al
also considered as an invalid value so
here you need to know exactly the
difference between for example positive
and positive or zero so pos positive or
zero just the difference that it accepts
zero and finally we have the size
annotation so the annotated element size
must be between the specified boundaries
and for example here if I have a string
and I want the size or the length of
that string to be between a minimum and
a maximum value all I need to do is to
use the size and then specify the minan
and the max values so these are the the
all the annotations or all the
validation annotations that we can use
also we can create custom annotations
but this we might cover in the future
lesson for now let's move on and let me
show you how to validate or like how
like it's a proper way to validate
objects all right so now we implemented
or we are almost done with the
implementation of our rest API we also
organized the code we added the
validation we are the mapping our code
is well organized and each part and each
domain is in uh is in its own package
and everything is all right also we test
the application and the application is
working fine but the question is are we
done with this implementation so let me
give you the answer so the answer is no
because we are missing really a crucial
part and a critical part of the
application which is testing yep exact
it's all about testing because why we
need test because for example if I do a
small change in one of the domains that
we have what are my guarantees to say
that this change won't impact anything
else so software testing is a crucial
process in the realm of software
development designed to identify and
rectify defects errors and
inconsistencies with a software
application it serves as a quality
assurance mechanism ensuring that the
software performs as intended and meets
the requirements and expectations of
both developers and and users through a
systematic and a structured approach
software testing evaluates various
aspects of programs functionality
usability security and performance so
then in the next part first we will see
what is the importance and how spring is
going to help us for testing and after
that we will try and we will do testing
and we will see software testing in
action so we will implement the three
parts of Tes testing so unit testing
integration testing and endtoend testing
so stick with me and I'm really happy
you reach this part and let's go
ahead implementing tests for a spring
boot application is important for
several reasons first we talk about
quality assurance so tests help ensure
that your application functions as a
expected they identify bugs error and
expected Behavior early in the
development process allowing you to fix
issues before they reach production and
then regression testing as you make
changes or add new features to your
application tests act as a safety net to
the catch regressions they ensure that
existing functionality continues to work
as intended even after code changes also
test serves as documentation for your
code base they provide examples of how
your code should be used and demonstrate
its expected Behavior this is especially
helpful for other developers who may
join the project later on also a well
written tests encourage good coding
practices and modular design they often
lead to the more modular Lo L coupled
code that is easier to maintain and
refactor when you want to refactor or
optimize your code tests provide a
safety net they allow you to make
changes with the confidence that you'll
immediately know if something
breaks also the test facilitate
collaboration among developers when
multiple team members are working on the
same codebase tests ensure that changes
made by one developer don't negatively
impact the work of others also in a cicd
pipeline or like continuous integration
continuous deployment pipeline tests are
run automatically whenever new code is
pushed this helps catch issues early in
the development process and prevents
faulty code from reaching
production also wrting tests can take
more time up front but it can
significantly reduce the time spent on
debugging later in the development
process it's much easier to identify the
root cause of a failure when you have a
well- defined
tests as your application grows the
complexity also increases tests provide
a safety net that allows you to
confidently make changes and add
features without introducing unexpected
issues and finally
of course tests certain types of tests
like security and vulnerability tests
help identify potential security
weaknesses in your application this is
crucial for protecting sensitive data
and ensuring the overall security of
your application so generally speaking
in a Springwood application you can
Implement various types of tests
including unit tests integration tests
and even endtoend tests so each type of
test focuses on a specific aspect of
your application's functionality and
provides a comprehensive safety net to
ensure its reliability and
correctness now let's see how spring can
help us in implementing the test and
what spring provides exactly so first
spring provides utilities and
annotations for testing applications so
the test support is provided by two
modules the spring boot test contains
core items and the spring boot test Auto
configure supports Auto configuration
for
testing and then we have also the spr
spring boot starter test which Imports
the following modules first of all we
have the spring boot test module we have
also junit assertj hum Crest and number
of other useful
libraries so a springbot application is
a spring application context and this I
will explain it more in details when we
go to the practice
part so the spring boot provides a
spring boot test annotation when you
need spring boot features during test so
for example if you want to load the
application context in your tests all
you need to do is to annotate your class
with the spring boot test
annotation and then in case you are
using junit 4 you need to add the The
annotation run with spring runner. class
to your test otherwise The annotation
will be
ignored other than that if you are using
junit 5 there is no need to add the
equivalent extend with spring extension
as the spring boot test annotation and
the other annotations will be already
annotated within the at Spring boot test
so now we mentioned that spring comes
with a spring uh spring test Auto
configuration module so the spring boots
Auto configuration system works well for
applications but can sometime be a
little too much for tests so it often
helps to load only the parts of the
configuration that are required to test
a slice of your application so the
spring boot test autoconfigure module
includes a number of annotations that
can be used to automatically configure
such slices and finally each slice
restricts component scan to appropriate
component and loads a very restricted
set of autoconfiguration classes now we
are done with the theoretic part this
might be a little bit too much or like
too much talking now we will move to the
practice part and you will be able to
understand and start implementing tests
your own so let's move on and let's go
ahead and do it all right now let's dive
into the implementation of tests for our
different classes so here this is the
diagram or the composition or the class
diagram of our small application and I'm
focusing only on the student domain so
here we see from the bottom to the top
we have the student composed of the
student service this means that the
student controller uses the student
service and the student service use both
uh of student repository and student
mapper and the student mapper will use
both object student and Student Response
dto so now I want to tell you and
explain to you what you need to
implement test for so what do you need
to test which classes and which objects
you need to implement tests for so here
we see that the Student Response D and
the student object they are just classes
so there is no logic inside it so it's
just a class holding some information
about the student and this class or this
record is only holding some information
about the Student Response dto now if we
go a level down we see that we have the
student mapper and then we have the
student repository so the student
repository we can also Implement test
for that but it doesn't make sense or
it's not really required to implement
tests for repository so we will skip
this one now let's start with the
student mapper so the student mapper
right here so if we go to the navigation
or if we navigate to the student mapper
right here to this class class we see
that we have two methods all right so
now I want you to change a little bit
your mindset and suppose that you don't
know the code before so you just have a
mission or you're asked just to
implement tests for these classes so
here we have two methods to student and
to Student Response dto so the first one
will return student object and the
second one will return a student
response dto so normally from the name
of the method we can understand what is
its functionality otherwise we can go
ahead and read the code so we don't need
that because we already implemented this
our own and now what we need to do is to
create a test class for this student
mapper so to create a student mapper
test class let's start with the
recommendation so here we see that we
have the Java and this is the base
package that we have which is com. al.
example and then we have school and
student and student profile and so and
so forth forth here if we check the test
we have also Java and then com. alibu
example and here we have also example
application test which is the same or
like the same loader class or the class
that will load the application context
for our test so for now we will just
ignore this one and I will explain it in
the coming sections all right now the
first recommendation is when you create
a test class for one of the for one of
the services or the CL classes that you
want to test be sure and make sure that
you keep the same package naming so you
you need to keep the same hierarchy of
of packages and folders just to make it
easy to find so you can just create it
anywhere or like even without creating
packages but the recommendation to make
your test classes clean and clear and
easy to understand and easy to point you
just need to keep the same hierarchy or
like the same package hierarchy and we
are lucky because our IDE whether you
are using anj Eclipse net beIN and so on
so forth you always have some shortcuts
and you have the instruction and menu to
generate test classes for the class that
you want to test so here if I open back
my test student or like my student
mapper class and I want to generate a
test class for it so if I do like um
right click and then let's click on
generate right here so here we see that
we have many options and among these
options we have test so if I click on
test you will see that it will be it
will be generating a student mapper and
then it will have or it will give it a
suffix called test all right and here
you see the destination package it will
be com. al. example. student you can
select a different one or you can change
the name and so on so forth but as I
mentioned before I recommend you keep
the same the same hierarchy and then you
also can generate methods for setup tear
down or also showing the inherited
methods and even you can generate two
methods or like two test methods for the
two student and two Student Response dto
but for now we won't do that we will do
it one by one and step by step so I will
cancel then we have a different option
so here just um focus on this area you
will have this green popup to show you
which uh command or which shortcut or
keyboard shortcut that I will be using
in order to navigate to the test so here
if you do uh command shift t or Control
Plus shift plus T if you are using
Windows or Mac anj will try
automatically to navigate you to the
test class of this student mapper all
right but if it can't find any test
class it will suggest you to create a
new one so it will also open and display
the same window that we use before or
that we saw together before and here for
the testing Library since we are using
Java like recent version of java and
also like a recent version of spring
boot so we we can keep or we can use the
junit 5 also if you have another project
uh using junit 4 for example I already
explained that before that you need to
add few annotations or like one
annotation in order to make it work so
now all we need to do is to click on
okay button and here you see see that
automatically a new package was created
and it contains a new student mapper
class test all right so now we have
everything ready let's go ahead and
start implementing or let's start
writing the first test method that we
have for our student mapper
class all right so first of all let's
generate a first test method to create a
test method all you need to do is to
create a public void so this is this
signature and it should be always public
void and then the method name so let's
call it test method one so this this
will be the first test method and the
test method is a method without any
parameters so here to make this test
method as a test method so all we need
to do is to add The annotation test so
the test it comes from org. gun.
jupiter. API so here once we are this
test you see automatically that now we
have this button to run this single
method or you have this button right
here to to run all the test methods
inside this class so let's first of all
just add a system.out do print Ln and
here my first test method and now let's
run this test class using this play
button to run only this method since we
have only one or if we want we can run
the whole test so let's run student
mapper test class and then you will see
that it will open the test View and here
we have the
system.out.println the message that we
printed my first test method and the
test was green since we have nothing to
assert yet we will come to this in few
moments but before that we need to
understand what are the properties and
what are the things that we can do
within a test class so the first thing
that we need to know is that we have a
setup method or we can create a setup
method so if you click on generate here
you will see that you have a setup
method you can generate it automatically
or you can even write it your own so
let's generate it and see what it what
is this method so it's just a void
called setup and it contains an
annotation called before each so this
means that this before each method or
this setup method will be executed
before each test that we have and we
mainly use this setup in order to
initialize few things or few parameters
or anything that we want to initialize
before running any test method that we
have so I will just copy this message
right here and here I will just write
inside before each method and now if I
run again my
class let's see what will be the output
so here we have have if I click in here
we have inside the before each method
and then my first test class so now I
will just duplicate this method right
here and I will call it my test method
two and here I will say my second test
Method All right so I will rerun again
the
class and here we see that this one we
have inside the before each method my
first test and here we have also inside
the before each method and then my
second test so as I mentioned this
before each will be executed before each
test class so in case as I mentioned
before in case we want to initialize
anything before running the test Method
All right so also as before each we have
other methods and let's go ahead and
explore them one by one in order to
understand the structure of a test class
and what are the usages and the benefits
of using this methods all right also if
we want to execute any script for
example to reset the values of variables
or classes or services or whatever we
also have a method we call it tear down
so the tear down is after each execution
of test method so here let's use the
generate again and here we see that we
have the tear down method so let's
generate it and here you see after each
so let's copy this same message and here
inside the after each method when we run
the test class we will see inside before
each method and then my first test
method and finally inside after each
method so let's go ahead and execute it
and see the output of this execution so
now I'm going to select the first method
and as I mentioned we see inside before
each my first test and then inside after
each so as I mentioned before in case
you want to reinitialize or for example
to change the value of a specific
attribute or for example if you are
running your test against database so
you can just initialize and insert some
data in the before each and after each
you can delete them or re-update the
data in order to be able to use them in
in the next Method All right so now
let's move on and let's see what are the
other methods other than the before each
and after each all right now the
question is what if I want to execute a
setup or to initialize a few attributes
and variables only before the execution
of the the whole class so I don't want
to run this method before each method
but I just want want it to be executed
only once so in this case we have also
another method so let's click on
generate and here we see we have a
before class so when I use a before
class so it's called a before all again
I will copy this message and here I will
say inside the before all method so now
when I run my test so you can whether
run it from here or again click on this
play button or just run one of the tests
so let's go ahead and run and rerun the
whole class and see what we have so for
example let's select this one so here we
have first when we select the method we
see only this three output messages
which is the before each the method and
then the after all but when I select the
class we see that we we are inside the
before all methods and then inside the
before each method and the after each
method and we have it again for the
second method so now just I want to make
this output clear so I will be running
only one method so like that you will
see it in a better way so now we see
that we are inside the before all method
and then inside the before each my first
method and then inside the after all
method so this is the case if I want to
initialize something a service for
example or to create a new instance of
an instance or an array list uh or
something like that but I just want it
to I want to do it only one time I don't
want to do it each time so in this case
we need or we use the before all method
so now in the same way we have another
method called after all so let's go
ahead and try this one and then let's
move to the real implementation of the
real test cases of our student mapper
class all right in the same way let's
generate an after class or an after all
method and again I will just copy paste
and here inside the after all method so
if I run one of the test classes or the
test methods that we have and here let's
go ahead and check the output so here we
have inside the before all and then
inside the after all and in between we
have the before each the the test method
and the after each so the use case of
the after all and the before all is for
example I want to initialize or insert
some data into my database in case we
are using for example an inmemory
database so I want to insert some data
and then once I'm done I want to remove
them for example or even if I'm working
against my Dev environment uh database
or something like that so in this in
this way we can initialize data work
with them and once we are done we can
remove all the data that we already
inserted so in this in this way we are
safe from polluting and inserting wrong
data into our database all right so now
you know the structure of a test class
what are the methods that we can use
within a test class so now let's go
ahead and start and implementing few
test cases for our student mapper
class all right now let's start
implementing our tests first of all
let's start by cleaning up all this code
so let's remove it and also let's
reoptimize the Imports and now let's
implement the first method so here just
to remind you we have our student mapper
class that performs a mapping so it
transforms a student dto to a student
object object and then we have to
Student Response and it transforms a
student to a student response dto so now
coming back to our student mapper test
so here the first thing that you need to
do is to declare the service that you
want to test so here we want to test our
student mapper so let's create an object
of type student mapper and then let's
call it mapper for example and then the
first method or like the first use case
or the test case that we want to
implement is that we want to make sure
that these two student mapper performs a
correct mapping from student dto to the
student object so here let's create our
first method public void and let's call
it should map student dto to student
class all right so this is our first
method and to make it a test method we
need to add always the test annotation
so the then you see that this student
mapper right here is not yet
instantiated so we don't have an
instance or an object of type student
MPP so it's just the variable or the
field so now we have two options whether
to initialize it in here so we can do
new student mapper or we can use one of
the test of of the setup methods so here
we can add a before each and then we can
move this part right here to this setup
method so we can make it this way or the
other way around so let's go ahead with
the before each so now we have our
mapper object initialized and now let's
start creating and implementing our
first test method so here the first
thing that we need to do we need to
create an object of type student dto
since this is the input of our two
student method so now let's go ahead and
do it so here we have an object of type
student dto let's call it dto equals new
student dto and for this let's call it
John and then for the last name let's
call it
do and we have an email so John mail.com
for example and then we have an INT the
school ID so in this way so I'm going to
just inline this one so in this way we
have our student object so after that
all we need to do is to call the to
student method so here let's create an
object of type
student and let's call it student equals
our mapper DOT to student and then we
pass the student dto and then we will
start asserting that the output of this
mapping method is what we expect so here
let's go back to this two student method
and we know that we when we call this
student method we just set these fields
and then we have an object of type
school so again we can test so what we
want to focus on is that we have also a
mapping for this school object and that
we have all the fields not changed so
now let's first start by asserting and
in order to assert so here we have
assert equals and this assert equals so
it comes from assertions so the
assertions is from the package org. gun.
jupiter. api. assert equals and here for
the assert equals we have multiple
implementation so we can assert equals
shorts bytes uh strings integers and so
and so forth so here let's do assert
equals and then what we want to test we
want to make sure that our dto doget
first name to be equals our student
object. getet first name so here we want
to make sure that that this first name
is the same for the class student all
right so now also we can import
statically this assert equals and we can
do that by add static import for the
unit uh Jupiter API assertions do assert
equals so when we do that and when we go
up so you will see right here that we
have a static import for that method so
the next time you see assert equals or
any static usage of a method so you know
that it's statically imported in here
all right so now let's continue the
assertion and here we have the first
name let's also test the last name and
here get last name and after that we
have the email and also here get email
and finally we want to make sure that
this the school is not null so here for
example we have the assert not null so
as you can see here so I want to assert
not null that my student student. getet
school is not null all right so then we
can also make sure that the school ID
was correctly set so what I can do we
can assert equals so our dto do school
ID is the same as student. getet
school.get ID so at this level we are
safe because we have an assertion that
the school is not null but if if we
change the order we might encounter a
null pointer exception in case this
school is not correctly mapped so now
let's just go ahead and run this test
method and let me show you what is the
impact and the execution of this method
so here we see that the method was green
but now you might ask the question I'm
just making sure that this object that I
created manually is the same as I called
this method so now let's go to our
student and for example Le let's say
that I forgot to set the school to the
student object and now if I go back and
rerun again the test let's see what will
happen so here we have a test failed so
here we see that expected not null but
the object was null at this point so
here you see that assert not null of the
school so this means that the school was
null and I'm expecting the school to be
not null so now step by step you see the
importance of having unit tests within
our application so let's go back to the
mapper and let's bring this back and
then for example let's say when I
transform the first name or the last
name I just I just do to
uppercase all right so I transform the
first name to an uppercase if I rerun
the test
again you will see that the test will
fail and here we see this message so
here we have assertion failed error and
the expected was John which is the
object right here that we initialized
with with our dto and the output was
drawn with an uppercase so this is also
another or a different assertion level
or an assertion test that we make sure
that the input should be exactly the
same as the expected output all right so
now let's go back to our mapper and
let's just remove this one and in case
for example you have changed the
implementation of these two student
method you need also to update the test
okay so in this case you make sure that
everything works fine so let's run the
test one more time and make sure that
everything works fine so our test is
green now we can move on and Implement
other tests all right so now since you
know and you understood how to implement
tests so I want to give you a small
exercise I want you to implement the
test method for for testing these two
Student Response dto and it should take
a student object and then return a
student response dto so you can also
Inspire and follow the same example we
did right here I want you to create
another method and you call it should
map student to Student Response dto so I
will let you do it and I will provide
you the correction in the next lecture
that's good I was sure that you will
implement it correctly so let's do it
together all right so first of all we
need to create a public void method and
then let's call it should
map a student or student to Student
Response dto all right and then
parentheses and then the brackets and
don't forget the test annotation all
right so the first thing as we did
before we need to create an object of
type student all right so here go
student student calls new student and
then let's initialize our student object
so here let's say Jane as a first name
and then Smith as a last name and then
let's provide an email so Jan
mail.com and then we need an age let's
say for example it's 20 and let me
inline this all right so now we have our
student then all we need to do is to
create an object of Student Response dto
and let's call it response equals our
mapper and then to Student Response T
and we need to pass our student all
right now comes the assertion part so
the first thing we need to do is to
assert first name last name and email
and make sure that the result is the
same since within our Student Response
dto we only have three attributes all
right so now let's say assert equals and
then I want my response. first name to
be the same as my student. getet first
name the same for last name so here last
name and then get last name the same for
the age I want the age to be the same as
the student. get
H uh sorry we don't have an H for the
response dto but it's email and here it
should be the same as get email all
right so now let me add a few comments
so here how how we can read the test so
here we have given a student object and
then when we map the student to a
Student Response dto then I want or I
expect this result so now let's go ahead
and run the test and make sure that
everything works fine and we did not
forget anything so the test is green
Also let's go ahead and run the whole
class and here we have all the tests are
green and passing okay so that's it
let's move on and let me talk to you
about something really really important
when you implement an application and
mainly you can detect that with the
tests all right now let me talk to you
about something else so here I will just
start by creating a new test method and
after this method I will just create a
method called public void and then this
is also a different way of writing the
the method name so we can write it in
this way should map student dto to
student object all right but this new
method I want to add if or let's make it
when student dto is null so this means I
want the mapping to be or to perform
correctly or in an expected way even if
the student dto that I'm passing right
here here is null so what I will be
doing I will just copy this part right
here and then paste it in this method
and instead of passing the dto I will
pass a null object so here what I will
be doing let's say for example so we
will change this later on but let's
start expecting this so here let's say
an empty string and here empty string
all right now if I run this test method
let's make it a test and if I run this
test method let's see what will
happen so here we have a null pointer
exception cannot invoke the student dto
do first name because dto is
null all right and the exception
happened inside the mapper itself so if
I click here we see that the the problem
is exactly in here because we are trying
to get the first name from a null object
and here we mainly talk about code
coverage so we need to cover all the use
cases that our method and our service
class and our class generally speaking
should handle so here you see and you
noticed that we did not handle the case
when we pass null dto object so in this
case what we need to do we need to go
back to our student mapper and then we
need to add a test or a check or do
whatever just to make sure that when we
receive null object we want to do
something whether raise an exception or
just printing a message or even for
example initializing an empty student
object with for example let's say empty
values so the implementation always
depends on the requirements of of your
story or of the application that you are
implementing so now let's go ahead and
start doing this so in this case or in
this use case we will see many things so
the first thing let's go back to to to
student and here I want to do if my dto
is null for example I want to throw a n
pointer exception all right so here we
need the new keyword so a new n pointer
exception and here the student for
example as a message the student dto is
null all right so now we add we added a
coverage to our method so now let's go
back to the test and make sure to to
readjust the test right here in order to
make sure that this student method
should throw a null pointer exception
when we get a n dto student so we don't
need this one since we don't have any
assertions and now let's just rename
this method to make it more relevant and
here instead of should map so let's say
should throw and then a null pointer
exception when student dto is null so
now we have this mapper do to student
and then we are assigning it to a
student so we can also remove this
assignment since we know that it will
throw an exception and it will return
nothing so now how can how can I expect
or make sure that these two student is
going to throw a null pointer exception
so in order to do that all I need to do
I need to assert that this method is
going to throw a null pointer exception
so I'm just going to remove it and now
I'm going to use assert throws so here
this throws method first of all it gets
the expected type so in our case it's a
null pointer exception. class and then
it's a Lambda expression so here when we
call the mapper do2 student I'm
expecting to have null pointer
exception. class thrown so let's run
this method and make sure that it passes
green right now so now this method is
throwing this exception so now what if I
want to check the message that the
message should be the student dto is
null or should not be null so here let's
just rename it should not be null and
I'm going to copy this message and now I
will go back here so in order to do that
all I need to do let's create a VAR
message equals this so as you can see
this a assert throws it will return the
exception itself all right so now if I
do MSG Dot and here here I have access
to the method get message from the NP
pointer exception or from the exception
generally speaking so now I want to do
assert equals I want this error message
to be equal to my message or exception.
getet message so let's just rename this
one to exp to say it's an exception so
exp for exception and now if I run again
let we need to be sure that the the
method through this exactly the correct
error message so here for example if I
add a DOT and run again the method
should
fail and as you can see now the method
failed and the assertion failure is we
are expecting this but we got this one
so in this case we gained two things the
first one is that we add a coverage to
our two student method and then we also
covered this with within the test so for
example in case I want to change from
null pointer exception to a different
exception it will be automatically
detected by this test method again if I
change for example the exception message
it will be also automatically detected
so now let me run it again and make it
green and now we added a new coverage to
our method so this is how you can test
exceptions and this is how you can catch
exceptions and make sure or you can do
whatever you want even if you work with
custom exceptions that you create your
own you can also capture that and do
whatever you need to assert everything
is as expected all right so now let's
move on to the next part all right so we
finished the implementation of the
student mapper and we saw how we can
create a test class how we can create
test methods also we saw how we can or
how how much we need to cover our code
like we need to cover all all the use
cases now let's move and start testing
or writing tests for our student service
so we know that this student service is
a spring component and it has a strong
dependency with student mapper and the
student repository and especially when
we talk about student repository we talk
about communicating with database so
when it comes to testing how can we test
and how can we tell spring or this
student service that we have a student
repository and this one needs to
communicate with the database and what
happens in case we don't have a real
database for testing because testing it
does not necessar necessarily need to
have a database for testing so that's
why we will talk about test isolation so
test isolation means that we want to run
and to write tests for this student
service in isolation of its dependencies
in a different way I want to execute and
write test for this student service but
I don't necessarily need to have the
real instance and the real object of my
student repository the same for my
student mapper so what do I need to do I
need to mock these two objects so to do
that we have there is a framework called
mokito so mokito is a popular Java test
in framework that helps you create mock
objects and stab behaviors when writing
unit tests so it's especially useful
when you want to isolate a specific
component of your code and test it in
isolation from its dependencies so now
we know what we need to do we need to
isolate and we need to mock so you need
to remember this term we need to mock
our objects we need to mock the student
repository and the student mapper to be
a able to run the student service test
in an isolated way so let's go ahead and
let me show you how we can isolate and
how we can marck the objects and the
methods for each service that we have
right here so now as always the next
step is we need to go and create a test
class for our student service so all I
need to do navigate here and then
command shift T and create a new test so
here we don't need any of these
we just maybe need or use the setup
method so I will just check it out and
then click on okay so here we have our
before each and we have our student
service test class so as we did for the
student mapper what we need to do here
first of all which service that we we
want to test so in this case we want to
test our student service so I will
create an object of student service and
I will call it student service and then
when it comes to objects that have
dependencies let's check in here so we
see that our student service has two
dependencies that we need to inject all
right so our Constructor is a
Constructor with parameter and it
requires an object of type repository
and an object of type student mapper so
let's just go ahead and do that I'm just
going to copy this one and and in here
declare the dependencies all right I'm
going to paste this and then I will just
fix the code all right so now I have my
service and I have the dependencies so
what I need to do so we said that in
order to run the student service in an
isolated way what we need to do we need
to marck this student repository and the
student mapper so what we need to do
there is an annotation called mock
so this mock annotation comes from or.
mokito it's not the one coming from the
or. spring framework we want to use the
mock from org. mokito so let's select it
one and the same we need to add it to
our student mapper so in this in this
way we are telling our test class and
the mokito framework that we want to
create mock for this repository and a
mock for this student mapper all right
now how can we tell this mocking
framework that we want to inject these
two properties and these two
dependencies into this service right
here so the answer is kind of
straightforward because I just mentioned
injecting so we have an annotation
called inject MOX so inject MOX always
is coming from the or. moku package and
like this our mocking framework will try
to find any dependencies annotated with
the mock annotation that is compatible
with the dependencies that are required
from our student service so this means
when we try to create an instance or to
initialize this student service the
mocking framework will look for two
object annotated with the mock
annotation and that are of type one of
them is of type repository and the
second one is of type student maper
all right so now we prepared everything
we still need to do one more step so
then what we need to do we need to tell
the moito framework that we want to open
the mock or like we want to start the
mock for this current class so this
means that in the before each here what
we need to do we need to use the moito
annotations class doop Mox and this open
MOX takes an object which is the test
class as you can see right here so let's
give it this because we want to open the
mock for the current class all right so
may you might see this warning right
here this is because the open mock
methods return and autoc closable so and
this the anj or your IDE will recommend
to you that you might need to you might
want to use a try with resource but we
can ignore that for the moment it's not
something really important or really
really uh going to break our test all
right so now we set up our test class
now let's move on and implement the
first test method that will allow us to
save a student so the first one it will
be this save
student that's good now let's analyze
our save student so we have here first
of all we are doing a mapping and then
saving the repository and then again we
are doing a second mapping P so this is
what we need to test in our test method
so let's go back to our student service
test and here I will create a public
void and then should successfully save a
student all right so this is our test
method let's not forget the test
annotation and now here let's remember
the given when and then so here given
what so here in our save method we have
a student D so let's first of all all
create a student dto object so let's go
back here and here I have first of all
my student dto object also this class is
going to need an object of type student
which is this one so let's also go ahead
and prepare our student so it will be
almost the same so just copy the
signature right here and here I will
create an object of type student let's
call it student equals and then new
student all right here let's remove this
one all right here we have also our
student object and our student dto so
what we want to do or like how this is
going to work this means is when we call
our student service do saave student we
are expecting an object of type Student
Response dto all right so here I will
create an object of type Student
Response dto I will call it response dto
equals our student service do save
student and then we have a dto so this
is the dto that we will pass as a
parameter and then what we need to do is
to start asserting so let's say assert
equals and then we have our dto object.
getet first name should be equal our
response dto do get first name all right
let's do the same also for the last name
and also the email so we can stick just
to these few fields we don't need to
test everything so this is what we want
to test so now if I run the test what
should happen so let's go ahead and
check together so I will run this test
method and let's see what will be the
output here we see that we have a null
pointer exception saying that we cannot
invoke Student Response do get first
name because the response is null and
this this is happening in here so this
means what I'm going to just add a break
point right here and I will run again
this test in debug
mode so here let's see our student
service so we have an object since it's
already mocked the same for our
repository so we as you can see we have
a moito Interceptor and so and so forth
so now if I evaluate this expression and
then evaluate expression and then
evaluate we see that the result is null
okay so let me explain to you why we
have this null result so this null
result is because the student service is
trying to call the student mapper and
then we have the student repository is
also going to call the save method but
remember here we have a mock so we don't
have the real instance or the real
service running for our test because we
decided to run our student service in
isolation mode so to do that what we
need to do here we need to mock the
calls so which calls that we need to
mock we need to mock every call that
uses another service or another
dependency in our student service and in
this case we have the student mapper and
we have the repository do saave so let
me show you now how we can mock these
calls so the first thing that we need to
mock is the as you can see here the
first thing that we that we do is the
mapping so let's mock the mapping all
right so now in order to mock the calls
so the first thing that we need to mock
is our two student so student mapper do
two student method so this comes from
moito we have a static method called
when so this means when we call a method
so we have as a parameter the method to
call so here we have student mapper do
to student so when we call these two
students with our dto object so make
sure that the mock will work only if we
pass this object right here so then what
we want to do then we have so many
options so we can return we can return
with a student we can also a student and
a list of other students we can return
an answer or we can even throw an
exception so in our case we want to
return an object which is our student
right here so let's return the student
and now we are done with the first mock
of our student mapper do to student
method so here when we say when we are
mocking a method all right so this when
we call the student mapper do2 student
dto then we need to return the student
object so this means that our student
service will run in isolation mode and
it does not 100% depend on the real
implementation or the uh not the real
implementation but the real instance of
the student mapper so also let's import
this in statically so when student
mapper then return all right so let's do
the same for our repository so when our
repository dot save and then student
then return our student itself all right
because we know that when we save a
student we return another student or if
you want to be more consistent or if you
want to have like more uh details you
can even create another student object
you can call it like saved student and
set the ID and set everything and also
you can return that one so let's just do
it it's it's totally fine so I will call
it saved student and then I will just do
saved student. set ID and let's give it
the ID number one and in here I will
return our saved student all right so
now we have three objects so first we
have the dto and then the student that
will come from the mapping and now this
is the student that should be saved in
the database so now again we mocked the
second call which is our repository so
if we go back in here we still need to
return another call so here we need to
mock also the student mapper do to
Student Response dto so in order to do
that just in the same way so here we
have when we call our student mapper do
to response dto of our student object
which one which is the saved student all
right so here we have then return let's
now just return a new student response
dto and all we need to do is to pass the
first name last name and email so this
is the first name last name and email so
let's let's just copy them from here so
we have our John do I'm also going to
inline this so you can see the full code
and the email is just John email.com all
right so now we have our test set and
ready so let's go ahead and run the test
right now and see the output so I'm just
going to click and run this one and
let's see what will happen so now our
test is green so we have all the
expectations and everything was running
in a successful way because we have here
we mocked everything and in case for
example I just change anything or you
forget to uh to mock a step your test
will
fail that's good now we created our
first test method and we saw how we can
mock objects and also do some assertions
so this is the classic assertions but
now what if we ask the question how can
I check that my application is
performing well so here for example in
this save student I want to make sure
that I only save one time the student
into the database this means for example
I don't want to have some error or like
someone typing two or three times this
repository. saave because this will save
the student many times and in case for
example you have a un constraint it
might throw an exception and this will
break the application so let me show you
how we can prevent this from happening
so if I go back to my student service
right here we can do this in the same
place since we have our code already set
up all right so here we are
mocking and now what I want to do I want
to make sure that this student mapper2
student was called only one time same
for the repository and the same for this
one all right so to do that mokito also
provides us with a method called verify
as you can see here so we want to verify
and then we need to to type the mock
object so our mock object is the class
or the instance itself and then we can
pass a parameter so it's a verification
mode so here we have okito do times also
we have out we have so many other
options I can for example check that a
method call should take only just just
as an example should take only 2 seconds
maximum to be executed if it goes beyond
2 seconds the test will fail and like
that I can also make sure that I have
performance issues with my application
all right so now let's continue with
this times so I want to be sure that
this student mapper dot to
student and then the object student dto
or the dto object that we created it has
been called only one time all right so
let's do the same for
repository and then times one and then
the save method when we pass the student
object again I will do I will duplicate
this one and here student mapper and
then to response dto or to Student
Response dto and here just to make sure
that we passed the saved student as an
object all right so here we need to say
saved student all right I'm just going
to align these methods right here just
so you can see everything so here verify
that this method or these three methods
of the different Services were called
only one time so let's go ahead and run
the method again so run this and then
the test passed so now let's suppose for
example that one of the developers or me
for example as also as a developer of
this application I accidentally forgot
to remove this extra line all right so
now if I rerun the test again let's see
what will happen so the test will fail
and we will see here that wanted one
time so this means that we wanted to
have our call only one time but it was
called two times and here so as you can
see here you have student service. save
student that was called two times all
right and it was pointing to here and
then to here so here we see that even
the test will point us directly where
the issue has happened all right so
that's good now let's move on and let me
give you a small exercise and I'm pretty
sure sure that you will be implementing
it really easy without any issues now
let me give you an exercise I want you
to implement the test for these find all
students so it needs to cover and to
make sure that when you make a call to
this repository. find all it should
return the exact same list that you
already expect and in the next lecture I
will show you how to fix this one all
right that's good I'm sure that you
correctly implemented the test for this
find all students but also let's go
ahead and do it together so I will
create as usual a public void and then I
will call it
should return all students and then we
have the given so for the given the
first thing that we need to do is to
create a list so let's create a list of
students so this is the object that will
be be returned so let's call it students
equals new array list and then let's add
one student so student. add and we can
even copy the student from the previous
method right here so I'm just going to
copy this one and I will insert this
student
here all right so now we have one
element
in in our student
list and then we need need to mock the
calls so the first call that we need to
marck is when we call our student
repository or the repository object do
findind
all then I need to return the students
list that we created all right and then
what we need to do we need to marck the
call for the mapping all right so here
we have when mapper or student student
mapper dot to Student Response dto and
here since we might add or pass any
student so we can use the power of moku
and here we have argument matchers do
any and here when we say any we can also
specify the class so when we receive any
class of type student do class then I
want to return for example a new like a
new object of type response Student
Response dto something like that so I'm
just going to inline this so when we
call the student mapper to Student
Response passing any object of type
student we want to return this object we
can also make it more Dynamic but for
the sake of a simple um test case it's
also easy and it's also okay to make it
like this and here we just forgot the
test annotation so we need to add it and
now all we need to do is to have a list
of type Student Response dto and then
let's call it response dto equals our
student
service do find all all right and here
so this is given and now it's when when
we call this one so then so here for
here we do assert equals that our
students list do size to be equal to our
students dto do size or response dto do
size all right so this is the
implementation let's go ahead and run
this method and make sure that
everything is fine all right also should
return all students is green we can also
add an extra test and make sure that for
example this repository. find all was
called only once so let's go ahead and
test it just to make sure always that we
have our application performing really
well so here we have our repository and
then times one and then dot find all to
be called only one time let's rerun
again all right so the the test is still
green so now let's move on and let me
tell you what we will be doing next all
right now I want to give you another
exercise and I want you to implement the
test for this fine student by ID I'm
pretty sure you're going to do it in a
correct way and I will see you in the
correction all right so as usual let's
go back to our student service test.
Java class and the first thing that we
need to do is adding this test
annotation and then creating a public
void and let's call the method should
find student by ID or should return
student by ID all right so here always
the given and here we have an INT
student
ID or an integer let's make it an
integer student ID equals 1 and then
let's create a student object we can
also take it from here so let's call it
student so here we have student student
equals new students and then we have
when so here we need to mock so here we
have when we call our repository. find
by ID
and then we pass our student ID and then
I want to return an optional do off my
student all right and you might ask the
question why I used optional because
this finded by ID is going to return an
optional the second mock that we need to
do we need to marck the two Student
Response D from this from the student
mapper class and to return that one so
from that we can can just copy this one
and then let's paste it in here so here
we have when we make a call to our
student mapper we are going to map this
one and again we can just go up and copy
this assertions so here I will create an
object of type Student Response
dto I will call it dto equals my student
service Dot find by ID and then I will
pass the student ID that I
created and now we have the then so here
we start the assertions so here we have
our the dto do first name should be
exactly the same one as the student.
getet first name so here I will just
copy the student from here and I will
just replace it in here so now we can
select all and here we have get and then
let's make this one uppercase and now
that's it also we can add another check
we want to verify that our repository
has been called one time for the method
find by ID so passing also the student
ID as an object as a uh as a parameter
and now let's go ahead and run this new
test
Method All right so we might miss
something okay so here expected John
example.com but the actual was john.
mail.com so maybe let's fix it so here
we have mail let's change this one also
to mail and let's rerun again and the
test is green and fine all right so that
was it for this method let's move on and
implement the next one that's good you
really made a really good progress and
I'm really proud of you so the next
method that we need to implement the
test for is find student by name and
just I want to give you a quick hint you
can Inspire from the previously
implemented methods in order to
implement it in a correct way so take
your time and I will see you in the next
lecture to provide you the solution for
this exercise all right you did a good
job now let's correct this exercise
together and you might learn learn
something new so as always we need to
add the test annotation and then we have
a public void and let's call the method
should find student by name all right so
then what we need to do the first thing
we can also copy things from what we
have before so I'm going to explain it
one by one so we can copy this part
right here we can also copy this one
right here so here we copi it so also
let's copy it with a given so here the
initialization of the students list and
then we have the mock for the find all
this one we will change later on and
also we need to copy the mapping so
let's go back here and now so when we
call the find student by first name
containing and here I just need also to
declare
a string student name let's call it John
all right so here containing student
name then return the students list and
then when we call the student mapper do
to Student Response dto of any student
object I want also to return this mapped
object or the Student Response dto now
when I call so here let's use VAR just
to make it shorter I I will call it
response dto equals our service do find
all by name and here I need to pass the
student name so then I need to do some
assertions so I want to do assert equals
that the
students do size is equals to our
response dto do size so this is what we
need to do or what we need to check also
we can add a verify that our repository
has been called one time for the method
find all by first name containing our
student name so I'm going to break the
line for this one and now let's run the
test and check the
result all right so the test is green
and our method is correctly implemented
all right that's good so now we still
have only one method in our student
service so let's go ahead and create an
exercise for that and also we will see
the solution together congratulations on
mastering the intricate Dance of the
spring framework you've built a solid
foundation but guess what there's a
whole universe waiting to be explored
the enigmatic realm of spring data jpa
ever wondered how the Pros handle data
persistence in style we're about to
reveal the secrets that will transform
you from a spring Enthusiast to a data
wizard back up for a thrilling right
through repositories relationships and
the Art of querying with finest you've
tasted the sweetness of spring boot
access now let's add the spice of spring
data jpa to your coding Journey get
ready to play play with embedded
entities Master the Nuance of ID
generation and harness the power of
named queries and specifications before
we dive into the nitt gritty don't
forget to subscribe to my YouTube
channel and join our Vibrant Community
elevate your coding skills with Fresh
weekly content delivered straight to
your virtual doorstep all the links are
conveniently waiting for you in the
video description don't miss out the
coding Adventure your seat is already
reserved now that you're locked loaded
and subscribed let's get back to
business spring boot was just the
beginning spring data jpa is the next
Frontier ready to unravel the Mysteries
grab your coding gear hit play and let's
embark on the Epic coding journey
together let's get
started first of all we will start by
setting up our database management
system and and for the purpose of this
uh course I will be using Docker and I
will show you how you can install post
degree SQL or my SQL uh database so you
have multiple choice also if you have
them already installed on your machine
you can skip this part so this part is
only about installing and setting up the
database management system on your
machine so uh first of all make sure
that you have Docker desktop running uh
installed and running and here like when
you open the docker uh dashboard you
will see this green uh part like here or
this green icon so this means that the
engine is running so if it's an orange
uh color means that the engine is
whether is starting or it's not started
so you need to make sure that this is
green and this is all you need to do
okay now let's let's move and uh and St
the docker image for post degree
SQL the command that we need to run is
the following so here we need to use the
command Docker run and then Min D to be
to say we want it to be running uh in
detached mode so we don't want to wait
for it and now we want uh our Docker
image to be persistent or to have a
persistent volume within our system
because as you know every time you start
a Docker image it will it will start
like uh from scratch and it will
consider that nothing uh is persistent
so if you want to have a persistent
Docker volume you need to add this
option minus V it's for volume and now
for the volume first of all you need to
specify the path where you want to store
the the data of uh post-degree SQL and
for example in my case so it will be in
here so I just called it this way it's
my personal project data
slpg uh for post degree and data for
data and then just column here and slash
VAR so here we are trying to map the
volume from our local machine to the
volume that postre SQL will be using
okay so uh it will be /var slash lib
slash postre
SQL SL data so this is the path that
postgre SQL uses to store the data okay
so now we mapped already the the volume
now we can also pass some environment
variable uh and these environment
variables we need them for uh the
username and the password okay so to
pass an environment variable it's like
following it's minus
E and then we have post post
agree underscore username this are
predefined uh environment variable that
postgre SQL will look for and here I
will call it just post agress or post
degree and then Min E I want to pass a
second uh environment variable and this
one it will be a postre
password okay it's a post degree _
password and here I will call it alibu
coding the for the password okay and now
we need to map the port so this means on
which Port we want to run our
application so let's keep it the default
one which is 4
5432 colum
5432 okay so we will be using or we will
be connecting to uh our post degree SQL
on the port
5432 okay so now all all we need to do
now is to precise or to specify the
image name which is in our case like we
said we want to use post agress so it's
going to be
postgress now let's hit the enter button
and see how it will it will
do so here it says that uh unable to
find the image post postig latest
locally so it will be pulling it from uh
Library SLP scale so means it will
download the the image and now we see
that we have the status downloaded image
or new image from post degree uh latest
and here we have the hash of the image
also you can you can go to Docker
dashboard and you will see here that we
have this image and if you go to
Containers you will see the container
which is running okay
so and here you can see that we have
this container which is up and and
running
okay so to install my SQL uh using
Docker we will follow the same steps so
it will be Docker run Min d as uh D for
detached and now we want our database or
we want our image to be persistent or to
have a persistent volume so we can also
precise the Min V which stands for
volume and I want my volume or my
persistent volume to be in this uh in
this path so it's up to you to choose
where you want to have your persistent
volumes and then colum slash VAR SL uh
lib SL MySQL SL dat so this is what my
SQL uses uh for for data and now we need
also to precise some environment
variables uh and in this case or for my
SQL if we do not precise uh for example
the username it will take the root uh as
default username so I will I will keep
it just uh just root so I will only
precise my SQL or
this or this environment variable which
is the root
password
okay so it's my SQL andore uh rotor
password uh equals and I will keep it
empty or you can leave it empty so I
want to have an empty password for my
SQL uh next we need to we need to
precise the port so it will be 3306
mapped also to
3306 okay and then of course the image
it's my SQL or my SQL okay now let's hit
enter button and it will download or
pull the image so now it's it's
extracting and in just few seconds it
will be done and we will be able to see
the hash so this is this is the digest
or the Sha of um of the pulled image and
this is the ID of the image and also to
make sure that everything was fine and
okay you can go to image refresh in here
and you can see we have the MySQL
running and it's already in new so if
you click on this one you will see it
here that it's up and running
okay to create new spring boot project
the the recommended way and also the way
that I really recommend is to go to the
spring initializer website which is at
this address start.
spring.io and here you have uh a graphic
user interface or website where that you
can use to create a spring boot project
okay so let's go ahead step by step and
create our spring boot project so first
of all you can choose
which um which project
um first of all you can use which
dependency manager want to use so if you
want a maven or Gradle project or here
you have also the option for gradel
cotlin for people that wants to use
cotlin instead of java and here you can
also uh specify the language Java cotlin
or groovy so for us we will go for the
standards which is Maven and
Java uh for the this tutorial or for
this course because spring 3 is already
out so we will be from now on we will be
using the spring 3 version okay now
let's specify or precise the project
metadata so here the group ID it will be
um let's call it com. alibu
coding and the artifact let's call it
because this is a spring data jpa course
I will call it just jpa
so this is spring uh and the description
you can leave it or you can put whatever
you want so let's just leave it and this
will be our base package or the package
name so we want a jar packaging and of
course we will use the Java 17 for our
project
okay now let's add uh some dependencies
that we will need within our project so
first of all we need spring data
jpa and for the people that would be
using post degree SQL just choose post
degree SQL driver for the people that
they want to use the MySQL just go ahead
with the MySQL driver
okay uh next we need lombok so lombok
it's as you know it's an annotation
which helps us to reduce the boilerplate
code and I will be explaining uh all the
annotations that we will use within our
project and also I will add uh spring
web just in case um we need for example
to if you want to need to expose some uh
controllers or something like that you
can you can use the spring web okay so
now once everything is set up you have
all the dependencies you have uh all the
metadata and you configured everything
so we can first go and explore the
project before downloading it it and as
you can see here we have all the
information so is the parent is a spring
boot start parent with the version three
and here we have the group ID and the
artifact that we precised by default the
version is 001 snapshot and the name is
jpa
okay also we have the properties Java 17
and so on so forth and here we have all
the dependencies that we want to use and
in the end we have this build plugin
which is the default one from the spring
boot
framework and yeah okay so now let's
just go ahead and click on download and
open our project using inj or your
preferred
IDE to connect to our database there are
so many ways to do it my perfect way I
want to have everything in one place so
I always go with a database option
within anj so by the way this is the new
interface so you can download the latest
version and enable the beta UI and you
will you will have the same uh the same
view as me uh okay so let's go back to
our
database so in order to connect uh you
have this um menu right here which
called database but if you don't see it
um you can go to view and then you have
tool
window and then you can see here
database so if you click on database it
will it will open up this this window
right here all right so now let's create
or connect to our data source let's
start with uh post degree SQL so just
click on this plus
icon let me make it a bit bigger like
that so uh when you click on data source
you have here a list of um of databases
or uh databases um management system so
here for example you can also filter
type post agree uh to filter for post
agree SQL and then click on it okay so
this window will show and here we will
have a default name which is uh post
address Local Host and here you can you
can add some
comments uh you can also see the
connection type which is default and the
driver which is post degree SQL driver
so this is not the driver that we
included to our pom.xml but it's the
driver needed by anj or the the database
view system that you want to use uh to
to be able to connect to the database so
um here uh you have postre SQL but for
the first time it will it might require
you to download the driver so just go
ahead and click on download the driver
it will be in the bottom here next to
test connection and now let's go and
configure our database so as you
remember from the previous um part we
when we set up our postgre SQL we chose
the default Port which is
5432 and then we chose uh username and
password so for the username we said
it's suppos to Gray and for
the for the password we chose alibu
coding as a password okay now just go
and click on test connection once you
provide all the correct information so
so if you used a different port in here
just precise it same for the local host
and so on so
forth so when you click on test
connection so you need to expect this
succeeded otherwise you have something
wrong whether the password or something
like that so let's do apply okay and
let's check what we have in
here so here we see that we have our
post degree SQL and here you have uh one
of three schemas or one of three
databases so these also are my old
databases or the one that I'm using for
uh other projects so now the first thing
let's go ahead and create our database
okay so right click and then new and
then you choose database to create the
new schema uh let's call it
um let's call it data jpa okay okay
dataor jpa because this is the purpose
of uh of this course now just click okay
it's updating or creating the database
and then all you need to do click on
this uh zero of three icon and then just
select the public so you have you will
have the public schema by default okay
and then every u in the in the future or
when we create a new table it will
appear under this public right here okay
so now we have our post degree SQL set
up and running within our application so
let's move to the next for the students
or for the users that prefer using MySQL
instead of post degree SQL so in the
same way you have this icon right here
that represents the database when you
click on it it will open a window like
that but if you can see it just go to
view menu and then tool windows and then
you will see database just click on it
and you will have this view available
for you all right now let's click on
this plus icon to add a new data source
and here like I have it uh already in
the recent used but also you can filter
by typing MySQL and it will pop up okay
so uh then you need to preise the same
information that you gave when when
creating the docker image
so the local host or the host it's
always Local Host and the port if you
follow my exact uh same configuration it
should be also
3306 and for the user it's root and the
password will precise so just go ahead
and click on test
connection okay so when you just provide
the username and password if you have
username and password but if you didn't
uh provide a password so just leave it
empty and when you click you will see
this succeeded means that you are able
to connect to your database also one
hint be careful and make sure that you
have your container running so otherwise
you will not be able to connect to the
database okay so I will click on okay
and now we see that we have our Local
Host for my
SQL let's configure our project to be
able to connect to our database and we
will start with uh connecting to post
degree SQL but this is important because
it's the same configuration and only few
changes would be um would be different
from MySQL or uh postre SQL so the first
thing just go to resources in here and
and here we have our application
properties files so I like or I prefer
using yaml representation so it's the
same thing the the only or the main
difference is just the way we write the
properties so I will use uh yamama
representation if you want to use
properties it's also okay so just go
ahead first of all rename the
application properties to application.
yaml okay next now we will start
providing information or providing
properties to our application or to
Spring container to be able to connect
to the database so first of all our the
first property would be
spring dot data
source and then we need to provide the
URL okay
so uh to be able to connect to a
database we need to provide few
information because we have the spring
data jpa starter within our uh
dependencies so uh we need to provide
the minimum required of information okay
so for that case we need the URL I will
just come back to it uh later we
need username so in our uh no not Hikari
just just username so for our case for
postre scl we say we said that it's post
gr and for the password we why this car
and for the password we said we want to
use alibu
coding as
password uh and then we need to provide
also the driver class name and the
driver class name you see here that we
have already two or three suggest we
have three suggestions so the so the
first one or the the first one is for my
SQL or my SQL the second one is for post
degree s because anj is smart enough to
detect that we have these
dependencies in our pom.xml so it will
suggested okay so now what we need to
what we need to do the first one we want
to configurate for post degree SQL so
just choose the second option or the or
the first I don't know the order that it
will uh pop up for you and yeah that's
it now let's add some other
configuration okay here I will add jpa
and here I want to tell or to give some
extra properties to Spring configuration
or to the spring data
jpa on how to connect or how to manage
or how or how to uh work with my
database okay and the first property is
part of hibernate and it's called ddl
Auto this means what do we want to do
when the application starts Okay so we
have many options the first one is
create drop this means that we'll create
and destroy the schema at the end of the
execution or the life cycle of our
application so when the application
starts we will create the the schema and
the tables and when we stop the
application we will uh we will drop or
we will remove everything so be careful
when choosing this one the second option
is create so when when the application
starts it will destroy all the previous
data and recreate the schema from
scratch so this is also you need to be
careful about it we have also the non
options mean that we want to disable the
ddl handling that that this means that
we don't want to do anything when the
application
starts uh last but not least the update
option means that we want to update the
schema if necessary so this means what
this means that hibernate will compare
the the Java representation or the
entities it will compare them to the
table or the database schema that we
have and it will try to to make it uh
even but here you need to put in mind
something which is really important the
update option it will not remove
attributes so for example if you have an
entity and you create uh and you want to
to remove um an attribute and replace it
or like create other ones it will create
the new attributes but it will not
remove the existing ones okay so also
you need to know that and you need to be
careful about
this the last option is validate this
means what means validate this it will
do it will not do any changes but it
will just validate the schema comparing
to the Java representation or the entity
representation so we have for
example um user entity and we have a
user table so the validate will check if
we have the same table same table name
same attributes same attribute names
same types and so on so forth so it will
just validate that what we have as code
is the same as what we have within our
database so for our configuration let's
say create drop because this is um
learning uh course so we don't need to
purchase data forever so create drop
should be fine for us so let's go with
create drop and now we can also precise
the database this like will help uh
spring or will help also hibernate to
know which database we are dealing with
so it will just enforce the way that we
will uh the way that we will uh update
and manage our database okay so here we
have also the option uh show SQL let's
set it to true because we want to see um
we want to see SQL queries okay so now
this is the main configuration or this
is the configuration that we need to do
now uh we will need to go back to this
URL and the difference between for
example configuring my SQL and
configuring post-degree SQL is just
providing the URL the correct driver
class name and here this option right
here you can also change it to say it's
my SQL okay so now going back to this
URL so it's
jdbc it's always like that jdbc do
postre
SQL colum SL slash and then you need to
provide the local host or like um well
whether it can be Local Host it's if
it's locally or it can be an IP address
or it can be a URL and so on so forth so
now we need to provide the port which is
5432 and then the database name as a
reminder the database name we created
here we called it dataor jpa so here
let's
just provide it so now our application
will be able to connect to this one so
how to test it what we can do we can
just go ahead and start the application
and see if we are able to connect to the
database now I will enable annotation
processing because we have lbook within
our application and as you can see here
so the application already started in
2.9 seconds and without any issues so
everything is up and because we don't
have any tables so we don't have any any
further uh information but if something
is wrong we would see that we have
exceptions in here and I will just show
it to you so for example if I provide
the wrong Port name uh number sorry not
name so if we provide the wrong port
number uh and we try to connect to the
database we will see that we have a
connection issue and it will say that
enable to connect to this Local Host uh
5431 so connection refused and so on so
forth so this just to ensure you that
when you have the correct configuration
you will have no issues when connecting
or when starting the application okay so
now our application is ready to use
let's move
on we will add now the properties to
connect to my SQL database and to do
that I highly recommmend that if you
skipped the the first part to connect or
to configure uh post degree SQL I would
really recommend that you go back
because we explained all these parts so
it's really really important that you
that you go back and check that uh now I
would show you how to configure or how
to connect to my SQL the first thing
let's go ahead and duplicate this
application. yam just copy and paste
just command C command V also just as a
reminder you every time I use a shortcut
you can see the green uh popup uh down
here so yeah you can always follow what
I'm doing so now I will just say my SQL
or just uh the new file I will call it
application- MySQL so this we can use it
as a profile as a spring profile and I
will show you how you can run the
application whether for my SQL or my SQL
or post degree SQL so uh how you can
configure until J to run with a specific
profile we will see it just in the end
of this video okay just go ahead and
click okay and let's start do the
changes that we need okay let's put this
in full screen or even I guess it's also
like that is readable
so uh the first thing we need to of
course change change the username and
password so for my SQL it's root root
and we will see if it works or not let's
go ahead and change the driver and now
we want to use the my SQL driver okay
and for the database we want also to use
my my SQL or my SQL now we need to
change or we need to update this URL and
connect to the database so uh the good
good thing is within my SQL you can ask
him to create the database automatically
if it doesn't exist or if the database
does not exist so my SQL will create it
sorry yeah so my SQL will create it
automatically for you the URL is here
instead of uh let's remove it let's
write it from scratch so it's jdbc and
here my SQL and then column SL slash now
we need to provide uh the URL of the
database so it's Local Host uh column
3306 this is the port that we want to
use and then we want to use also the
same database or the same database name
here so just we just for to be uh
convenient so I will call it also data
jpa okay and also you remember that that
we did not create manually the database
because as I I mentioned uh my SQL has
the the option or has the capability to
automatically create a database if not
exists so to do so just add
interrogation Mark and add this uh
parameter which called
create
database if not
exists equals true and that's it so like
that it automatically um my SQL will try
to create or will create a database
called Data jpa if not exists okay now
to run the application using this
configuration first before clicking on
this play button right here to the to
run the application just click on jpa
application and you will see edit
configurations here and here you see
that we have active profiles so spring
now if I precise it as my SQL spring
what will do when starting the
application he will try to find an
application properties file or
properties uh file have uh having the
suffix my SQL as precised in the
configuration in here okay so here we
said that the active profile we want it
to be my esql we can we by the way we
can provide many active profiles uh uh
as you can see here it's profiles not
profile so we can U provide many but in
our case we want to connect to
application- mySQL yl file so spring
will automatically try to scan and read
this file if exists okay I will click
the
run and let's see if the application is
going to start correctly or not
yes um all right so uh we see here here
something that I didn't know uh so here
we see that loading class this one but
it's deprecated and the new driver is
the one that we saw in the options okay
so we will just update it later on now I
want to go and check the
schema let's refresh this one and here
we see that we have now five schemas and
we see our database data jpa so we don't
have nothing yet but this one once we
create the table the tables and the
entities we will have all the tables in
here so uh let's do the final
update and let's replace this with a new
driver using this package and that's it
for this course we will implement the
following database class diagram so uh
this database class diagram is about uh
e-learning platform
and what it's about exactly so it talks
about um how we can for example if you
go to uh alibu coding and check the
courses that I have there so what you
see this is what we have behind the
scenes so we have courses sections
lectures and for each lecture we have uh
a resource and the course has an author
and so on so forth so this is what we
will see but first let me explain to you
uh in depth this class
diagram
so uh we have a course so for example
this one that you are following right
now which is mastering uh spring data
jpa uh step by step so we have a course
and this course has an author okay but a
course can be done by many authors
right and the same author
can create many courses so for example
me I can create so many
courses and one course can be created uh
within a collaboration of multiple or
many uh authors okay so that's why here
we have this many to many
relationship but uh here create an
author having an author within our
database doesn't mean uh that this
author should already have a course
within the database but if we have a
course we should have at least one
author assigned to that because when we
want to create a course we need to
assign it to at least one one author
okay so that's why you see it this you
see this symbol right here and you see
this one right here means that the
author is optional to have courses but a
course is is mandatory to be assigned or
to be done or to be created by an
author then uh you know that a course
has one or many sections okay so um here
when we create a course we need to
create at least one section but we can
have multiple sections for for one
course and here just uh put few uh few
attribute attributes just simple ones uh
like title description uh name and order
for the section and so on so forth um
okay so uh as I mentioned a course has
one or many sections but one section if
we take one section it belongs to one uh
one course and within the course we can
have many sections that belong to that
to that course
okay all right
next one when we talk about sections we
have uh many lectures okay we have so
many one or many lectures and one
lecture one lecture if we take one
lecture it belongs to one section so
this means that we cannot have one
lecture that belongs or can figure out
with in different sections okay so if we
take the section A that has uh lecture
one and lecture two so this lecture one
it belongs only to this section A it can
we cannot find it as part of uh section
c or section D for example okay now
after that a lecture um has a type or
has a resource okay so a lecture has one
resource and this resource belongs only
to this one lecture so that's why here
we have this onetoone relationship
between the lecture and the resource and
for the resource we have of course the
ID name size and URL and the resource
can be of different types so I just
created a simple uh simple types here
for example video file or text so this
represents a resource okay so here what
we have we have um inheritance
between this resource class or resource
table and this video file and text
objects okay so for the video we have
the length for example for example how
many minutes um this video for the file
we have the type for example whether if
it's uh PDF MP3 and so on so forth and
we have the te for the text we have the
content and all of them all these three
types or three uh types of resources
they are already uh resource and they
can be assigned to lecture okay so this
is our class diagram and this is what we
will
Implement during this course so we will
go uh through all this one by one and
each time or every time we need to
explain something we will go ahead and
create and see how we do that and also
we will see how to create advanced
search queries how to work with
transactions and so on so forth so you
already saw the plan of the of the
course and this is what we will be
implementing before we go further let's
first understand and explain the
difference between hibernate and spring
data jpa so first spring data jpa is
just an abstraction layer on top of jpa
to reduce the amount of boilerplate code
required to implement data access
objects or what we call Da or D
Dao but jpa what is jpa jpa is just a
specification that facilitates object
relation mapping to manage relational
data in Java applications this means
what we can consider jpa as uh a Java
inter pH where we have or where we
Define the methods that we want to be
that we want them to be implemented by
any class that wants to use or implement
this interface and why is that because
we have so many implementations like for
example we have hibernate we have
Eclipse link we have ibus and so on so
forth that all of them they should
implement the jpa specification and the
reason behind that is we want to make uh
coders or developers life much much
easier so for example if you want to
move from hibernate to Eclipse link all
you need to do is to do a minimum
configuration or minimal changes like uh
CH changing the the dependency or maybe
or maybe some basic configurations but
for example if you have a save method
it's the same it's exact the same method
for hibernate uh and Eclipse link for
example this this is what jpa exactly as
as I mentioned jpa is just the
specification okay now if we go to the
hibernate level so hibernate is a jpa
implementation and also hibernate
generates uh SQL query and executes us
using jdbc so hibernate is the omm the
object relational mapping that will use
jdbc to handle all the database side
mean like saving uh reading deleting and
so on so forth okay so this is the main
difference between hibernate and spring
data jpa so let me also re explain this
part so instead of doing all the
implementation
and defining the S the session
management and so the transaction
management also and so on so forth that
uh hibernate provides so spring data jpa
will do all this job for us because as
you know when using the spring data jpa
starter it will autoconfigure almost
everything for us so yeah this is the
power of the spring data jpa let's see
see first how we can transform a table
or database table to a Java class and to
be able to manipulate it uh within our
application so let me explain this
diagram right here so we have this
author. Java that we will take as a
first example and we want to process
this object into our database and we
want it to be stored directly into the
author table okay
so uh we have our author. Java that
contains a set of attributes uh ID first
name last name email and
age and then what we will see next is
which annotations that we need to use in
order to make uh spring data jpa
understand that this is a table or this
is an entity and needs to be persisted
and so and so forth okay so uh let's go
to our anti J now let's create within
our base package com. alibu coding. jpa
let's create a new class or um yeah
let's create a new class A Java class in
here but if you want for example if you
don't have the right package uh ready to
use just uh when you want to create the
class you can
precise the package uh the package name
for example if if you want to call to
call them models or if you want to call
them entity or entities it's up to you
so you just um call uh give the the
package name for example let's say
models in here and then you
can precise the class the class name so
for us it we want to create the author
Java class and we want it to be within
the models package so when you hit enter
so this is what we see in here and we
have author created under the package
models okay so now as we mentioned
before let's just
create our attributes so here just a
reminder we want to create ID of type
integer first name last name and email
of type string and we have an age of
type int here I
have a private entity
ID and they have a string first
name and they have also a last
name private string email and finally I
have a private int
H so this is my Java class now what we
need to do or like normally or usually
what needs to be done when you create uh
a Java class or when you create
especially when we talk about entities
and so on so forth so always think about
generating Getters and Setters so make
all the fields private and generate
Getters and Setters so to do so there is
a
shortcut uh in here like as you can see
like you can generate uh using this
shortcut and here we have getter and
Setter here you can select all the
fields that you want to generate Getters
and Setters for and then just click okay
and you will see that we have all these
methods ready to use but if you remember
we I will just roll back this so if you
remember we already added lombok to our
uh project or to our pom.xml so let's
use lbook for that okay so the Lum book
annotations we have many annotations
many useful annotations we have the
getter
annotation and as you can see it's
always from the package lbook so this
will
generate uh Getters for this class and
also we want
Setters so this will generate this
annotation will will help us generate
Setters or Setter methods for all the
attributes in this class if you want
also for example a no arcs Constructor
means a Constructor with no parameters
you have the no arcs Constructor
annotation also if you need uh all Arc
Constructor you can also add it using
this annotation also all arcs
Constructor but we have another
annotation it's called
Data always from uh from lombok and if
we go and read the documentation always
try to download uh sources to be more
readable for you and to get all the
information that you need so here this
data annotation it generates Getters for
all Fields uh useful to string method
hash code uh hash code and equals
implementation and so on so forth so
this dat
annotation it's the equivalent to getter
Setter required AR Constructor to string
and equals and hash code annotation
so always to reduce the amount of boiler
plate code we can remove
this and we can remove this too so we
can just work with two annotations data
and no arcs Constructor and also if you
need other annotations is also easy to
use so we have now our uh our class or
our Java object ready to use let's move
on and try to make this an entity or to
make it a table now let's try to answer
one question is having a Java class
containing all the attributes that we
need for our table is it enough to tell
spring that this is an entity so spring
or spring data
jpa how he will know that this is an
entity and needs to be managed so the
answer first of all the answer this is
not enough having just a Java class is
not enough and we need to tell spring
that this is an entity so we need to
provide and some annotations or some
some information in order for spring to
be able to scan and pick up this object
so I already told you the answer so we
need to give an annotation and this
annotation is entity okay so this entity
just let
me show it to you first so now we are
using spring boot
3.0 and as you know one of the uh
breaking changes or like the biggest
changes is using Jakarta E9 and when we
use Jakarta e so we the package is no
longer Java x.p persistence so all the
Java X not all of them 100% but all the
Java X packages that uh belongs to the
Jakarta e now they they have been
renamed to Jakarta okay and from now on
we need to use Jakarta do persistence
for all these annotations okay uh all
right so here uh using this annotation
and when we run the application
automatically hibernate spring and
spring data jpa like all of them are
working together so they will be able to
pick and tell this is an entity so we we
need to use it okay and I want to show
you also the
documentation and it says that this
specifies that the class is an entity so
it specifies that the class that has
this annotation is an entity okay and
also this is so important this
annotation is applied to the entity
class so here it's um it's a type type
level or type targets so like this we
covered this part this entity part and
we have here the same package as we
already saw together so now spring will
be able to know or to recognize this
author. Java class as an entity let's
move on and see what we need to provide
as minimum information in order to have
this entity created in our
database after annotating this Java
class this author Java class with the
entity so this means that spring data
jpa will recognize this class as an
entity and it will create the table for
example based on the configuration we
specified in the ddl auto when we first
configured the application so it will
automatically create this table
otherwise it will consider it as a table
all right but here we see that we still
have an issue even by having this entity
annotation we still see that we have
some error right here and let's go ahead
and check it together so here it says
that the persistent entity author so we
see that now our class is a persistent
entity should have a primary key so you
may ask the question I already have a
key field right here but yes this is a
key for us we are human being and we
understand and we can read that this
field is ID and even Our intention is to
have it as an ID for our entity but
spring data jpa doesn't understand this
spring dat data jpa is just a program
it's just uh zero and one is a binary so
it understands only annotations okay so
to make this field an ID or any other
field an ID we need to add an annotation
and this annotation is as the name says
so it's The annotation ID and here while
we are using the spring 3.0 always make
sure that you are using The annotation
from the correct package okay so the
package is always Jakarta dop
persistence all right I will insert this
one and we see that the error now is
gone but first let me explain to you
what is this idea so in Spring data jpa
the ID annotation is used to Mark a
field as the primary key of an entity it
is used to specify the identifier
property of an entity which is used to
unique identify an instance of the
entity in the
database okay so when the entity is
persisted to the database the value of
this field will be used as a primary key
of the corresponding database table so
this means the value of this integer ID
is unique within our table and also it
might be unique within our database
depends on the generation type or the
strategy that we will use to generate
this ID all right so here I want also to
answer one small question you might ask
so why we are using integer here instead
of instead of int okay so the answer is
as follow so the int value by default is
zero but the integer value by default is
null and this is super
important because spring data jpa
and when we talk and we talk mainly here
about hibernate because we are using the
hibernate
implementation so uh hibernate each time
when we try to save or to persist a new
row or new line into our
table hibernate will check the value of
this ID or the field annotated with the
ID if the value is null hibernate will
understand that we want to create or to
persist a new element into into the
database otherwise if the value is
different from null or is not null he
will try to fetch the element within the
table that has this value okay so if we
use the int if we use the Primitive type
so the default value will be zero so
hibernate will try to find an element or
a row with a value zero and it will
never find it okay so that's why it's
always recommended to use wrappers over
primitive types
okay so um I hope this is clear if you
have any questions just go ahead reach
out to me otherwise let's move
on we already explained that this ID is
the unique identifier of of our table
and we mentioned that we want to use or
we need to use the wrapper classes or
the classes like objects in here because
the integer is the wrapper class of the
Primitive type in because when hibernate
sees that uh this ID has a null value it
will
automatically uh generate a new ID and
insert a new line into our table but how
hibernate will generate this ID so here
we talk about gener generation types or
generated values for our IDs and here
let's explain or let's see which
annotation or which mechanism can help
us generate this ID all right so the
answer is easy and here we have an
annotation called generated value and
just a reminder always from Jakarta
persistence and once we mention or once
we annotate a field with this generated
value here let's check the documentation
what is written in here so it it says
that it provides for the
specification of generation strategies
of for the values of primary keys so
here this is a keyword means that we
work with primary keys so this generated
value works with primary keys so the
generated value annotation may be
applied to a primary key property or
field of an entity or mapet super class
in conjunction with ID annotation so
this property of this annotation might
work with primary key uh property of a
field or an entity or mapped super class
we will see all these uh terms
together and always in conjunction with
ID annotation the use of the generated
value annotation is only required to be
supported for simple primary keys so we
cannot use this generated value with
complex uh Keys means complex Keys means
we can have for example uh an ID
composed of two Fields let's say for
example an integer and a date so this we
can create a composed key and and we
will see that
also uh somewhere like after in the in
this course okay so uh use the generated
use of the generated value annotation is
not supported for derivate primary Keys
okay so um here we have this annotation
generated value and we know that it will
generate uh it will generate an ID or
autogenerate a value for us let's check
what we have in here or what which
properties we have within this
annotation so we have a strategy which
is of generation type and also we have a
generator so this strategy is the
primary key so it's optional but it's
the primary key generation strategy that
the persistence provider must use to
generate the annotated entity primary
key so here it we we can Define or we
need to Define what which strategy we
want to use so the persistence provider
and the persistence provider here means
the database provider or the database
management system we are using must use
to generate the annotated entity primary
key so here we have a default value for
this
and we will check what are the types we
have right here the second one it's also
optional we don't need to specify this
property and this is the name of the
primary key generator to use and
specifies the sequence sequence
generator or the table generator
annotation defaults to the ID generator
supplied by persistence provider so here
based on the on the generation type that
we want to use we can also create our
own generator so this means what let's
go ahead first and check this generation
types so for this generation types we
will go and understand them one by one
we have table sequence identity and we
have this UI ID and this Auto okay all
right so we will understand this in a
few
seconds and now I want to go back
to this generated value annotation and
talk about this generator so we saw that
within this generation type we saw that
we have one value called table and one
value called sequence so this sequence
generator and table generator they are
responsible if we want to create
manually our sequence generator or table
generator so we will understand that in
the SEC in the next
lecture
[Music]
so now let's understand the different
types of this generation strategies so
as we mentioned the default value of
this generated value the strategy
default value of it is the auto and we
also have the sequence table and
identity so first let's understand what
this strategy equals Auto means so this
means that hibern will try to connect to
the database or to the persistence
provider and try to determine which is
the best strategy to use so to
understand this more in practice so just
a reminder here we see that you have
within this this uh generated value
annotation we have the default strategy
is Auto and now in order to understand
that all we need to do is to start our
application so by default our
application is connected to post degree
SQL and we will see that within post
degree SQL it will choose one strategy
but when we choose uh MySQL or we start
with the MySQL uh profile it will choose
a different one okay so let's go ahead
and start our
application so our application has
started and we let's check the log first
and then we will check the database so
here it's just a normal log and a
classic one but we see here we have some
hibernate logs so now what we have we
have create sequence author sequence
start with one increment by 50 okay and
then we create a table author with the
following uh attributes integer ID not
null and so and so forth and we have
here or we are defining here a primary
key ID okay
so this is good let me reduce this and
here within this uh data jpa or our
database let's refresh it and here if
you see Zero of three you need to select
the public schema okay now let's open
this one within the public we see that
we have one table which is our author
table right here with the fields or the
columns that we defined which is uh ID
age email first name and last name
and also we see that we have one
sequence which is the author sequence so
by
default hibernate determined that the
best strategy to generate IDs for this
uh database for the Post degree SQL
database is US using sequence so it
created a
sequence and it named it author sequence
by default like it takes the
concatenation of of the table name
within a suffix _ sequence and then it
using it will use this sequence to
generate values so if we have multiple
tables or like more than one entity the
sequence name will be hibernate sequence
okay but for now we have on one single
table so it will take the table name
with this sequence suffix all right now
let's restart our application but using
the MySQL profile and let's see what
will happen within this MySQL okay so
let's do it and in order to profile uh
in order to define the different profile
so all we need to do here with an entity
J you see this uh little card right here
just click on it and then open edit
configurations select your application
right here so you might have multiple
ones but select the one jpa application
it's the our application name and here
specify the profile name and the profile
name how you can find it let me close
this one
first and you open here and you see for
um here for our application it it's
called application- MySQL so this MySQL
is the profile name so now let's go
ahead edit the configuration and in the
active profiles right here I will just
provide my SQL so like that when we
start up the application spring we'll
pick up this configuration
file so now the application is running
and we see that uh we have drop table if
exist drop table if exist and here what
do we have here we are creating first
create table author with the with the
attributes or the IDS that we precised
and we see here instead of creating a
sequence we have have create table
author sequence so it contains a next
value attribute of type big in okay so
here MySQL and hibernate determined that
the best strategy for my SQL is uh using
table okay using strategy table and this
might not be the best strategy but maybe
MySQL or any other database management
system does not support one or another
strategy for example my SQL does not
support sequences so it will fall back
to the second option maybe I don't know
the exact order but I'm just trying to
explain it like that so it will fall to
the next strategy which is author uh
which is table strategy okay so let's
check our tables right now click here
refresh and now we see that we have two
tables the one is our author with the
five columns that we already precised
and the author sequence is only one
column which is the next value so if I
open this table you see that for now it
contains only one line and the value is
one and if I insert any
data it will
automatically increase it by one and use
it for the next value all right so this
is the auto strategy and now let's move
on and talk about the next
one
so here we saw together how hibernate is
able to detect which strategy is the
best for our persistence provider now
let's talk a bit more into in details
about this sequence generation okay so
by default hibernate will create a
sequence if possible of course but let's
assume that we are using postre SQL and
the best strategy is sequence so
hibernate will automatically create a
sequence but what if we don't have the
right to create sequences what if we
have a database admin that creates
everything for us so we need or we need
to specify which sequence we have
already or like we need to point
hibernate to that sequence and the name
might be different one might be a
different sequence so we need to point
hibernate to that so this is one use
case the Second Use case I want to
create my own the sequence and I want
also to autogenerate or to Auto
configure manually the allocation size
so we saw in the previous uh lecture
that hibernate will use the value 50 as
an
incrementation or as a step value so we
want for example to be one all right so
let's see how we can do this so now in
order to do that first of all we need to
specify the strategy right here and the
strategy if you hit control space we see
the the options that we have and let's
choose sequence okay now I just want to
remind you that within this generated
value annotation we have the strategy
and the generator and the generator here
it's the name of the primary key
generator all right so let's give it
right here I would just put it into new
lines and here I will precise the
generator and my generator is a string
like we should we need to give it uh a
string name and I will call it author
generator or sequence author sequence
okay I would call it author sequence or
SE like let's call it sequence to to see
the difference between the one we
generated before or that was
automatically generated I'm talking
about this one so our name would be
author sequence all right okay so now we
have author sequence but when we start
the application hibernate will will not
find this author sequence so it will
claim or it will raise an exception
telling that we don't find this
exception all right so what we need to
do is we need to create or to manually
create this sequence okay and to do that
it's really easy
peasy we have an annotation called
sequence
generator and this annotation sequence
generator it takes a name as a parameter
so this is uh the name and the name
should be the same like as this one all
right so I'm just going to copy paste it
to avoid uh
typos and let me align it so after
providing the name we need also to
specify the sequence name the sequence
name is the sequence that all also we
want to use as a name all
right so sequence Name by default it's
empty but let's also use this author
sequence as a name next we talked about
uh allocation size means the step of
increasing or incrementing this sequence
and it's called allocation size and as
you can see here the default value of
this one is 50 and this is what we saw
before in the
that's this is where this allocation
size or 50 is coming from all right so
for us we want an allocation size of one
and now that's it we have our sequence
generator and we have our generated
value for this ID let's go ahead start
the application and see what will
happen so here we see that we have this
log right here uh create sequence author
sequence so now it's called author
sequence start with one increment by one
so it starts from the position number
one and it's incremented by one and this
start by one so it's from the initial
value so you can also change it if you
want to start your sequence from
specific value all right next we are
creating the table and now let's go and
check the database and make sure that we
have everything in order so I will just
refresh this
one and we see that we have our table
and now our sequence is called author
sequence so in case you want to create a
uh specific sequence or um yeah a
specific sequence for each entity this
is the way how to do it all right so now
this is how sequences works and then you
don't need to do anything hibernate will
automatically use this author sequence
to generate the ID
all right so that's it if you have any
questions just reach out to me on
contact alibu coding.com or you know all
my contacts on social media otherwise
let's move on now what if we want to
choose different strategy of generation
what if we want to use table instead of
sequence and we want to create our SE or
table generator instead of sequence
generator so let me show you how to do
that first of all I will just comment
out this sequence generator I will let
it I will leave it here in the code so
you can use it then we need to change
this generation type from sequence to
table and I will call or rename this
generation or generator instead of
author sequence I will call it uh author
ID generation generator okay so ID gen I
would call it like that okay now uh
instead of using this sequence generator
we have a similar annotation which is
table generator okay this table
generator it takes a name as parameter
so the name I don't need to mention it
again but it should be the same name as
in here after precising the name I want
to precise Also the table
right so the table right here let's call
it ID generator for
example all right next we need to
precise the primary colum
name comma here PK colon name and this
is going to hold the column name of our
primary key let's call it um ID name for
example just to make it uh easy for you
I will call it ID name and the
value
and the value colum name is the value
for this colum so I will call it ID
value just to be consistent with that
and make it easy for you and of course
we can Define the allocation size as you
can see here it's always default 50 and
I want to make it one all right so I
will keep the same profile the the
postre SQL profile so we can see the
difference or we can see what will
happen when I restart the application so
I'm going to stop it right now and
restart
it so here let's first check what we
have as information so we have here
create table author so this is our main
table and then we are creating a table
called IG ID generator and the ID name
is type of V chart 255
255 and ID value and so and so forth so
here what we are doing and insert into
ID generator and we are inserting the
first value which is the author and the
and the value is zero all right so let's
check what we have in here I'm going to
refresh this
one let
me so here we no longer see this
sequence generator right here we no
longer have the sequence but instead we
have this generator table and this
generator table it contains only uh
already one line which is the author
which is our entity name and the ID
value is zero so when we use this table
generator the one that we created
manually it will create one line for
each entity and it will initialize the
ID value for it so if we want to insert
another entity it will come here query
it by the name and as you can see the
name is is an ID so it should be unique
and it will increment the the value for
that one so this is how we can also use
tables as uh generators but here before
we finish this
part I want just to bring everything as
it was before so I will also comment
this out just to leave it in the
code like that and also I will change or
just remove this okay so I will just
leave it as generation type Auto and
like that I don't need to care about uh
which strategy to use all right so
that's it if you have any questions
don't forget to reach out to me
otherwise let's go ahead and
continue in the background I restarted
the application so we have the previous
state so now we have our table and we
are using the sequence as a generator so
what we what I want to show you in this
part is as you can see here we have this
ID age email first name last name and so
on and so forth but the question is what
if I want to have more control over
these columns okay so for example this
first name I want to have a different
name and I want to have a different name
for this last name I want something
which is different from the field that I
have right here so this is the first
thing the second I want to have uh you
unique or I want to make sure that my
email is unique so uh this will prevent
me from having duplications uh when we
talk about email because we know that an
email is unique per per user all right
so to do so we have an annotation that
can help us um Reach This goal so let me
make this one full
screen and first of all let's talk about
this annotation so The annotation is
colon
and first let's check what this column
is what this annotation so it specifies
the mapped column of a persistence
property or field if no colon this is so
important if no colon annotation is
specified the value of the default value
apply so default value means what means
the default values of this annotation of
this column annotation and let's quickly
check the attributes that we have right
here here so as you can see all of them
are optional here so the first one we
have this name so this is the name of
the column otherwise it will take the
property or the field name so if we
don't precise anything in here so the
default name will be first name and here
as you can see that uh when we write it
in camel case it will be transformed
automatically into snake
case all right now let's go back to this
colon annotation we have a unique
attribute so this specifies whether the
colon is unique or not uh also if it's
nullable if we accept null values by
default it's true but if we accept null
values or not and here we have this
insertable uh property so this means
what this means that if we accept the
that we can insert new value for this
colum you may ask the question why I
should prevent inserting and the answer
is when we talk about for example dates
and we have an update date or the last
modified date of this column so here we
want we don't want it to be insertable
but we want it to be only updatable okay
so here we have insertable true
updatable true and the same the same for
this updatable property so for creation
date or like the the date of creation of
a new line or when we insert a new row
into a table we want to track the
creation date so the creation date
should be only insertable and we need to
insert it only when we when we create a
new line but when we update the same
line we don't want to update it so this
field should not be updatable okay and
here we have a table we have length and
also length for example for Strings we
can specify or we can say for example
that um username or a login name or uh
AO name uh should be only maximum or
have the length of eight uh eight
characters maximum okay and when it
comes also to uh numeric numbers or
decimals we can talk also about
precisions and scale so okay now we we
talked enough let's go and see this in
action all right so the for the first
name I want to have uh my name or the
name of this field to be like that for
example F name all right and why we have
or why we we need to change this so like
um for projects from scratch it's it's
okay because we will Define everything
but imagine you want to work on on a
project where the database already
exists and for example let's take the
financial um domain and the database
already exists but believe me you don't
want to know how they call the fields or
the columns so it's totally totally
different because they are using really
technical names uh Financial technical
names so we want to have a more
understandable for our Java application
we need to have a more understandable
names so we need to stick to the same
names to the datab base but we want to
have our own all right so when we
manipulate objects within our uh Java
Java project we want to use first name
instead of this F name or it can be F1 2
3 4 so we don't want to name our field
F1 2 3 4 we want to name it first name
and then we can reference it or we can
give it a name that will be used within
our database
okay so this is the first one now I will
move on to this email so for the email
for example it's okay it's fine for me
to keep the name as it is but for this
email I want for example to I want it to
be unique so as you can see and also as
I showed you before this unique
attribute has a default value false so
by default the field or the colum is not
unique but let's make it unique so when
we use this property this means that the
email will become unique so we can
cannot insert a duplicate values for
this email all right also I can make it
non nullable because also nullable by
default is false but I want to specify
or like make the user uh pass a value
for this email so the email I want I
don't want to see any emails into my
database with null values okay also if
you want to I I know this is um this is
not okay but let's go back and do it in
here I was going to talk about the
length if I want to have a specific
length so the default is
255 and let's say for example I want to
have uh 35 as max length for this first
name so this is the property to use all
right so here if we talk for example as
we mentioned before I will
create a local date time field right
here uh created at so this is the
creation date and I will give it also
the colon annotation all right and for
this colon annotation I want this to be
not updatable all right so as you can
see it's by default true but I don't
want this field or this colum to be
updated so I want it only to be
insertable so I don't need to specify
the insert because by default it's true
but I don't want this one to be
updatable and this one cannot be null
all right so this also nullable false
now I will create another column and I
will call it last updated at or last
updated or last modified let's call it
like
that so for this last modified I will
also use the colum annotation
and within this colum annotation I want
this one to not to be insertable so I
don't want to insert this last modified
when I first created when I first create
a new line or when I first insert a new
line I want this last modify to be null
so because if I insert it it might be
confusing because for example I want to
query all the data where the all the
data that were not modified okay so I
don't want to insert it all right uh I
want it also to be updatable and it will
be nullable so I just keep the default
value because nullable is by default
true so using this column annotation we
can have more control over our columns
within the within our entity and on the
database level so we can precise the
name we can precise the length we can
also um check the Unicity and the
nullability of of our field also we can
decide if it's updatable or not and if
it's insertable or or not so this
annotation gives us more more and more
control over our uh our columns okay so
I'm going to restart the application and
let's see the impact of these uh of
these annotations right here so let's
see what what was the impact of this so
um here so it's here it's just updating
the constraint so here we see that first
of all we are we are adding a con new
constraint to our email with this unique
so now it's Unique and here for example
for the age uh it's an integer not null
and we have this created at it's not
null the Emil mail is also this the same
and we see that the first name is now
called f name and and is no longer
called first name all right so we see
also that the last modified is a
timestamp but we don't have any control
over it like uh not null and so and so
forth same for the last name and here we
are defining the primary key as our ID
colum let's see the changes directly
visually I will refresh
this and now we have our seven columns
so we see here that we have this ID the
age created at email and we see this
small circle right here so this means
that these objects are not null or so
they should not be null okay also we see
that we have two keys so we have the
author primary key and we have a second
one which is referencing the email
because we don't want this email to be
null and we want it to be unique so here
you see this UK is unique stands for
Unique key PK stands for primary key all
right so I hope this was clear for you
otherwise drop me a message and let's
move
on now let's take the following example
what if we want our table to be named
author and _ TBL as a table name in the
database and we have our Java class
called author so in this case how we can
map or how we can tell this entity or
the Java class or we mainly talking
about spring data jpa and hibernate how
we can tell hibernate to name this
entity and give it the name author
underscore TBL in the database so the
answer is in here we see this annotation
this the table annotation is the one
that can help us do this so let's see
the power of this
annotation so let's go back to the code
right here and now I will use this table
annotation right here so first of all
let's check what are the properties of
of this annotation so first of all uh it
says that it specifies the primary table
of of uh for the annotated entity
additional tables may be specified using
secondary table and secondary tables so
here if no table annotation is specified
for an entity class so the default
values apply so if we don't use this
annotation we will apply this default
Valu so the name will be empty catalog
and so on so forth so let's now discover
quickly these these fields or these
properties so name this is the name of
the table so we already have the answer
how we can change or how we can give a
specific table name here we can also
specify a catalog and the same for the
schema so for example if my table is
located in a different schema so I can
provide it in here so I can give this
information so for example if I have a
schema 1 schema 2 and schema 3 within
the same uh within the same database so
uh I can spe specify or I can precise
which schema for each entity or each
table also if I have unique constraints
like the one we did before we want uh
for example our email to be unique we
want we want to add a new indexes and so
and so forth so we can add a list or a
table of unique constraints okay the
same for indexes all right let's go back
here so for our case we only want want
or we only need to give uh to give a
name to our table because the we have
only one schema so if you have a
different one you can give also the
schema name so here I will call it
author
TBL and I will restart the application
and let's see the changes so click on
restart right
here and let's check again what we have
so we have this sequence this AU auth
tlore sequence and we have our table now
is called author TBL okay so just for
record uh databases are not case
sensitive just in case you don't know
this information so that's why we see
here that the table is written is lower
case and here it's already in uppercase
so we see we see now that the table or
the table name has changed and now it's
called author TBL all right so yeah
that's it I will just clean up the code
make comment out this annotation and I
will leave the rest for you so thank you
so much um drop me a message if you have
any questions otherwise let's move on so
far we learned how to
manipulate date tables how to create
entities which are the annotations that
we need to use which properties of these
annotations we can use like for example
when we talk about uh generated values
how and the strategies how they work how
we can also customize them and create
our own uh and private sequence and
table uh table generator and so and so
forth but now we didn't reach yet the
point where we need to discuss or where
we need to manipulate and interact
directly with a database interact means
for example crude operations like read
uh create read update and delete and
this we will see right here for example
we have as always our author table in
the database so this author table has
its own representation in our Java code
as an author. Java and we need to
persist this object to this database so
the link between the author and the
database right here because the DAT a
table already belongs to a database but
when we talk about Java program and
programs and also when we talk about
spring boot framework we talk about uh
entities all right so um what we need to
do to in order to better interact with
this
database so here comes the power of
spring data jpa so spring data
jpa uh made it so easy for us because he
proposed something really really nice
which is a repository and and the
repository is an abstraction to reduce
the amount of boiler plate code needed
to implement the Dow layer or the data
access object to interact with the data
stores okay so let's go a bit deeper
within this definition so in Spring data
jpa a repository is a Java interface
that is used to abstract the data access
layer from the business logic it is used
to perform crude oper ations crude just
a reminder stands for create read update
and
delete as well as other common database
operations such as pagination and
sorting repositories are typically
defined as
interfaces and uh that extend one of the
spring data jpa repository interfaces
such as uh jpa repositories crude
repository paging and sorting repository
so these are the three main uh
repositories or jpa repositories that we
can extend like we create an interface
and extend this interface to to have our
own repository okay so because these
interfaces provide a number of
predefined methods that can be used to
perform common database operations such
as uh saving deleting entities finding
entities by their primary Keys finding
entities based on various criteria and
this is what we will see in details
later on okay but
first let's understand and see this
hierarchy of
repositories so far we learned how to
create a Java class out of a database
table and this Java class is the
representation of the table in our
database now we have another question is
what can we do do or how can we do when
it comes to database manipulation and
interacting with the database means if I
want to persist a new object into or a
new row into this author table so how
can I do this so the answer is using jpa
repositories all right so but first
let's understand and give a quick
definition of this repository so a
repository is an abstraction to reduce
use the amount of boilerplate code
needed to implement the Dow layer or the
data access object to interact with the
data stores in theep in Spring data jpa
a repository is a Java interface that is
used to abstract the data access layer
from the business logic it is used to
perform crude operations such as create
read update and delete so this is what
crude stands for uh like and then as
well as other common database operations
such as paging and sorting so
repositories are typically defined as
interfaces that extend one of the spring
data jpa repository
interfaces such as crude repository
paging and sorting repository or jpa
repository so this has been a bit
changed since uh spring 3.0 and I will
show you the difference right now so
these interfaces provide a number of
predefined methods that can used to
perform common database operations such
as saving and deleting entities finding
entities by their primary Keys finding
entities based on various criteria and
so and so forth and we will see in deep
how we can create data or can create
queries using the spring data jpa
repositories so but first let's
understand or see the hierarchy of the
spring data jpa
repositories so as we can see here
that's why I told you before that it was
slightly uh changed about when we talk
about paging and sorting repositories
because now the new architecture looks
like that so we start as we mentioned by
creating an interface so for our for our
example we want to create an author
repository and then we need to extend
one of these five repositories that we
see right here all right but let's start
start and see the uh inheritance from
the lower level from the lowest level to
the from the highest level to the lowest
one actually it's the the other way
around so we first can start by EX
standing jpa repository right here and
this jpa interface uh repository it also
extends two other interfaces at the same
time so it extends the list paging and
sorting repository and list crude
repository so this list crude and list
paging so both of them they contain
methods like that's that this is where
comes the difference because there have
been a small refactoring in this
interfaces so now we have all the
methods that returns list they are
within this list paging and sorting
repository so this in order also to to
reduce more the the boilerplate code
because for example if I want only to
perform crude operations with I don't
need list so I can only extend this
crude repository same for paging and
sorting but if I want everything all I
need to do is extending this jpa
repository so let's continue so here we
see or we said that uh the jpa
repository extends at the same time list
crude repository and list paging and
sorting repository and the list crude
repository already extends crude
repository and this crude repository
also extends the basic uh interface
which called repository the same way
when we when we take the left hand side
uh part so when we talk about jpa
extending list paging and sorting
repository this interface itself it also
extends the paging and sorting
repository so now let's go
ahead and see the code or the Implement
well not the implementation but the
interface which was created by Spring
data jpa so go back to your
inj hit command shift o or control shift
plus n for Windows and Linux users and
just type jpa repository and you will
see that we can open the Java class or
the repository if you already downloaded
the code and we can open it and it's the
one spring data jpa the version
3.0.0 so if you are using a previous
version of spring boot this might be
slightly different
okay but our course is fully focusing on
Spring 3.0 because we want to see the
new changes and we want to use also the
most recent versions all right let's go
back in here so we see that we have here
our jpa repository interface which is
extending at the same time list cud
repository and list paging and sorting
repository so this query by example
executor so this is something else we
will see uh later on so that's why I
didn't mention it in the in in this uh
in the diagram so let's go back and and
focus on this so here we have this list
crude repository if we open it we see
that this list crude repository is
already extending the crude repository
and list crude repository contains all
the listing methods so save all find all
find all by
ID and then when we open this crude
repository we see that it also extends
the repository interface and this screw
repository contains
uh these methods like the crude method
save save all find find by ID and so and
so forth all right and the same way if
we want to go to list paging and sorting
so here we have this find all within
this list paging and sorting repository
the same when we go to the paging and
sorting repository interface we see that
we have this find all find all and so
and so forth and this one like we see
when we talk because when we talk about
p paging and sorting we mainly talk
about lists so we have here the first
parameter for the find all is sort and
the second one it's a pageable and the
pageable also contains the Sorting so we
can when we if we want we want to use
this one so it already covers this all
right but make sure that the return type
of this one is iterable and this one is
page so this is just to mention and as
we said both of them they extend the
repository interface all right
so if you have any questions don't
hesitate to drop me a message otherwise
let's move on and
continue first of all we will create a
repository for this author model or this
author entity but first of all Don't
Panic if you see that I removed the code
and don't worry you will not be losing
the code because here it's just a
cleanup and you can find all the code
when you go to git right here and then
you click on the logs you will see that
after each chapter I will commit or have
a full commit right here so if you
double click on this author you will see
all that you all you need so here you
have the entity you have all the
annotations the strategies and so and so
forth so you will see all the changes
that we will do in each chapter so don't
panic don't worry about about that so
it's just for me to have a clean code
for each step all right so now in order
to create a repository it's so easy so
here I will create a
new package or I can create a class and
a package at at the same time so here
create a package called it
repositories and then Dot and the class
name or the repository name and don't
forget to select interface because we
mentioned that a repository is an
interface that extends another interface
one of the jpa repository interfaces so
uh let's call it author
repository hit enter so here we see that
we have a public interface author
repository and in order to transform or
to tell spring that this is a jpa
repository we need to extend one of the
J one of the repositories okay the
repository interfaces so for our case we
will extend the jpa Repository
so because within jpa repository we have
all the methods and as we saw before
this jpa repository it's a generic
interface that takes two types the first
one is T which is the class or the table
and the second one is the ID and this is
the unique ID or the type of our ID
within our entity all right so if here
it's integer so we will pass integer if
you use string long uh big decimal and
so on so forth just pass the type all
right so let's finish this one so it's a
repository or jpa repository of our
object author so this will help uh
spring data GPA to determine and
correctly write the correct queries okay
and of course we we want our ID which is
of type integer okay so like this we
have our first repository now let's go
ahead and play a little bit with this
repository and create or insert some
data and see how we can use this
repository now in order to test this
repository right here we need to create
a service and then create a controller
expose the endpoint and use Postman or
like Swagger UI to test this uh
repository or test this methods and so
and so forth so the process might be a
bit long but let me show you a better
way how to do it okay so we will use a
command line Runner and the command line
Runner is uh a bean or is a method that
will be executed at the application
startup okay so when we first start the
application we will run this method and
within this method we can inject any
Bean which is available within our
application context all right so to do
so let me close all this go to the jpa
application or your main application
file the one where you have the spring
boot application because this is the
startup
class and then just create a bean all
right so add the bean annotation and
here a public beans always should always
be public don't forget that and the type
is command line run
R all right so this interface right here
command line Runner give it a name
command line Runner and within this
command line Runner uh method or Bean
you can pass any type you want right
here okay so it's like that and now I
want to inject my author repository
right here okay so I will create an
object of type author
repository I will call it repository as
a simple name so like this automatically
this Bean or this auor repository will
be injected okay so now to implement
this let's use a Lambda
expression so let's say
return args or something like that and
then Arrow function and that's it and
inside this method we can implement or
we can do whatever we want within this
repository okay so let's go back check
quickly our author method so here we
have the data no arcs Constructor entity
and so and so forth I will just add two
annotations the first one is all arcs
Constructor to have a Constructor with
all the arguments and the other one is
the Builder annotation so the Builder
annotation it's for uh the design
pattern Builder which help us create and
building objects so I will show it to
you right away so now to use this
Builder uh annotation or this Builder
design pattern I will create a VAR
called it author so you can use VAR
because we are uh using Java
19 so equals
author do builder. build so you see
because we have this author because we
have this Builder annotation now we can
use this build or Builder method so you
see already in the icon right here this
is the lombok icon and yeah so and then
I will just type
build all right so uh this Builder help
us like we can use the field names as as
methods so first name email and so on so
forth to create or to instantiate an
object all right so uh let's have first
name I will call it
alibu last name also
alibu let me make this one full
screen uh age okay I'm going to I'm
going to give you my age I'm getting a
bit
old okay so email here you can find my
email if you want to contact me so it's
contact at alibu coding.com
and that's it so these are the
information that we need to create an
author object now let's use our
repository dot
save all right so within the repository
let's go ahead and have a quick look on
the methods that we have right here so
we have save count count delete equals
uh delete all delete all by ID so all
these methods they come from all the
interfaces that we saw together so like
we have a pre-built methods that we can
use without any need to create uh
methods our own like or to type or
create queries manually so we can use
spring data jpa or the repositories to
create a bunch of methods or many
methods that uh can make our life so so
easy so for now I want just to test the
save method so I want to save this
author object okay so at the application
startup when I run the application this
Bean will get executed
and and it will insert a data or a line
into the database okay so uh let's start
the application and test this
one
all right so the application is running
right now and let's first check the logs
we see that we have a first log from
hybernate which is Select next Val from
author seek or like this is the sequence
so hibernate will get the sequence or
the next value from our author sequence
and then we see that we have an insert
into author age email and so on so forth
and here we have the values so here it's
like just uh interrogation mark
because uh it will not print out the the
execution but here it's logging already
that you are inserting something into
the database now let's open our database
and check that we have our data so I
will open this author table uh first Let
me refresh because we renamed few
staffs yeah now we have our author table
go ahead open it and we can see right
here that we have this ID we have the
age email and so and so forth so here
like the the object he got executed this
Bean got executed and now we see that we
have some data within uh our database so
also this might be useful for you if you
need to execute something at the
application startup you can use this
command line Runner so we will be using
it uh in the future Maybe to uh to test
few things all right so yeah that's it
let's move on now and answer one small
question at the application startup when
we execute this block of code or when we
execute any kind of this code in service
or in controller or whatever so I mean
when we create an object and we try to
make a transaction to our database
saving it deleting it reading and so and
so forth so we call this a transaction
but this is not the main um goal of this
part but first of all we want to
understand what is the life cycle of an
entity okay and to understand this let's
go ahead and open this diagram right
here in order to understand what is a
life cycle okay so in in hibernate an
entity is an object that is persisted to
a database table and the life cycle of
an entity refers to the entity to the
different states that it can be uring
its existing from when it's first
created until it's eventually removed
from the database all right so let's go
and check these four states of a hybern
entity
okay so the first one here we have the
first state which is the the state
transient and this is the state of an
entity when it has just been
instantiated and is not associated with
h with a hibernate session an entity in
this state is not persisted to be the
database and is not managed by hibernate
this means what means when we have or we
create create a new instance of our
author object or we use the Builder for
that so we move from the object to a
transient object right here so at this
level our object is still transient it's
not persisted and it's not yet managed
by hibernate but once we execute one of
the following methods save persist save
or update or update so like this we will
move from the transition
state to the persistent state so the
entity or this object will become a
hibernate managed object all
right all right let's talk about and
explain this persistent state so this is
the state of an entity When It's
associated with a hibernate session and
is being managed by hibernate an entity
in this state is persisted to the
database and any changes made to its
properties will be persisted to the
database when the transaction is
committed so here when we do or when we
operate any kind of this operations
right here so the state will become
persistent and any updates so if we made
any if we make any updates to these auor
object and we execute one of them so
this change it will be affected or
applied to the database one once the
transaction is committed all right so
now after this trans after this
persistent State we can move whether to
the removed state or to the detached one
let's talk about the detached State
first so to detach an entity the detach
is this state of an entity is when it
was previously associated with a
hibernate session but is no longer
associated with it it all right and an
entity in this state is persisted to the
database but is not being managed by
hibernate any changes made to uh to its
property will not be persisted to the
database until the entity is reattached
to a hibernate session so let's focus on
this until the entity is reattached to a
hibernate session session so this means
what once we execute one of the
following methods detach close clear or
evict the state of the hibernate entity
will pass from persistent to detached
okay and here when the entity is
detached we have two choices so the
first one we can go back to the
persistent state or we can just go to
the garbage this object will just move
to the garbage right here okay but let's
first talk about this uh word that we
said until the entity is reattached to
the hibernate session to reattach the
entity to the hibernate
session we can use one of the following
methods save save or update merge merge
or lock so this means what means within
one method we can save we can create the
object so it moves to the trangent save
it so it goes to persistent
and after the persistence or after
saving the entity we can do some logic
and then we call the session the hyet
session. detach so it will move to the
detached State once it's detached we can
also change some properties for example
and then we can call back this one of
these methods save save or update and so
and so forth so it will go back to this
persistent state if if not or if we
don't execute one of these methods so
the entity will just go to the garbage
so it will no longer become hibernate
managed entity okay so now let's go back
to this persistent state so from this
persistent State we we can move to this
removed State all right so to move from
persistent to removed we need to execute
a method or a delete Method All right so
the removed is the state of an entity
when it has been deleted from a database
an entity is in the state in this state
so in the in the state removed is no
longer persisted to the database and is
not being managed to by hibernate so
once we delete an entity so it passes to
the state removed and then automatically
to the garbage okay and here let's talk
about a little bit and explain this
state or moving the object to the
garbage as you can see right here if we
create an object if so it's in the
transient state so from the transient
state it will move to the garbage if we
do not execute any of these methods okay
once we persist an object and then we
try to detach it so and then we we do
nothing it will also go to the garbage
okay again from this persistent State
once we perform a delete uh operation it
will go to removed state so it will the
state will become removed and then it
will move to the garbage again now we
can go here from this state from this
author directly to this persistent state
so this means what this means when we
try to perform a get operation find all
find by ID and so on so forth so we will
directly go to this persistent state so
because here we we don't need to
instantiate any kind of uh data but we
just want to call our session management
or persistent uh persistence
entity or entity manager to get or to
fetch data directly from the database so
we move from this initial State directly
to a persistent State and then we can
move to these different other states so
we can perform a detach save delete or
remove all right so this is the
hibernate entity life cycle but here
something uh something really important
to know about so we with using spring
data jpa we no longer need to care about
all this life cycle because it's
automatically managed first of all
second so this save persist detou and so
and so forth is being handled in the
background so we don't need to
automatically uh commit the transaction
or detach The Entity and so on and so
forth because spring data jpa will do
the job for us so now we know and and we
understood what is the life cycle of our
entities let's move on and explore other
important
things if you have any questions as
always do not hesitate to drop me a
message otherwise let's move on
previously we've been playing around
this author entity now what about if we
talk about this whole class diagram and
how we can realize it okay but before
that we see that we have relationships
between the different entities we have
the many to many one to many and so and
so forth but first of all what is
relationship and why we need
relationships in in a database
relationships between entities can be
used to represent the connections and
dependencies between different pieces of
data and there are several types of
relationships that can be created
between entities such as one to one one
to many and many to many
relationships creating relationships
between entities allows you to model the
real world relationships between
different pieces of data more accurately
which can help you better understand and
analyze your data it can also help you
to enforce data integrity and prevent
inconsistencies by ensuring that changes
to related entities are coordinated and
consistent with each other in addition
to modeling real world relationships
creating relationships between entity
can also improve the performance of your
database by using relationships you can
avoid storing redundant data in multiple
tables and instead use foreign keys to
reference related data in other tables
this can help to reduce the size of your
database and improve query performance
overall creating relationships between
entities uh is an important part of
Designing a well structured and
efficient database it can help you to
model real world relationships more
accurately enforce data integrity and
improve the performance of your database
so when you work with SQL databases
always think about adding relationships
this is important to improve everything
and ensure Integrity or your data inte
Integrity now before moving on and start
implementing uh this class diagram and
um creating relationships between the
different entities let's explain one
small thing so here we have for example
this course entity and this author we
see that we have one relationship here
it's many to many relationship because
we said that an author can create uh
multiple courses and one one course can
be created by multiple authors so that's
why we have the many to many
relationship all right so here we have a
questions this question is how can this
relationship be done and the answer is
here we are not talking about
annotations we are not talking about
anything but the focus or the main focus
in here is the type of the relationship
so here we can identify two types we
have unidirectional relationship this
means that one entity has a relationship
with another entity but the other entity
does not have a corresponding
relationship within the first entity
this means that the relationship is
defined only on one side of the
relationship this means what like when
we talk a bit uh code right now this
means when we create uh for example the
course entity and we want to link this
course entity as a many to many
relationship within the author so we
create an attribute or a list of authors
uh within the course uh entity and give
it The annotation many to many and
that's it so this is what we call
unidirectional relationship so it's from
only one side now now what if we want to
make it BD directional so in a b
directional relationship both entities
have a relationship with each other so
this means that the relationship is
defined on both sides of the
relationship so first of all we created
a list of authors right here and it's
referencing the author now to make it B
directional we need to create a list of
courses in the author entity right now
right here so like this we will
ensure that we have a b directional
relationship in general UD
unidirectional relationships are simpler
and easier to understand but they do not
allow you to navigate uh the
relationship in both directions means
you can you can navigate from course to
author but if you implement unique any
directional relationship you cannot
navigate from author to course so it
only ensures one way uh oneway
navigation but B directional
relationships are more powerful and
flexible but they can be a bit more
complex and require more care to
maintain the Integrity of the
relationship that it also ensure a b
directional navigation from both sides
so from author we can access the courses
and vice versa now let's move on and
start creating all these classes let's
create let's create and Implement
everything we have right here let's
start now by creating our entities so
what we will do is we will create a Java
class and give it the entity annotations
for each of these classes that we have
right here but we will not do any um any
mappings any relationships we will just
create Java class scores for example
with an ID title description and so and
so forth so this is what we will be
doing right now and then we will move on
and Implement and explain in details all
these relationships and annotations that
we can
use so let's go back to our anj I will
close all these
tabs and within our models
package I will right click and create a
new class I will call it course
so here like as we did with this author
we can use the same annotations right
here so we need the data no arcs
Constructor or all arcs Constructor the
Builder and especially the entity
annotation because we need it to make
the class or the course. Java class an
entity but just I will copy paste them
to make it uh much much faster all right
so this this course right here let's go
ahead and create few fields we have an
ID we have a private
string
name and we have also a private string
description and that's it so here we
have our entity next let's add the ID
annotation because we need it and we
have also the generated value and just a
reminder of always make sure you use the
Jakarta persistence if we if you are
using the spring 3.0 otherwise it's
still Java x. persistence for the
previous versions so generated value and
we will leave the strategy to hibernate
to decide which strategy is better for
us next let's
create the section entity so I will call
this class section paste the same
annotations we we used before and now we
need to create a private integer
ID and
private string name the section
name and also a private int order so we
want to give an order for it for each
section all
right okay now as always we need this ID
annotation and we need this generated
value annotation right here okay so
that's it within this section uh entity
let's move on and create the next one
let's now create the lecture entity so
right click right here new class and
call it
lecture as always just paste the
annotations that we will need and now
let's create an integer ID
attribute and then we need also the
private string lecture name so that's it
we have only an ID and a name within the
lecture and now let's add the ID
annotation and the generated value so
this should be an easy task for you and
let's move on and create the next one
now we will create this resource entity
but for the moment we will not create
this uh inheritance video file and text
but we will leave it for later when we
will explain The Inheritance within
hibernate all right but for now let's
just stick to this resources entity and
create the following
attributes so go ahead right click on
the models package create uh a new class
and just call this one a resource always
paste the annotations and we have here a
private integer
ID private
string name resource name and private uh
int
size and we have finally private string
URL so this represents the URL of the
resource and do not forget the ID and
the generated value
annotation so that's it now we have all
our entities created let's now move on
and start implementing the relationships
one by
one now let's start establishing and
creating relationships between our
entities so let's start from here let's
create the one many to many relationship
between the author and the course and as
we explained before an author can create
multiple courses and one course can be
created in collaboration of multiple
authors that's why we have the many to
many relationship in here here now let's
go back to our entity
J and as we mentioned before when we
talk about many to many relationships or
many relationships the first thing that
we need to think about is creating lists
okay so let's open our author entity and
scroll down here and first of all create
a private list the list is always from
the Java util package and we want to
create a list of course okay and let's
call it courses so this is the first
step Second Step go also to this courses
uh entity and in here create a
private list of authors okay uh author
and let's call it authors all right so
this is the first two steps next we are
talking about many to many
relationships so let's add many to many
right here and many to many also on the
course
level so now we defined or we have our
many to many relationships
okay but now we need to define something
we need to define the owner of this
relationship so because we have the
owner and the reverse relationship and
in many many relationships in jpa one of
the entities is considered the owner of
the relationship and is responsible of
maintaining the foreign key values in
the joint table and the other entity is
considered uh the inverse of the
relationship and does not have any
foreign keys in the join table all right
so to do so once you decide which of
them should be the owner of the relation
ship just go to the other one that you
want it to be the inverse relationship
and give it uh the map it by attribute
like give it the value all
right so for our case we want the course
to be the the owner of the relationship
so the author is the inverse
relationship right so within this
inverse relationship add this Mapp it by
and the mapet by should be or we should
provide the name of the attribute we
have right here so here it's called
authors just go copy and paste it in
here be careful about making typos all
right so if you make some typos this
means that you can also have exceptions
at the application startup okay so now
let's go back to the owner of this
relationship so for for our case the
owner is the the course and now to
define the the the join table of this
relationship we Define it from the owner
side so here we will use this join table
annotation and here this means or this
has a goal uh of creating a new joining
table between our author and courses
okay so uh for this joint table let's
provide some properties first of all is
the name the name is will be or will
hold the name of the joint table let's
call it
authors
courses means the courses of authors are
like you can call it whatever you
want
next we need to define the join column
and here we can we can Define multiple
join columns okay so the join columns
right here here equals and now we need
to pass a list of joint columns I will
just make it a new line so it it will be
more readable for you and now we will
use The annotation join column okay it's
always Jakarta
package and for this join colum we will
we need to provide the
name and the name right here let's call
it uh so this join colum is the one
responsible or the one that will hold
the information or the primary key of
the owner of the relationship so this
one will be the course
ID okay next Once We Define the join
columns we need to define the inverse
join column so when we when we say
inverse we are talking about the inverse
entity so here inverse join columns
right here equals and as the same way
here we need also to use at join
colum so join colum and let's give it a
name and here let's call it author
ID so like this or in this way we just
defined a many to many
relationship between our author and
course and to check that let's just
restart the application and see the
impact in the database and also let's
check the
box so here we
see all right so here we have uh we have
one exception and you see right here
it's caused because of this syntax error
near order because in
this lecture the sorry in this uh
section the order is a reserved name
okay so let's just rename it to section
order right or position or something
like that let's restart the application
again and see what
happens all right so let's first check
the logs here we have everything is
working fine and here we are creating
the sequences for each entity you see
that for each entity we have or we are
creating a sequence and here we have the
author we are creating the author and
the course and also we are creating the
author's courses the The Joint table
that we created for this author and
course entity we have also the lecture
resources and so and so forth and here
we are creating all the constraints all
right so and also here we are inserting
because we still have
this Bean right here so if you want to
stop it just comment this Bean
out comment this out and it will no
longer insert insert data so now let's
go and check our database so here
refresh it and now we should see at
least the author author course and
courses so here we have our colums so we
see that we have this ID age email and
so and so forth for from the author and
we have from the course we have this
three columns that we just defined ID
description and title and now from the
author courses we see that we have two
columns and you see for the primary Keys
it's a golden key but for foreign Keys
it's blue key so now we see that we have
this course ID which is referencing the
course and the author ID which is
referencing the author entity all right
so this is how we can create many to
many relationships let's move on and see
see how we can Implement relationships
between the other entities too if you
have any questions don't hesitate to
drop me a message otherwise let's move
on at this level let's implement the
relationship between the course and the
section so a course has m zero or many
sections so or one or many sections okay
and one section if we take one section
it belongs to only one course so here we
have one course to many sections and we
have many sections to one course so how
we can also explain this so when we
create a course we have the course but
every time we create a new section we
will have a foreign key course ID that
will be Associated within this section
class all right so let's see now how we
can implement this so at this level we
are talking about the course so and we
said that one course has many sections
so here when we say that we have one
course and many sections so list of
sections and let's call it sections okay
so this is the first
step because we have one too many so
it's always the the current instance or
the current object which is the course
has many sections so we create a list of
sections right here okay now let's go to
the
section you can do uh command click or
control B for Windows and Linux to
navigate to the definition of this so
here we said that many sections can
figure out or many sections belong to
one course all right so here this means
that we need to create a private course
element right here or um a field of type
course right here let's call it course
okay now from now to implement the
mapping so we go back to this course.
Java where we have the list and it's
easy like when we have the list always
think about one too many so it's just as
we explained it it's one core
it's one course too many sections so one
course too many sections all right and
here when we use one too many we need to
map it or to tell which mapping that we
need to use so here map it
by and this MPP it by it should be the
exact same attribute name we have right
here so just copy paste it and be
careful always about typos so here we
have this one to many now let's go and
navigate to the section entity So within
the section right here we said that many
courses or many sections so we said that
many sections they belong to one course
so we have many to one and when we use
many to one we need to specify the join
column so when we create a course when
we create a section right here what
should be the joint column name all
right so here we need to add or to use
The annotation annotation join column
and let's give it a name right here and
the name let's call it course
ID okay so now we just created a mapping
or relationship between the course and
the section so let's restart the
application and see the
changes so the application just started
right here and we see that we have all
these entities now let's go and check
our database and now what I'm expecting
is to see a foreign key called course ID
within this section class so let's do it
refresh the table right
here and let's check this section So
within the section we have four column
this is good and we see that we have for
one foreign key and this foreign key is
this one so we see it's uh FK let me
make it a bit bigger so we see that this
uh FK stands for foreign key and this is
the ID of this foreign key so the I the
name or the key of this attribute is
course ID and it references to the
course okay so it references the course
ID that we have within this course table
okay let's also check again the columns
right here so we see that we have an ID
name name section and course ID so like
this we are able to create or to make a
relationship between two entities using
one to many okay let's move on and
implement the next and if you have any
questions don't hesitate to drop me a
message now let's implement this
relationship between the section and the
lecture and it's also one too many as we
did for the course right here so this I
think it's an easy task for you and
let's go ahead and implement it quickly
so from the section level right here we
said that the section has a list or list
of uh lectures or many lectures so let's
go ahead create private
list lectures okay and let's call it
lectures and now let's move to the
lecture and create or reference it
within the object that we have so here
we have
private
section
section and now let's add the mapping
okay so we say that we have one
section one section to many lectures and
this one is mapped
by section okay so it should be just a
reminder it should be always the same
name that we have here now from the
section level as we explained before
it's one section to
many uh it's one lecture to many
sections and here many SE many
lectures can belong or they belong to
one section okay so here we have many to
one and do not forget to add the join
column
and give it a name and let's call it
section
ID all right so that's it let's restart
our application and check the diagram
and check that we have all the foreign
key correctly
created and here if we go to this
lecture I'm expecting to have this
foreign key right here which is section
ID referencing the section and also for
the columns we have the ID name name and
the section ID as a foreign key right
here so that's it let's move on and
implement the one: one relationship
between the lecture and the
resource now when we talk about a
lecture and a resource we talk about
onetoone relationship because one
lecture has only one resource and when
we talk about one resource it belongs
only to one lect
so that's how or that's from where we
got the one toone relationship okay just
as a reminder this part we will see
later
on now let's go back to our code now in
order to implement a one toone
relationship so first of all Define your
uh your entities and in here we have uh
our section and also we have our
resource so from the section
level
let's create a private
resource let's call it resource okay so
when we talk about onetoone
relationships we can talk about one uh
unidirectional or B directional mapping
okay so we can link the lecture to the
resource and that's it so we will have
uh the owner of this relationship is the
lecture and we can access the resource
from the lect lecture but when we want
to go back uh or access the lecture from
the resource we will not be able to do
that because we don't have B directional
relationship so let's start with
unidirectional relationship now in order
to Define uh onetoone relationship as I
mentioned create an object of the the
other entity so in our case it's an
object of type resource and here we need
to use the one to one relationship okay
so here we have the one to one we can
also Define the join column name that we
want to
use and here let's say resource
ID all right so this is how we can
define a onetoone
relationship and then let's restart the
application and see the impact of
this so now we see that the application
started let's let's check the
database now if we go to the lecture we
see here that now we have two foreign
Keys the first one is from the resource
the one we just created and the second
one is we the one we previously created
from the section but here we need to
focus or we want to focus on this
resource ID from the resource okay also
if we open this one we can see that we
have a new uh column defined here which
is the resource ID
okay let's go now and implement the
second way or like the B directional one
to1 relationship so just to make it
faster I would just copy these
annotations go to the resource entity
and as we did before let's create a
private
lecture and let's call it lecture right
here okay and now let's paste this one
to one annotation and join column and
this one let's call it lecture
ID so here this means when we want to
create um when we want to create a new
lecture and a new resource we need to
link them together in order to have this
B directional relationship okay so as we
mentioned before like having B
directional relationships make it a bit
complex to maintain all the foreign Keys
all right so let's go back restart the
application and check the
database so the application is starting
right now let's open the database and
see refresh
it and let's see now from the resource
we will see that we have one a new
foreign key which is the lecture ID and
it's referencing the lecture right right
here so like this we just created a
onetoone relationship between lecture
and resources all right so that's it we
just implemented all the relationships
between all our entities and classes
let's move on and I want to show you how
you can check that what you created is
the same as your class
diagram now for the people having the
the ultimate version of an and using
this database to check the data and
refresh the data and refresh the
database and check the tables so there
is one thing that we can do so here when
you click on this database you can right
click on it and here we have in the
bottom you have diagrams okay and you
can show a visualization or you can show
it in a popup let's show show the first
one and here it will generate all the
tables of our database okay so you can
also uh you can also click on this icon
to apply the current layout and it will
reorganize it and here we see that we
have our
author right here we have our author
table let's just try to organize it a
bit and we see right here within this
diagram that we have the same one as we
already did designed at the beginning of
this of this course so we have the
course and the author and here we have
the the join table between these two one
because we have a many to many we also
have a relation between our course and
section and the same between section and
lecture and we see that we have this
onetoone relationship between our
lecture and resource all right so like
this or this tool might help you
checking if you have the correct
implementation or if you did the correct
implementation or not so just go ahead
use it and you can also compare it with
this diagram that we just created so
just double checking we have author
courses section lecture and resources
and it's the same diagram that we have
generated right here so this one it will
use the database and all the
relationships that we already defined to
draw this schema so uh uh that's it
about all the relationships now let's
move on to a bit more deep and important
uh stuff that we need to learn together
if you have any questions don't hesitate
to drop me a message send me an email or
contact me on social media and also you
can go and ask your question on Discord
I will create a special channel for this
course so just go ahead and ask it
otherwise let's move on previously we
said that we will leave this part right
here where we have this resource video
file and text entities to uh further
part so now it's the time so here as we
can see so this is the symbol of
inheritance and we have this resource
class we have also these three classes
video file and text so this means what
this means that a resource can be at the
same time uh um can be whether a video
file or a text so here we have video
extends resource uh file also extends
resource and same for the
text so in Spring data jpa you can use
inheritance to define a base class of
your entities and then create a subass
that inherit from the class or from the
base class so this can be useful if you
have a number of entities that have some
common properties and you want to avoid
uh duplication code or duplicating the
code
okay and when we talk about inheritance
in Spring data jpa there are several
ways to implement this inheritance so we
have the single table strategy also we
have the joint table strategy and table
per class strategy so we will see all of
these strategies in details
but here we need to talk before we go
and we before we leverage inheritance we
need to talk about pros and cons for
each one for for this inheritance so the
pros or the advantages of uh inheritance
is first of all code reuse so because
inheritance allows you to reuse common
code among multiple
entities also simplified queries with
inheritance you you can create queries
that span multiple entities without
having to write separate queries for
each entity now let's talk about the
cons or the disadvantages of
inheritance so first of all is the
complexity inheritance can make the
database schema more complex especially
if you are using a strategy like join
table per class or table per concrete
class also we can talk about rigidity
because inheritance can make it more
difficult to change the Bas class or
other new sub classes because it can
affect the entire inheritance hierarchy
so this means every time you need to add
a field or you need to add a new
attribute within the Base Class you need
to really be careful about the sub
classes or the derivate classes that
extends this Base Class so this is
mainly the pros and cons of
inheritance before we move on and start
implementing The inher Inheritance
strategies I want to highlight something
which is really
important which is composition over
inheritance because both inheritance and
composition H are ways to achieve code
reuse and modularity in objectoriented
program in in general it is recommended
to favor composition over inheritance as
composition is more flexible and easier
to CH to change because inheritance
evolves creating a sub class that is
specialized version of a base class so
the sub class inherits the properties
and behaviors of the base class and can
also have additional properties and
behavior of its of its own this can be
useful way to share code among multiple
classes but it can also make the code
more rigid and difficult to change if
you need to make a change to the base
class it can affect all the sub classes
that inherit from it which can be
difficult to
manage composition evolves creating a
class that has reference to one or more
subjects and delegate tasks to these
subjects this allows you to combine the
functionality of multiple classes into a
single class without the inheritance
hierarchy of a base and
subass composition is more flexible than
inheritance because you can change the
object that a class delegates without
affecting the class itself so in summary
it is generally recommended to use
composition over inheritance because it
is more flexible and easier to change
however the best approach will depend on
the specific needs of your application
so this is the comparison between
inheritance and composition and as I
mentioned it's all it's always
recommended or generally recommended to
use compositions over inheritance okay
now let's go and dive into these
inheritance strategies in case you want
or in case you need to use inheritance
within your application so let me teach
you how to use it in the correct
way now imagine with me that that we
want to add some auditing fields to our
entities uh means I want to add some
information to track uh the creation and
the last modification of each entity or
of each line uh of my tables in the
database this means for for example this
course entity or this course class I
want to add four field uh like the
created ad last modified ad and also
created by and last Modified by same for
author section lecture resource and all
the tables that I will create within my
database okay so in this case uh I will
have four Fields including this ID we
can five in each entity but this is okay
from the database but now when we talk
about the code our code I want to avoid
this code application and I want to
organize it much much better okay here
we can use one technique to achieve this
one and it's going to be something like
that we will have a kind of Base entity
or we can call it abstract entity or uh
parent entity you can call it whatever
you want and in here we will move or we
will try to um to collect all the common
fields between the entities we have or
between the Java classes we have and for
example we have this created at last
modified at created by and last Modified
by and I want all these fields to be
part of all the entities I have within
my
database so for this it's super easy
here we will use inheritance we will
create a class we will call it base
entity and all the classes I have right
here they will extend this base entity
okay and this base entity needs to be
annotated with a special annotation and
this annotation is called map super
class so this annotation indicates that
a class is a super class that is mapped
to a database table and this annotation
is used to define common
properties uh that will be shared by
multiple entities without creating a
separate table for the super class this
means the the only existing or existence
of this base entity is within our code
but from the database side we will not
see any table called base entity so now
let me show you how we can do
this
let's go back to our anj and here within
this
models uh package let's create this new
class okay so let's create a class
called it base entity or base class or
base table call it whatever you want so
this base entity first thing that I need
to do is I need to give it a maid super
class entity and as as you can see it's
always from Jakarta persistence do mapet
superclass so this means and this this
will indicate that this class is a maid
super class and any entity that will
extend this one will inherit also all
the fields that we have right here okay
and for this I will create a private
local
daytime uh this one for example created
ad I want to add a
private so this one last modified
ad and I want also to create two strings
for example this this is this is just an
example and you can create or you can
move all the common fields that you want
into this base entity so here I will
will create a string created by so to
track who created this entity I mean
like the the user who created this
entity and we have also last updated by
or last Modified by
okay all right so here within this maid
user class we can use all the all the
Jakarta all all the persistence um
annotations like colon last Modified by
last created by and so and so forth so
it's a normal entity but it's just
within our Java code base okay now also
let's check right
here for all the classes or for all the
entities that we created right here we
have this integer value uh this integer
ID which represents the ID of our entity
so also if you have always the same name
for um for for all the entities what
what we can do also we can also move
this entity right here to this base
entity right we can use this field right
here so now we can see that we have this
ID generated value and so on so forth I
will also just go ahead add some lbook
annotations to generate the Getters and
Setters and so and so forth all right
so I will just copy this one and I will
give you a small hint which is super
important uh here when we work uh with
lombok so here we see we have all the
Getters and Setters but here within this
one this is going to be the parent
entity and we want to use a builder when
we use a builder within uh dant class or
the the child class we will not be able
to access this Fields right here and to
do so uh lombok they created uh an
annotation called super Builder from the
for now it's from the package lombok do
experimental and might be moved uh later
on but The annotation is called super
Builder all right so here what we need
to do first is use this super Builder
with all the entities that we will that
will extend this base entity or in any
case if you have inheritance between
your classes and you want to use this
Builder annotation just go ahead and use
this superb Builder instead all right so
now let's go back to this author uh this
author entity and we see right here this
one is in red because we don't have the
primary key but once we
extend our base entity this error will
move on okay so this this is now is this
is now gone all right and also when we
use inheritance and we use this data
annotation we we need also to add the
equals and hash code annotation all
right and here it needs to call the
super so these are some hints for you
when you want to use correctly all the
annotations from lombok and also from uh
from the pist from the jpa or Java
persistence API also go ahead and check
my C about lbook and the useful
annotations that you can use and also
how they work all right let's move on
right now I will also make these changes
to all the entities we have right here
and when we restart the application we
want to make sure that we have
everything as we had before plus I want
to see these four Fields right here okay
so I will go ahead and do it for all of
them so what we need to do or the way we
need to implement this so let's first
replace this Builder with super super
Builder and let's extend the base entity
next we need to remove this ID field
with this with the
annotations and that's it so this is how
we can extend or this is how we can
inherit from this base entity and keep
everything working fine also don't
forget to add the equals and hash code
annotation let's do the same for
lecture and so this one ex
stands base entity let's move this ID
field you can skip this one like for the
rest of the entities if you are familiar
with that and here and I will also
do add think equals and hash code all
right so next one is resource same thing
here let's also extend our base entity
right here and remove this ID
field next one is
section and then we will restart the
application and see the changes so let
me remove
this and extend the base entity all
right replacing also the Builder with
the super Builder and here we also need
to add the equals and hash code and then
you can optimize the Imports to have
your code as clean as possible all right
so here what we have or this is what we
have right now let's go first and check
the database make sure that we have
everything as before before restarting
the application let's make sure that we
have the same structure and the same
tables that we have right here
okay so now go ahead start the
application because I stopped the
application that's why we don't have any
tables right now because we have the
property create drop but let's start the
application
first so everything is started and we
have all the all the entities but we
don't see that we have a base entity
getting created and this is what we
expect now I will refresh the schema
right here and we see that we have this
six tables all right author and this is
the The Joint table and if I open this
author I see now I have nine columns
including this created ad created by and
last modified
also I still have the same ID and this
ID is inherited from this base entity so
this is how you can uh group The Common
uh the common fields within one entity
and this can make your your code uh a
bit cleaner and you can group and if you
want for example to change the type from
local date time to for example just uh
java.sql
.d here instead of this local date time
you can do this change only in one place
instead of doing this change in all the
places also for example if you want to
link this created by and last Modified
by to the real user table in the
database you can just update and modify
in one place so this is how the the maid
super for class
works and as I mentioned uh like finally
before we end this part using the maid
super class annotation can help you
avoid duplication of code and make it
easier to maintain common properties in
large applications however keep in mind
that the maet super class does not have
its own table so do not forget this one
and if you want to use a mapet super
class entity so do not expect to have a
separate or its own table and it cannot
be queried or persisted directly so we
cannot query this base entity and we
also cannot persist this base entity it
can only be used and a base class as a
base class for for entities all right so
if you have any questions don't forget
to drop me a message otherwise let's
move
on now let's talk about inheritance
within this part of our class diagram
all right so we have here just a
reminder we have our resource video file
and text okay so let's first prepare and
create these three classes right here I
will create class called video file and
text and then let's explain and see how
we can implement the difference the
different uh inheritance strategies okay
so let's go back to our
inj and here again with this models uh
with this models package I will create
three uh three classes but first I want
to go and open this resources and I will
just roll back all these changes I mean
I will um I want to use this integer
right here why because we cannot extend
multiple entities or multiple classes uh
using Java all right so this is the only
and unique uh reason for that so because
our Focus right now is the inheritance
uh regarding this resource otherwise I
will I can also show you how how we can
do or how we can uh Implement multiple
inheritance all right okay so uh this is
what we have right here and now I will
just go ahead and create my first
class I will call it video and this
video VI it will have also the same uh
without the entity I will just copy
this the these annotations the lombok
annotations but here instead as I
mentioned before it will be or it should
be super Builder and for this video I
will have uh right here a private int
length so it's just the length of the
video I will
create
another class like we have right here we
have file and text
okay now I will
create a file class so this file it also
will have the same annotations and here
I will use the super Builder
instead do not forget also to update uh
or improve the Imports and here I will
have just private private string type so
the type is just to say say if it's um
for example PDF txt word and so on and
so forth all right let's create now the
third class which is
text also do not forget to paste the The
lombo annotation and change this one to
a super Builder and within the text we
have our private content
attribute private
string content and that's it now we have
the three files or the three classes
that we have video file and text and now
we can go back and start explaining and
implementing the different inheritance
strategies using spring data
jpa let's first see the single table
strategy so this strategy is a way to
map an inheritance uh hierarchy to
entities to a single database t table
this strategy is used in hibernate or uh
spring data GPA or mainly when we talk
about the Java persistence API so jpa to
Define how inheritance is implemented in
the
database with the single table strategy
all subclasses of the inheritance um of
The inh Inheritance hierarchy are mapped
to the same table and then we talk we or
we need to talk about a discriminator
colum is used or we need to use it to
distinguish between the different sub
classes so the discriminator column
contains a value that indicates which
subass uh a particular Row in the table
belongs
to and within when the single table
strategy is used all of the properties
of the of the parent entity class and
its sub
classes will will be persisted to a
single table the discriminator column is
used to determine which subass a
particular row belongs to now the single
table strategy is the simplest way to
implement inheritance in the database
but it can lead to an efficient queries
and a large table size it is best suited
for situations where the number of
subclasses is small and The Inheritance
hierarchy is not deep so this is
theoretically uh how single table
inheritance works now let's try to
implement this first of all to implement
the single table single table strategy
so we go first of all to the parent
class or the base entity or whatever you
can call it whatever and in our case
this is uh uh this is our base entity or
the parent class but first of all here
this one needs to be super Builder
because if in case you need it later on
and now here we need two things we still
have this entity annotation which we
need and we need also to add this
inheritance annotation and and it's the
one from always Jakarta persistence all
right and within this inheritance uh
annotation we can Define we can Define
the strategy and here we can see that we
have joined single table and table per
class all right but as you can see right
here by default it's using single table
so whether you precise single table or
not it will be by default single table
okay so you can just use inheritance
annotation without the strategy so it
will take as a default value the single
table all right so this is the first
first step now let's go to this video
files and file and text and in here
optimize the import first let's collap
this one and now within this uh this
video I will just add the entity
annotation
okay so the same and here from this
video we need to
extend our resource because a video is
also a resource right and don't forget
with this data annotation from lombok
when we use inheritance or we extend
another class we need also to implement
the equals and hash code with the
attribute or the property called super
equals true this is just a reminder for
you let's go ahead and do the same for
file so here we need the entity
annotation and now we need also to
extend our resource entity
and then we need to add the equals and
hash code annotation let's do the same
for
text
entity let's extend resource right
here and finally we add the equals and
hash code annotation all right so here
we have everything up and ready for us
okay now let's restart the application
and see what will happen with only this
configuration that we wrote right here
so click on
restart so now the application is up and
running and we see that we have no
exceptions so everything is good so far
let's move this one and here let's go
back to our database click here and
update or refresh the database so we
have the inheritance within the resource
Source uh column and we see now that we
have nine columns within this class okay
so we see here that we have uh ID name
and so and so forth but we see here that
we have the extra and we see here that
we have the size this one the this is
the one coming from uh from the from the
file or from the video we have also the
type we have the content and so so and
so forth we have also the length and
what happened right here with this basic
configuration so hibernate he grouped
all the he grouped all the fields within
the B the parent uh the parent entity so
everything now is within this resource
and if we want for example to create a
content and so on and so forth if we
want to create a new instance of type
text we need to fill all the information
including other information from the
resource including the content okay now
let's try
to to give some more differentiation
between the entities all right so let's
see what we can do as extra
configuration to make this more clean
and More Beautiful to use all right so
now let's talk about this discriminator
value this discriminator value will give
a value that we will SP specify in
advance to each type or to each derived
class so for example if we give uh the
value V for video F for file and T for
text we will add uh a column called type
right here to the
resources and then this resource type
every time you create a new instance of
video this type will be automatically v
f for file and T for text all right so
let me show you how we can do that so so
here we have our inherit inheritance
strategy which is single table now we
need to add an another annotation which
is discriminator colum and this one it's
just to give the discriminator colum
name and here for this name by default
it's D type if we do not if we do not
precise this colum by default it will be
D type like we have right here okay so
it's the discriminator type
but let's give it uh a special name
let's call it resource
type all right so from the parent uh
class or the parent entity we need to
add this discriminator column to specify
the column that we want to use otherwise
you can leave it to the default one
which is D type all right now let's go
to the different uh different entities
now after this entity annotation
just go ahead and add a discriminator
value so this discriminator value let's
for example as we mentioned before let's
give it V for video I would just copy
this annotation and paste it in
different entities f for file and T for
text so now if we restart the
application we will see that instead of
this dtype column we will have our
resource type column right here so I
will restart the
application and here the application is
restarted let's open the database and
refresh it again so refresh this
resource table or all the data uh all
the database So within this resource we
see that we still have nine column and
now our column is called resource type
all right and we have this name size and
so on so forth those are the attributes
that we have from all the children
classes all
right now if we create a new instance or
if we want to persist a new
file we will create all uh we will
insert all the data including uh for
example for the file right here we have
the type we will say for example PDF
right here and all the information and
automatically this resource type will be
V so the value of this resource type it
will be automatically uh F sorry not V
because F is for file so it will be f
for file and it will be V for video and
so and so forth so you don't need to
worry about um to you don't need to
worry about filling this resource type
because every time you create an
instance of the children or the child
class it will be automatically filled
using this discriminator value all right
so this is how it works and in the next
step I will show it to you in action I
will um we will insert uh for example a
new file or a new video into the
database and we will see what will
happen let's see now in action how we
can uh how this is going to look like
all right so I will close everything
right
here and in this repositories package I
will create um a sample reposit for this
uh entity called video because I we want
to check only one of them so here I will
create a new class I call it video
repository so for you in case you want
to use uh inheritance you need to create
of course one repository per per entity
okay and uh here let's extend jpa
repository and let's give it the type
video
and of course integer for the ID so this
is our repository right here it's ready
to use now let's open our main uh class
or M our jpa application class where we
have the spring application
repository and I will inject right here
our video
repository I will call it video
repository okay and I will bring back
this ban annotation okay so uh this is
going to save this author but I will
just comment this out because I don't
want to insert any other
lines so uh now let's use this video
repository to insert one data so I will
have here our video equals video.
builder.
build so for this video I will just
precise or give some information like um
the name for example uh
abc dot um
length let's check our video right here
we have the length and let's say for
example it's 6 minutes or 5 minutes it's
also okay and let's give it another uh
another information which
is the I I guess that's it okay so let's
give it just the name and the length and
here let's use our video
repository dot save this video
entity okay and now all we need to do is
restart the application and see what
will be inserted in the video or in the
resource table into our database let's
restart now so the application is
restarted and we see also that that we
inserted something into uh the into the
resource table and here we see that we
have this resource type but we did not
precise it just to remind you here we
don't have we have only the name and the
length Okay let's check this resource
table right here I'm going to
refresh the database or the table and
then double click it to show the
content so we see the content right here
that we
have first of all we have V for the
resource type and this is something that
we did not precise we have the ID name
we have the size which is zero because
it's an INT that's why it's zero because
int by default equals zero and we have
the URL type and so on and so forth also
we have the length that we precised so
we have the name
ABC and the length equals 5 and the
resource type is V so if we do this the
same for file and text it will be f for
file and T for text so this is how
single table strategy using
discriminator column and discriminator
value this is how it works so if you
have any question just go ahead drop me
a message otherwise let's move on and
check the next
strategy now let's comment first of all
uh this being annotation close this
class and now we will talk about about
the next strategy which is joined table
this
strategy each subass in The Inheritance
hierarchy is mapped to a separate table
with a foreign key pointing to the base
table this allows each subass to has uh
to have its own table with only the
properties that are specified to that
subass okay so when the joint strategy
is used used each sub class will use or
will have its own table with a foreign
key pointing to the base table this
allows each subass to have only the
properties that are specific to that
subass which can lead to more efficient
queries however it also requires M more
tables and foreign Keys which can make
the database schema more
complex The Joint strategy is a good
choice where when you have a large
number of sub classes with significant
differences in their properties and you
want to optimize the performance of your
queries however it's not suitable for
situations where you need to query the
entire inheritance hierarchy at once as
as it requires multiple joints to
retrieve the data so these are let's say
the pros and cons of this strategy now
let's see how we can implement
this so let's go back here to our
resource let's collapse this one and
let's go back to our resource entity so
now instead of this inheritance first we
need to command out this one because we
don't need this discriminator column
anymore and now for the strategy instead
of single table we will use the joined
one all right so this is the only
required change from the base entity so
we have this entity and again The
Inheritance with the joined strategy and
no discriminator colum is needed so this
one I will just type it right
here only with single
table all right so you don't mix when
you when you directly check the code you
don't mix with this annotation right
here all right so now let's go to the
sub classes let's start with this video
right here for example and now for this
video we don't need these discriminator
values so let's go ahead and remove them
all because now as we mentioned we will
have uh a table per subass okay so
that's it this is how the joint table
works let's restart the application and
check what will
happen so now the application is up and
running let's open our database and
refresh it so refresh it right here so
we see now that we have this file we
have this text and we have this video
table so let's check the columns here we
have this content and the ID also we
have one foreign key which is this ID
which is pointing to the resource all
right so this text table contains only
this content which is is the attribute
that we specified right here let me make
it uh in both sides so we have only this
content right here and we have this ID
which represents the primary and the
foreign key at the same time because we
see right here that we have these two
icons the blue one and the golden
one so they point to the same uh to the
same thing so it's primary and a foreign
key at the same time and we will see the
same thing if we open this video right
here so we have also the length and
ID and now let's try to insert some data
we have already something in here within
our jpa
application let's bring this Bean back
let's restart the application and check
what will
happen so so now the application
restarted and we see here that we have
uh two insertions instead we just have
we just created a query or we just
inserted one element into our video
table all right so here what we have we
have this video. Builder and we have we
precise the information of the video but
we see right here that we are inserting
into resource and we are also inserting
into video so let me show you how this
is represented as data in the database
so first of all I will open the resource
let me make this one full screen so here
we see that we have the ID we have the
name which is ABC the one that we
specified and we have
this default values for the rest of them
if I open the video right here I see
that I have this ID column which is as I
mentioned which is the primary and the
foreign key at the same time and we have
the length that we specified so
automatically hibernate inserted two
elements or two lines into uh two
different tables because we have our
strategy as joined okay now let me uh
show you something you might also want
to do in case for example you want to
give a special or a custom name for this
ID column which represents the foreign
key
we can use an annotation for that all
right so let me make it full screen I
will keep the Bean for now and I will
just commented out once we are finished
with this uh join table strategy all
right so within this uh entity or within
this entity called video which is a
subass here we can use an annotation
called
primary join column okay so this primary
join column we can give it the attribute
name and here I will call it um for
example video
ID all right so now when I insert or I
restart the application and we will
insert some data we will see that this
ID right
here this column right here ID it will
now be rename to video ID let's restart
this so first of all we can see it
already in the insertion query so when
we insert into video we have length and
video ID also if you scroll a bit up and
you check the codes of creating the the
table video we have length and we have
video ID instead of ID so by default it
will use the ID name or the ID name
field of the parent class so in this
case it will use this one but if we want
to customize it and have our own name
for each entity we can also use this
primary key join column so let's open
this video and we see right here it's
now called video ID all right so uh
that's it so this is how join table
works again before we finish let's go
back to our jpa application and let's
command this out and in case we need it
we will bring it back again all right so
if you have any questions don't hesitate
to drop message write me an email
contact me on social
media otherwise let's move
on now let's see the table per class
strategy so the table per class
strategy uh each Concrete subclass in
The Inheritance
hierarchy is mapped to a separate table
abstract super class are not mapped to a
table and their properties are inherited
by by their con concrete sub classes so
you may ask the question what is the
difference between this joined table or
uh and also
the you might ask the question what is
the difference between the the strategy
joined and the strategy table per class
so it's super easy let's check now we
still have the joined table right here
so here we have the resource that
contains The Columns of the base entity
or the parent entity which is name size
URL and so on so forth and each sub
class contains only its own uh its own
attributes with the ID imp plus all
right now when we talk about uh table
per class this means that we will have a
table with a table video for example
with all the attributes from the
resource table joined into this text
table all right so this is the main
difference this means that we will
create a table for each sub
class so when the table per subass
strategy is used each concrete subass
will have its own table with a copy of
all the properties inherited from the
base class this allows each subass to
have only the properties that are
specific to that subass which can lead
to the most efficient queries however it
also requires the most tables and can
make the database schema more complex so
in case you have multiple inheritance or
many sub classes so your schema might be
uh a bit complex than the normal so the
table per class strategy is a good
choice when you have a small number of
sub classes with significant differences
in their properties and do you want and
you want to optimize the performance of
your queries however it's not suitable
for situations where you need to query
the entire inheritance hierarchy at once
as it requires multiple tables to
retrieve the data now let's see this in
action let's see how we can implement
this table per class strategy so the
implementation is super easy there is
not uh there is not a lot of things that
we need to change so first of all let's
go back to our basee entity and here
instead of inheritance
joined let's use table per class all
right so this is the first change and I
will just go back to the video right
here and comment out this primary key
join annotation because it works with
the joint uh
strategy so that's it all we need to do
to mention here that we want to to use a
table per class now let's see the impact
when we start the application and then
we will see or let's also comment or
bring back this spin annotation and
let's see what will happen when we
insert a new video within our database
so let's see the the schema changes and
also the impact when we insert data so
first of all we see here that we have
only one insert which is inserting into
video and we have the lecture name size
and so and so forth now let's see how
this is represented in the database so
now I will go back here and click on
refresh and we see right here that we
have this for for example this
video
um this video table right here we have
our uh we have our all the attributes
and we have the size and so on and so
forth so we have all the attributes from
this resource table and we also have the
attributes from the video all right so
if I open this video we see right here
that we have the ID name size and so and
so forth so we have all the information
joined into one table per subass and if
we check also for example file or text
we will find the same thing so here we
have six columns and this is the content
or the attribute that we have from the
text all right so um now this is how
inheritance
works with hibernate let's go ahead and
check uh few issues that we might face
when using inheritance and how to solve
them when we work with
inheritance we can also query the base
entity so we can Define the strategy
that suits
us and we can also or we want for
example to retrieve all the res sources
of our database okay it's like uh select
star from resource and that's it or like
using the find all methods all right but
we have one issue is when we query this
resource table we won't for example just
to get all the informations or just the
attributes of this resource entity and
we don't want to get any information
about file text video and so and so
forth I just want the resources not this
sub classes of that so this is with this
one like in the
background so in the background when
creating the base class which will
return all the sub class records as well
by using a union statement in the
background and the use of Union can also
lead to inferior performance when
choosing this strategy another issue is
that we can no longer use identity key
Generation all right so when we use this
kind this type of inheritance we might
face the issue of polymorphic queries so
as mentioned querying a database class
will retrieve all the sub classes uh
entities as well now if we don't want uh
a subass to be returned by the type of
the query we only need to add the a
hibernate annotation to to say or like
to uh exclude it from the definition so
for
example if I want to exclude this video
right here if I want to exclude this
video entity when I want to query the
resources I need to add one onot one
annotation to exclude it from the parent
when I query the parent all right so
this annotation is called
polymorphism and and here I need to give
it a
type so polymorphism and the type right
here it's polymorphism type. explicit
because by default it's implicit means
when I query the resource. Java it will
automatically query all the sub classes
from that one but if I say I want it to
be explicit this means that it will
query this video only when it's required
or only when I ask for it otherwise it
will not uh it will not create okay so
this is how we can solve the polymorphic
queries issues so just go ahead use this
annotation and exclude all the sub
classes that you don't want to create
okay so if you have any
questions don't forget to drop me a
message otherwise let's move on in this
chapter I want to teach you how to work
with embedded IDs or embedded entities
generally speaking all right first of
all let's define what is an in embedded
IDs or embedded entities okay so in
software we come across many use cases
when we need to have a composite primary
key to Define an entry in a table a
composite primary keys are that use more
than one column to identify a row in the
table
uniquely So within one table we can
Define more than one column to be the
unique identifier of that column okay so
we represent a composite primary key in
Spring data jpa by using The embeddable
annotation on the class level this key
is then embedded in the table
corresponding uh entity class as the
composite primary key using the embedded
ID annotation we will see all that in
details but first let me give you a use
case for that so here like I have this
other table other table one other table
two it's just an example to tell you
that this is an independent database so
now let's take the case or the use case
of a microservice and now we will talk
about the order microservice all right
and here we have for example this order
table so this is just uh an illustration
example it's not a real life example
just for illustration and here let's go
back and we take this order table we
have right here and we don't want to
rely on generated IDs okay I don't want
to create a generated ID which is auto
incremented to be my unique uh my unique
ID of of this table but I want to have
my own ID I want want to create my own
ID but this ID I want it to be composed
why I want it to be composed it's not
just a want but it's a need why because
in real life one user can order or can
um pass or validate many orders in one
in um at the same time or in one day for
example okay so uh in this table right
here we can find the same username
multiple times so this means that we
cannot rely only on the username okay so
we have also we have here Order date and
the order date itself we cannot just
rely on this order date because at the
same time even at the same milliseconds
we can find more than one user ordering
uh something all right but when we talk
about the
composition when when we talk about
username and Order both of them this is
unique so both of this username the
combination of the username and the
order date it's Unique this means like
the unique
identifier of one order will be the
username for example alibu as a username
and the order date let's say the 0101
2023 uh at uh for example let's say
midnight okay okay so at this time only
we have only one user this alibu user
he's the only one passing this entity uh
this order sorry not entity but the
order but we can also find another
combination at the same order time but
within another username so like the
combination of username and Order date
is something unique and we can rely on
so this is the use case or one of the
use cases when we need to use embedded
IDs all right so now let me show you an
action let me show you in real life how
we can create embedded IDs and how we
can use them within our entities in
order to demonstrate that let's first
create and prepare the ground for that
so to use embedded uh entities and using
the embedded IDs what I will do I will
create a sub Pro sub uh package within
this models package and there I will put
all the all the entities and all the
resources related to this embedded ID
example so right click right here on the
models and then I will create a new Java
class I will call it order
ID and this order ID I will created um
within the package embedded
Okay so so I will just call a pack
create a package called embedded and
within this package I will create my
class called order ID hit enter and now
we have our package and also we have our
our entity so now in order to to create
an embedded ID so first of all you need
to define the IDS or the attributes that
you want to rely on to use that as an ID
and uh as our case demonstrat so we want
to have something uh composed of uh
username and date on and or we can call
it order date so I will first of all
create a string
username and here I'm just assuming uh
that the username is something unique so
we don't have two users with the same
username then let's create a private
local
datetime let's go call it order
date so this is the username or this is
the entity well actually it's an entity
but it's not a persistent entity it's
something like the map super class the
one the example we saw before but it's
not a persistent entity it's just a
composition where we can compose
multiple uh attributes and we can use
them as as an embedded ID so first of
all we need some
annotations I will use the data from
lombok all arcs
Constructor the no args
Constructor and here I will use one
annotation which will make this one an
embedded embedded entity
so here The annotation is called
embeddable and this embeddable comes
from Jakarta do persistence because we
are using spring 3 this is just a
reminder so let's use this embeddable
annotation using this embeddable
annotation we'll tell hibernate and
spring data generally speaking that this
is an embedded entity now how to use it
I will show you just right away so
within this embedded package I will
create my order class or order entity
okay so I will call it
order and here here I will just copy
this
information so these are the annotations
that I will need and of course my class
is an entity so we need the entity
annotation and first of all I will
create a
string um let's call it order INF for
example and a
private string
another field because our focus is not
about the fields but it's just uh to say
that we have few information or few
Fields within the order entity so now we
see the same error that we know here
when we create or we map um a class or
Java class with the entity annotation so
it will claim about an
ID so here it says that this persistent
entity order should have have a primary
key and here it it's asking to add an
attribute or an ID attribute for us as
we mentioned before we don't want to use
an autogenerated or an autoincrement ID
but instead we want to use this order ID
class we just created so first of all I
will create an instance of that or field
of type
order ID and I will call it I ID all
right so for now we have this order ID
but it's still not known as an ID for
this entity now to make it to make this
one an ID we use The annotation embedded
ID all right so this embedded ID right
here so here we see we also still miss
something but first I will I will go
back to this in a few seconds first I
want to show you and I want to go
quickly to the documentation of this
embedded ID
annotation so here it says apply to a
persistent field or property of an
entity class or maid super class so here
you need to focus it's entity class or a
MPP super class to uh denote a composite
primary key that is an embeddable class
the embeddable class must be annotated
as embeddable so this is The annotation
we are already
used also there there must be only one
embedded ID annotation and no ID
annotation when the embedded ID
annotation is used so this means when we
when we want to use the embedded ID
annotation we cannot have another ID
annotation within this one all right so
next it says that the attribute override
annotation may be used to override the
column mappings and so on and so forth
and this one we can also skip you can I
I will get you can have the time to to
read
it and here it says if the entity has a
derivate primary key the attribute
override annotation may only be used to
override these attri those attributes of
the embedded ID that do not correspond
to the relationship in the parent entity
okay and here also you can see an
example we have for example this
employee primary key with this embedded
ID and here we see that we have this
dependent ID annotated with The
embeddable annotation right here okay
so this is a bit uh and quickly The
annotation of this embedded ID now let's
go back and check this error right here
okay so here it says that the class
order ID should implement the ser
realizable so when you want to use an
embedded ID absolutely think about
extending and implementing the
serializable interface okay so this
order ID should Implement
serializable so the serializable is the
one from java.io
package
now if I go back to the order now the
error is gone and and I have my entity
So within this embedded package I will
create my order class or order entity
okay so I will call it
order and here I will just copy this
information so these are the annotations
that I will need and of course my class
is an entity so we need the entity
annotation and first of all I will
create a
string um let's call it order info for
example and a
private
string another field because our focus
is not about the fields but it's just uh
to say that we have few information or
few Fields within the order entity so
now we see the same error that we know
here when we create or we map um a class
or Java class with the entity annotation
so it will claim about an
ID so here it says that this persistent
entity order should have a primary key
and here it as it's asking to add an
attribute or an ID attribute for us as
we mentioned before we don't want to use
an autogenerated or an autoincrement ID
but instead we want to use the this
order ID class we just created so first
of all I will create an instance of that
or a field of type
order ID and I we call it ID all right
so for now we have this order ID but
it's still not known as an ID for this
entity now to make it to make this one
an ID we use The annotation embedded ID
all right right so this embedded ID
right here so here we see we also still
miss something but first I will I will
go back to this in a few seconds first I
want to show you and I want to go
quickly to the documentation of this
embedded ID
annotation so here it says appli to a
persistent field or property of an
entity class or maid super class so here
you need to focus it's entity class or a
mapet super class to uh denote a
composite primary key that is an
embeddable class the embeddable class
must be annotated as embeddable so this
is The annotation we already
used also there there must be only one
embedded ID annotation and no ID
annotation when the embedded ID
annotation is used so this means when we
when we want to use the embedded ID
annot ation we cannot have another ID
annotation within this one all right so
next it says that the attribute override
annotation may be used to override the
column mappings and so on and so forth
and this one we can also skip you can I
I will get you can have the time to to
read
it and here it says if the entity has a
derivate primary key the attribute
override annotation may only be used to
override these attri those attributes of
the embedded ID that do not correspond
to the relationship in the parent entity
okay and here also you can see an
example we have for example this
employee primary key with this embedded
ID and here we see that we have this
dependent ID annotated with The
embeddable annotation right here okay
so this is a bit and quickly the
annotation of this embedded ID now let's
go back and check this error right here
okay so here it says that the class
order ID should implement the
serializable so when you want to use an
embedded ID absolutely think about
extending and implementing the
serializable interface okay so this
order ID should implement
realizable so the serializable is the
one from java.io
package
now if I go back to the order now the
error is gone and I have my entity okay
so if I start my application I should
see my order class or my order entity
created in the database and I should see
a composite primary key okay so let's go
ahead click Start and check these
updates so uh let's check the
logs okay here we see an exception so
the exception is we have a psql
exception and this is because we have a
syntax error near order because the
order is already a reserved uh keyword
so to solve this you already you already
know the solution let's use the table
annotation okay let's give it a name and
let's give it underscore order right so
now restart the application and we
should see everything working fine right
now all right so the application now is
running we we check we don't have any
exceptions no issues and also we can
check the logs and you will see that we
have our order table getting created
okay so now let's go ahead check our
database refresh and
see so here we have this order table
let's open it and we have already four
columns so for these four columns we see
that we have this order date and
username both of them they contain or
they have this golden key icon so this
golden key icon is the the primary or is
the icon of the primary key so our
primary key in this database is the
order date and the username both of them
concatenated all right so if we check
the keys right here so we see that we
have this underscore order uncore P key
so it's order primary key and it's a
composed or composed key and it's
composed already of this order date and
username so this is how we can create an
embedded ID in case you need to create
an embedded ID now you have the
knowledge to do it so if you have any
questions don't hesitate to drop me a
message otherwise let's move
on so now we saw one example or one
usage of this embeddable annotation I
want to show you another one let's go
back to our diagram right here and for
this order for example we want to have
or we want to add some information about
the delivery address but we want this
information to be uh embedded within the
same the same entity or the same table
right here so I don't want to store the
address or the delivery addresses in a
different table but I want it to be
within the same table order right here
you might say this is so easy to
do all I need to do is within this order
entity right here I just declare the
information of the address okay but yeah
the answer is yes but imagine we want to
use the same address object also to
store the address information with our
tables within the same database or
within the same schema so like this what
I need to do is to duplicate the code in
each entity which is not good okay we
have a better solution okay the second
one you might say we I can use the
method super class and extract all these
entities and just extend my entity with
this address entity I say
okay this also feasible but if you have
multiple inheritance right here if you
already for example extend a base a base
entity or if you extend another or you
have inheritance you with uh within your
database so what should be the solution
the solution can be using the embeddable
entities all right so with this within
this package embedded right here right
click and create a new Java class and
let's call it address
okay so this address first of all we
will need the same uh lbook or the same
basic lbook annotations right here data
all our Constructor and no arcs
Constructor and now I will just create
few dummy
Fields so here I will have string Street
street
name private also another
string house number for example uh house
number it's a string just in case you
have one a 1 b 1
C and private string zip code so it's
also string it might start with zero and
so and so forth so let's not focus so
much on on the fields right here but our
main focus is to understand how this
embeddable works so once we create and
once we Define all the attributes of our
embedded entity as we did in here within
this order we need to use this
embeddable annotation okay so let's use
this annotation right here and like this
we just created our embeddable entity
now I will show you how you can use this
embeddable entity as an attribute within
another entity now let's go back to our
order class and within the other fields
that you created I want to create a new
field of type
address so I will create an address and
I will call it address all right so now
I want to tell that this address is an
embeddable entity within my order entity
all right so I I already me the solution
so let's
use the embedded annotation okay so here
we have embedded ID and this is embedded
and let's check quickly what is this
embedded annotation so it specifies a
persistent field or property of an
entity whose value is an instance
instance of an embeddable class so the
embeddable class must be annotated as
embeddable all right so the attribute
override attribute override and so and
so for may be used to override mappings
declared and default or defaulted by the
embeddable class so here you can also
override some attributes when you use
this embeddable class all right so this
is the embedded annotation now let's go
ahead start and test it click on restart
right here so our application is up and
running right now and let's go ahead and
check the
database so now I will just refresh the
database and let's see what will happen
right
here so within this order table we see
right now that we have seven columns and
here we see that we have the house
number street name zip code and so on so
forth so the the fields of the address
are now included or embedded within our
order table so if you want to do or if
you have a need and us it usage like
that or use case like this one always
think about using embeddable entities
all right so embeddable entities will
make your code much much easier and uh
improve the granularity of your code and
your code will be really reusable all
right so because this address uh entity
or this address uh class right here we
might use it in many places so in order
to
duplicate uh not in order but instead of
duplicating the code of uh the fields of
this address class just create an
embeddable entity and use it or call it
whatever you need if you have any
questions go ahead drop me a message
otherwise let's move on previously we
explained the hierarchy of the spring
data jpa uh interfaces and how this
helps us and provide us with methods and
predefined methods to search data and
query data from the
database so now we cannot talk about
spring data jpa and not talk about
querying data from the database and
querying the data means reading and
writing and also deleting and all the
interactions and the trans transactions
that we can make with our
database the spring uh data jpa and the
repositories and the jpa repositories
they provide us several ways to
dynamically generate queries at run time
so these are called uh query generation
from method names or also known as query
derivate query methods okay and these
derivate query methods they allow you to
Define queries
based on the method name and uh of the
query method you are calling so for
example if you want to find the author
right here let's first before going to
this method right here let's just recap
and remind about what we have so we
created before an interface called
author repository because we have an
entity called author right here and this
author Repository interface extends
already the jpa repository which is a
generic interface that takes two
parameters the first one
is the entity in question and the second
one the ID type that we use within this
entity okay so this jpa repository will
use the author. Java our entity that we
created and just a reminder with the
author we have these IDs or this sorry
not IDs about these fields we have an ID
first name last name email and age okay
so here within this author repository
interface which extends already the jpa
repository as I mentioned before we can
create methods okay so it's an interface
and you know within an interface all we
need to do is the return type whether
it's a function or a void and then the
method name and the parameters this is
how we create me methods with within an
interface so as I mentioned spring data
jpa provides us uh a way to dynamically
generate queries okay and we call it uh
derivate queries or derivate methods so
this is how we can write it so here as I
mentioned it's the return type and then
the methods that we want to okay so
let's explain this example right here we
have this list of author so our method
will return a list of authors and here
we have find by last name and we have
our last name or Ln as you you can call
it as you want as a parameter so what
will happen in here so this find by last
name method generates a query that
search uh the users or search the author
with a specific last name and this
method right here for example this find
by first name and last name Will
generate a quer that searches um the
authors uh or the user by first name and
last name okay we can generate other
queries like uh like in here for example
we can count we don't have only the find
by we can also count we can also delete
we can also do as many operations as we
know in SQL using the derivate query
methods okay so for example if I want to
count all the authors in my database by
age so all I need to do is to write the
return type and spring data jpa will
take care of the conversion okay so the
count all by age within the age it will
create a query that counts all the
authors in this author table by the H
and return this value also if for
example uh we have already the delete
methods that we can use or the
predefined delete methods but if we want
for example to delete uh the the list or
we want to delete a list of authors by
age all we need to do is delete all by
and then we have age like bu and here
it's followed by the property that we
want to use Okay so
let's explain a bit more here in order
to generate one of the of the methods
right here that will create a query
behind the scenes at the runtime all we
need to do is we have find by and Then
followed by the property okay so this is
the the simplest way so it's find by and
then follow it by the property name and
depends on the return type right here uh
spring data jpa will determine what to
return exactly so here we have find by
so it will search everything from the
database and return the result set okay
but if we have for example here an
author or an optional of author so I
will explain the difference so an
optional is the design pattern uh null
pointer so this is a wrapper to wrap
this author object within this optional
class right here so this find by email
spring data jpa will will search the
author by email from the database and
then return a type of an optional of
type author okay so also the same here
we have this find by email but in this
case we will return the author so spring
data GPA will do nothing except creating
an object author and just return it okay
so here as I mentioned we have the
findby followed by the property and then
you can create as many methods as you
want okay so this is the first one also
we can use find all by so they both work
in the same way we can use find all by
last name find all by first name and so
on and so forth okay now we can also
combine uh properties combine means what
we can use uh operators such as and and
or so I can search the list of authors
by first name and last name okay so here
we see we see that we have find by first
name and last name and we need to pass
these two parameters okay so FN for
first name Ln for last name okay we can
also use for example let's go back to
this method I want to ignore the case
when I want to query all the all the
authors all the list of authors from my
database so here we can say find by last
name and Then followed by ignore case
okay we can also use other operators
like not like we can um use find by last
name like so means this uh contains and
so and so forth okay so we will see all
this in action we will see how we
implement or how we can Implement these
methods okay so I hope this part is
clear if you have any questions don't
hesitate to drop me a message otherwise
let's move on now let's see all this in
action so first of all I will teach you
how you can how you can write these
methods so as we explained before first
of all we start with the return type so
here imagine we want to fetch the list
of authors from our database and from
this this author table by first name for
example okay so when we say that I want
the list automatically think about
having a list okay so here you can
whether work with list array lists
Collections and so on and so forth but I
always recommend using interfaces don't
use classes use interfaces so in order
when you want to change the
implementation it's easier okay so let's
go back so here we have a list and then
the type so we want a list of
author and then you have this find by so
automatically when you type find by and
you have the type as
list so it will automatically transform
it or map it to a list of authors you
can also when you when you work with
lists you can also use find all bu find
all means that you want to search
everything okay so they both work in the
same way so let's use find
all so then here if you have the inell
the ultimate version or for the people
who are using another IDE which provides
autoc completion so here when you do
command uh space or control
space you will see that your IDE will
propose the list of properties or the
attributes that you have within the
author okay so and here you can have a
look on the gener ated uh generated or
the autogenerated properties which are
automatically detected from this author
entity okay so we can see age for
example and even within the age we can
see that we have a lot of methods okay
so imagine we have all these method uh
within only the age property for example
if I want to search all the authors
where the age is null so I only need
need to query um find all by age null
age not null age not like not in and so
and so forth so you can have a look and
all and on all these methods and we will
explain most of them okay so here for
example I want to search all the authors
by first name so all I need to do is to
type first name okay and within this
first first name also I can see that I
have a lot of autocomplete so after
before between uh by the way not all of
them are
appliable because when we say uh first
name after he mainly we are talking
about dates okay before also dates and
between and so on so forth so you need
to be careful not everything
autogenerated here is usable or
appliable for this specific property
okay but you will learn it by the
time so now the this find all by first
name is completely sufficient now I need
to provide my parameters so here uh you
need that you have the same type like in
here and then just type any name I will
call it f name just to just to mention
and to make sure that this works I don't
need to pass the same here the same
attribute name also one thing worth
mentioning and it's really really
important so you see this first name
right here if I go to my author uh
entity you see that we have the first
name is written in exactly the same way
so we have first and the name with the
capital N okay so if you go back here
you cannot say like this you cannot call
your method like this so it will not be
detected it will not be highlighted as
an error but within your anj or within
your IDE it might be be highlighted as
an as a warning but not for all the
cases but this worth mentioning so here
all the only thing that you need to
change is the first letter because you
are using camel case so what you what
you need to do is just copy the field
that you want to use and until you get
used to it copy it and then here just
paste it and then the you change only
the first letter to a capital letter
okay so like this you will have the
method or the exact method that will
work for you and if I change this one to
for example a lowercase we see that it's
highlighted and here we see that um
cannot resolve property first name this
means that my anj or my IDE he
automatically detected that this first
name property is not within this author
entity okay so here you need to always
be careful about this all right so this
is the our first method and this one
will search all the lists or of authors
from our database by first name now
let's try and see how we can improve or
how we can extend this this method
okay all right so let's try how we can
extend and improve a bit this query just
as a reminder I want to remind you that
this query is the equivalent of this one
select star
from
author
where first
name uh I will use it as as in the
database uh let's say this is a native
query equals and and here we have our
first name as parameter right here so
this is the same exact query
now now let's answer the following
question what if I want to find all the
authors from my author table where first
name equals any for example equals this
and I have in my database the users are
all in capital letters okay are all ABC
case but I want to ignore the case I
want even if I want even to pass when I
pass this Ali as value I want always to
query the data So within this method
right here and this generated query
right here passing this value Ali and
having all the first names in the
database equals or in uppercase this
will not work this will return an empty
list okay this will return nothing now
let's try to extend this query and make
it ignore the case all right so here we
have find all by first name and I
already gave you the answer we need to
add one property which called ignore
case okay so when we say ignore case now
it will accept this query right here
okay and it will return some data all
right so this is good now what if I want
to get all the data or all the authors
from the
database where the first name contains
this one for example contains a l all
right so and also I want it to be also
ignore
case in order to do so I will duplicate
also this method so here we have find
all by first name ignore case we can
also add
containing so we need find all by first
name
containing and then ignore case so as
you can see here we can concatenate and
we can use
multiple uh use multiple uh filters
within the same query method okay so
here we have find all by first name so
this is the attribute name and then the
condition that you want to use or the
CLA the work Clause that you want we
want to use containing so containing
will be the equivalent of this one right
here so it will be something like that
okay so it's going to be like percent
percent so this is the exact same thing
and also we want to insist that we want
to ignore the case so here be careful
it's property or we close and then the
refinement if we want to refine our
query okay so now I want to so this one
I hope it's clear otherwise you can drop
me a message and I can explain it a bit
more now I want to get all the authors
where the first name starts with this
and also ignoring the case all right so
in order to do that let me just keep
this as it is
and I will duplicate this method so I
will use it always as a base method I
will copy or paste uh this query right
here so I want as I mentioned to search
all the authors from the database where
the first name starts with this so here
instead of containing I will use starts
with so here when we use the start start
with the query will be transformed or
will be generated exactly like this okay
and also here we want to ignore the case
now let's take another another
case let's play around with these
quaries because it's really funny so
here instead of starting with I want all
the first name that ends with okay that
ends with uh sorry sorry I just made a
mistake so starts with with it's like
that so it's a and then anything because
this percent means anything but ends
with is the opposite one okay so I'm
sorry for that so here I need all the
queries or all the authors from the
database where the name ends with Al so
it starts with anything and ends with a
l all right so here I will duplicate the
same
method and and here instead of starts
with I already gave you the answer so I
need to use ends
with and you can see that this ends with
ignore case will transform and will
create this exact same query in the
background okay so uh we can also we can
also add and play with so many
attributes and as I mentioned like after
the first name or after the property
name with within your IDE you can click
on control space and you will see so
many methods okay so starting with
ending with also you can check if the if
the author or if an author exists with
this first name uh you can also use uh n
and so and so forth okay so um for
example if you
want for example if you want to generate
this
query so I want the list uh of authors
from the database where the first name
in for example I want to filter only
for for
example
Ali I want to get all the authors where
the name is where the Ali or Buu or
coding so here it's super easy as I as
we mentioned before let me duplicate
this
method and
here instead of ends with I need to pass
in okay so and also here ignore case so
I want to find all the names or all the
first
names uh in from the author table where
the first name is in a list but here we
we need to pass a list of strings
okay so to pass a list of strings so
whether we pass a table or we pass a
collection
okay so here we need to pass a list of
string as the first names I will call it
first
names and this will generate behind the
scenes this exact same query all right
so you can play with these methods with
these filters and you can generate
awesome queries out of this now let's
move on and try something else now
before moving ahead and going deep into
this derivate query methods let's play a
bit with what we created right here so
to do so we will go to this Java
application here where we have our
command line Runner bean and we need to
insert some data into our author table
to inable in order to be able to play
with these queries but here we Face a
small issue which is that if we want to
insert multiple data I need to every
time to create for example if I want to
insert 50 uh authors into my database I
need to duplicate this code 50 times and
each time I need to change the first
name last name age and so and so forth
but to do so we can use a dependency
which help us to fake data okay so this
dependency is called Faker or called
Java Faker so it will automatically
generate uh data for us including for
example first name last name emails and
so on so forth also it can generate
generate address and so and so forth all
right so uh first of all let's go ahead
and insert and add this dependency so
open the pom.xml file and go down to to
the dependencies right here and after
the project lumo add the following
dependency okay so add the dependency uh
tag and within the artifact Rd it's
called Java Faker so it's the second one
not the fixture but it's the second one
Java Faker so select this and then it's
from com. GitHub do Java Faker right and
the the most recent version at this time
is the one2 if you have more or a recent
version just go ahead and choose it then
click on this load Maven changes and
that it you will have the Java Faker
within your project okay now let's
insert some data first of all don't
forget to bring back this bin annotation
let me make this full screen and then we
need to comment out this one and to
comment this out all we all you need to
do is Select it and then go to code and
here you have this command with block
comment okay now let's bring back this
code right
here and what we will do let's create a
loop so I will do for in I equal z
i smaller than or less than let's insert
50 and here we have
i++ and let's let's move this code
inside now instead of this first name
and last name I will remove the email or
let's let's keep it like that the age we
can also keep it uh but here instead of
this first name last name what we will
do here I will create uh a
faker I will call it Faker equals a new
Faker okay so this is how we can use our
Faker uh uh object and now for the first
name I will use Faker dotname we see
here that we have this name object which
returns a
name and from this name we have first
name name last name full name and so and
so forth so we need the first name last
here and also let's use the same one for
the last name right here so instead of
first name let's use last name okay okay
now for the age we can use our
Faker do
number and here we can generate a number
or a random number between two digits
for example and the age I want uh my
author to be between for example 19 and
maximum let's say 50 okay so it will
like this it will generate an age or a
number between 19 and 50
okay all right so so now we can just run
our application and make sure that we
have all our authors inserted into the
database so let's go ahead and do
it okay so here we forgot that our email
should be unique so to do that I will
just do something like
this just to fix it quickly and here I
will concatenate it with uh with I okay
so it will be contact Z1 and so and so
forth so like this we don't have the
applications I will restart the
application and
see so now we see that we have the
insertion logs let's go ahead refresh
our database and check let me move this
refresh the
data and here we have our tables and now
let's go and check our author table okay
so we see right
here that we have this email and we see
that we have this first name last name
and so on and so forth and the
information that we provided also the
age but now let's make uh this insertion
permanent and I because here if you as
you remember when we start the
application and uh we made this ddl Auto
right here like just to remind you the
configuration the ddl auto we created is
create a drop so all we need to do is to
make this one to update okay
uh so when we make it update every time
we will start the application we will
not lose the data so this is what we
need to do so in order to do that just
go ahead make this property to
update like this and then we need what
we need to do is to restart the
application so we can insert the data so
just follow me on this restart your
application and then we will have the
data inserted
so here we have in our database let's
refresh it we have this data right
here and this data will be persisted
like always okay and then we go back
here in order to make this data always
persistent just go back right here and
you can just comment out this insertion
or you can also keep it but here we want
to play with this um with this part
right here but let's comment out all
this for Loop so let's use a block block
comment so we no longer have this code
getting executed and to make sure that
what you did is correct just go ahead
restart again the application and make
sure that you still have the data so
here we should not see any uh SQL log
telling that that we are inserting and
as you can see the application is
already started and nothing happened so
also if I refresh my database if you
open the table right here click this
refresh button you see that we still
have the data okay also let's just to
double check let's refresh this open and
we see that we have the data right here
okay so now we have permanent data
within our database and now we can play
with it now I want to give you a small
EX exercise so here we prepared
everything we have all the ground we
need to run our tests so now I want you
to play Within this repository this
author repository and the methods that
we already generated right here so
within this command line Runner or if
you want you can create a service and
some end points and you can play with
this methods but just go ahead and test
this uh find all by methods and see the
output okay so I hope you like this
exercise if you face an issue drop me a
message otherwise let's move on well
done after you played with all these me
methods that we created together now
let's move on and check something else
so here we have our author table already
inserted with data and we can see here
that we have email first name last name
and age and uh for this one I just want
to highlight one thing because here for
this email what I used here I used the
faker name. username because I'm sure
that this username will give me a unique
uh username and then I I made a
concatenation with the at alibu
coding.com so you can also do the same
also for the age you can uh you can use
the faker do number and then number
between and it will give you a random
number between 20 and 80 for example all
right let's go back here now we have uh
the data inserted now what if I want to
update for example the first one which
has uh the ID equals 1 I want to change
the email first name last name and age
okay so in order to do that it's so easy
here we will keep uh this one and also I
will keep the bean because in the
application uh here I have create drop
so this means every time I start the
application I will get my data inserted
okay so after inserting the data what I
want to do is I want to create or I want
to copy paste this one or I can copy the
whole code and here I want to update
author with id1 all right so in this
case what I will be do uh what what I
will be doing is I will create an author
object and here I will just change the
data and here I will make it first name
Ali last name bu Ali and age it will be
my age for example and the email I will
move it back as it was so contact at
alibu coding.com and then of course I
will need uh okay I forgot repository.
saave here and then I need the same
thing here so now this one it will
insert this um this author but if I do
do ID here one so this means that we
will update this author and let me
explain how this works so this save
method first of all it it will check the
ID so if we have uh if we have an ID the
first thing that it will do it will try
to fetch any object within this ID so it
will make uh select all or select star
from author where ID equals one
if the hibernate can find data what it
will be doing it will be merging or
updating all these fields okay otherwise
if for example I pass an ID equals 1
million or 100,000 so it will not find
any object within this ID in this author
table so it will decide that it will be
an insertion or creation of of a new
input here you need to really pay
attention that when you pass an ID the
ID should exist in the table you should
already know the ID in order to update
something so now let's move on and rerun
the application so we will we will have
all this information but the element or
the first one should be alibu alib Ali
and with the email contact albu.com all
right so here we see also that we have
all these
insert and then you you see here that
you have a select and then an update so
the first select is checking if we have
the author with the ID that that you
specified in here which is the ID one
and then we have update author set age
and so and so forth and then where ID
equals the the ID that we passed as
parameter so now I will just refresh
this this one and you will see that if I
search for the ID number one which will
be at the end we see here that we have
the urge 34 uh alibu coding uh.com Ali
and B Ali as a last
name so this is a way of updating the
data now what if I want for example just
to update this one or this one or only I
want to update age or all the ages of my
um of my table so for example what if I
made a mistake and and I want to fix all
the app updates or I want to update all
the ages of all the authors in the
author table so in this case I need to
write one query which will update
everything so I don't have uh a
condition right here like I don't have
an ID and if I want to use this method I
need first of all to find all the
authors from the table and then I have
to Loop over them and each time I need
to set the age and of course I need to
pass the ID and then repository. save
but there is an easier way and we will
see it just right now so what I want to
do now is running the following query so
I want to create a method or create a
mechanism that will allow me to update
to run the following query which is
update
author and then set or let's call it a
set
a. equals 22 for example and here let's
start first of all with
where a. ID equals 1 for example so I
want to have or I want to execute this
query so it's exactly the same thing
like here but I want to use the jpa or
the my repository right here so here I
have the author repository and I will
show you how you can use this repository
in order to run or to create update
queries so first of all go to this
author Repository and I can just copy
this one and then what I will do I will
create a void or let's create an an INT
uh method so update
author just update author it's it's okay
so in order to update the author we need
to pass an INT age and then int ID
because we want to update the the age of
the of the author having the ID one for
example and here as we mentioned we want
to run this following query so in this
in order to do that so we will use the
query annotation and then this is our
query so it's update author a set A.H
equals 22 where ID and now the ID should
be like this all right so this ID will
refer this one and the age should be
also H so this query does not support
update uh methods or update instructions
but we need now to tell uh spring data
jpa that this is an update query and in
order to do that all we need to do is to
add this modifying annotation so when we
have this modifying with this query
right here hibernate will understand
that this is an update query so now if
we go back here and if I comment this
out and then if I do repository do
update author and I pass for example 22
as age and I pass one as an ad and rerun
the application we will see that in the
author table we will have or we will
find that we have an update okay here we
see that the application did did not run
and we have already one exception so we
see that first of all we started to
insert everything and then we we got an
exception fail to execute command
command line Runner and then executing
an update or
delete uh through through an exception
so let me explain to you what is the
reason behind that so the reason is that
this update method that we have right
here was not or is not transactional so
so in order to do that or in order to
fix that we need to make this modifying
query transactional because the
modification or the update need to be
within the same transaction
okay so in order to fix that all you
need to do so here you need to put in
mind that when you use the query and
modifying then you need also The
transactional annotation so with these
three annotations right here modifying
transactional and query with the update
query we will be able to update our our
author so now let's run again and let's
also check the the output so we see here
that we have all the inserts that we
have but now we have no select as we saw
before but it's directly updating so
update author set age where ID equals
something so let's go back to
our and now if I scroll down and they
see this one so we see that the ID
number one has the age 22 and also if
you want to make sure you can just put 1
age equals equals one 100 for example
since we know that all our authors uh
ages are between 20 and 80 so now we can
make sure that we updated the correct
one and also the update method or the
update query is working as expected so
now we see that the age of this uh guy
right here is 100 so our update query is
working now if you want to or now let's
try to update all the all the ages or
the ages of all the authors that we have
so first of all I will create void
update all authors for example
ages and here I will just pass an INT
age and I will also copy this one and
all I need to do is removing this work
close and now I will duplicate this one
update all authors and I will set the
age to 99 for example this one we can
comment it out and I will rerun the
application oh uh we missed something
already so here it we need to use the
update all authors and age 99 and I will
remove the ID so let's start again okay
so we see here that update author set
age equals to something and if I refresh
right here I should see all the ages
equals to 99 so this modifying query and
this modifying annotation right here is
really useful if you want to do a bulk
update and you want to update many
things at the same time so you don't
need to Loop over uh the data and set
this said that set this set that so all
you need to do is to create an update
query and then if you need and also
don't forget if you need this workloads
you need to add it otherwise you will be
updating oral data in this part we will
see together the named queries so in
Spring data jpa named queries are useful
in a variety of scenarios uh for Oran
organizing optimizing and maintaining
query definitions in your application
and some common uh use cases includes uh
encapsulation for example of your query
logic so named query help you separate
query definition for the rest of the
application logic also named quer are
reusable they also help us optimize the
performance of our application because
they um the named query are validated
and passed and often optimized during
application startup so when you have a
named query it will be passed validated
and optimized on the application startup
also named queries uh are are
centralized this means named queries
allow you to store your query definition
in one place either with an entity class
or an external XML file this
externalization simplifies query
management and makes it easier to update
and refactor the queries let me give you
some specific examples when to use named
queries in Spring data jpa application
so first of all when you have complex
queries that are used in multiple places
throughout uh your application when you
want to optimize performance for
frequently executed queries when you
want also to improve code readability
and maintainability by separating query
definitions from other application logic
and finally when you need standard way
of organizing and managing queries
across your application so these are the
use cases or some of the use cases of
named queries and the definition also of
a named query but you need to keep
something important in mind while named
queries offer uh several benefits it's
it's important to note that they may not
always be the best choice for every
situation for example they might not be
as flexible as Dynamic queries for
example when we use Query DSL or
criteria API also when it comes to
building uh queries based on varying
condition or user inputs it's essential
to evaluate your specific use case and
choose the appropriate approach for your
application all right now let's move on
and Implement our named query and let me
show you how to do that to create a
named query first of all you need to go
to the entity or to the model where you
want to create that query so here we
have two options first of all we can use
this annotation named
query or we can also use named queries
so we have two options okay also we have
another one which is named native query
or named native queries right here so
you can also create native queries as
named queries so for the this case let's
move on and let's go ahead and create
jpql named queries so first of all we
will use a single one and I will show
you how you can use this uh named query
and then I will show you the use case or
the usage of these named
queries so first of all as I mentioned
when using named query we need to give
it a name and the name always think
about having uh The Entity name or your
model name dot the name of the named
query so I will just say find by named
query and then I would provide the query
itself so let's say for example for this
one I want to do select a from author a
this is just the Adas
where a. AG is greater than greater than
or equal for example to the age I want
to pass as a parameter so now I have
named query which will fit all the
authors by age where the age is greater
or equal than a specific parameter so
now in order to execute or to use this
named
query just go to your repository right
here and now we want to execute this qu
so it will be return a list of
authors and then we have find by and as
you can see enj is already proposing
this one and also you see that the icon
is slightly different from the from the
Native one or from the predefined ones
so here we have find by named query and
also as you saw here we have its named
query so all we need to do is to pass
our
parameter using the pram annotation
and then
age and then of course it's of type int
so it's going to be int AG so that's it
and here you see already the difference
that we have this icon and when you
click on it it will navigate as to the
named query okay so now in order to use
this one or to check it all you need to
do is to go here to the jpa application
and then after executing and updating
and doing all that what I will do I will
do list of
authors equals repository. find by named
query and here let's say for example I
want to fetch all the users having or
all the authors having an age greater or
equal than
this yeah so this one should be or
should go inside and here it will be
finded by named query and then I can can
do for example for each
system.out.println so I just want to
print all the authors that will be here
I guess we can also remove this one and
now let's execute our application and
let's see the output so here we see that
we have all the authors and here we just
forgot to remove this update because by
this we updated all the authors and we
set all the ages to 99 so it will
retrieve all of them so now let's see
and here we have a restricted list and
as we can see here we have all the users
where the age is 74 71 and so on so
forth so for example if I change this
one to 70 or 7 s something like that
yeah okay and if we run again we will
see that we have we will have or we will
get a shorter
list so you see that you have have only
two with the age 71 and 70 all right so
this is how we can create uh a named
query let's move on and let me show you
how we can create a list of named
queries and how we can create another
type of named
queries now let's update data using
named query so let's try to recreate the
same uh query right here but using the
name query so first of all I would just
copy this one and then I will go back to
the author and I will create another
named query right here and then I will
give it a name so the name will be
author.
update by named query and the query will
be the one I just copied so here it will
be update author set age where ID equals
something but here I will just remove
this
ID and I want to update all the all the
author authors so again I need to go
back
here so it will be a
void update by named query and this one
of course we need a parameter which is
the
age and then int
H all right so let's double check so
here we have a variable H so we need to
pass it and this is what we did right
here now let's go back after uh
displaying all this data Now update with
named query so all I need to do is my
repository do update with name or by
named query and here I will pass for
example 12 as an age and I will execute
the the application again and check what
will happen so it seems that it did not
work and now I guess and I'm pretty sure
that you know why it did not work and
the answer is so let me first show you
the the exception failed to execute
command Runner and here it says
expecting a select query but we got an
update so the answer is that is the one
you already thinking about we need this
modifying and of course we need The
transactional annotation so even if it's
a named query if it's an update query we
need always to use this modifying so
let's run again and check and now we see
that we have this update and then if I
open my table right here and I will see
that all the ages now are 12 so that's
it also before um before we move on to
the next steps here you see or we
mentioned already that we can use named
query or this annotation named queries
the difference between this named query
and named queries actually there is no
difference because if we go to the
source code of this annotation we see
that we have or we can pass a list list
of named queries so it's just a way to
organize our named queries so we can do
something like that and we can move
these named queries
inside and that's it so this this is the
only difference between the named
queries and the named queries so you can
whether have them separately or you can
also group them within a list of named
queries and nothing will change it will
be always the same everything will will
will remain the same all we need to do
is just group them with named queries
spring data jpa specification is a
powerful and flexible feature provided
by Spring data jpa framework that allows
developers to create Dynamic and type
safe queries using the jpa criteria API
it enables you to build complex queries
based on various criteria which can be
combined and reused in different
scenarios providing flexibility and
maintainability in constructing queries
and the core of the
specification the core concept of spring
data specification revolves around the
specification interface which which is a
functional interface with a single
method so here we see in the source code
that we have a bunch of static and
default methods but the main method or
the main uh important method is is this
one predicate to predicate here the T
represents the entity type on which the
query is built and the pr two predicate
method receives three arguments first of
all we have the root right here which is
the object that represents the root
entity in the query from which you can
navigate to other related entities and
attributes and then we have a query
which is a criteria query of a type uh
interrogation Mark which can be any type
which is an object that represents the
overall query being built this can be
used to modify the query structure and
uh or add additional constraints finally
we have the criteria Builder which is of
type criteria Builder which is an object
that acts as a factory for creating
various cre elements like predicates
extensions and orderings the two
predicate method returns a predicate
which is a Boolean expression
representing the query condition now
let's talk about how we can use this
specification so to use a spring data
specification you need first of all to
extend uh your repository with this jpa
specification executor interface which
provides methods to perform queries
using specifications the most common
used methods are find all and find one
you can also create Uh custom
specifications in es by implementing the
specification interface or by using
Lambda expression so specifications can
be combined using the end and the or
method as we can see right here we have
this end and we have this or also we
have where and not these methods uh
allow us to build complex queries
dynamically in summary and overall
spring data jpa specification is a
feature that leverages the jpa criteria
API to build Dynamic and typees safe
queries for your application it provides
a flexible and maintainable approach to
construct queries based on various
criteria which can be combined and
reused throughout your application this
approach is particularly used when
dealing with complex queries that depend
on user input or VAR B based on runtime
conditions now let's move on to the
action and let's implement our first
specification query the first step is in
implementing
specifications is first of all you need
to go to your repository where you have
or where you extend your jpa uh the jpa
repository also we need to extend the
jpa specification executor so here we
extend already um jpa repository I will
also extend jpa specification executor
and here we need to give it the same
type author in here all right so now we
have our repository ready to be used as
a specification executor after extending
the author repository we need to create
a new class so I will create a new
package here I will call it
specification and then I will call or I
will create a new class called it author
specification and now within my author
specification I will create two
specifications or let's call them two
predicates uh and these predicates they
will filter for example my authors based
on the first name and age so let's
create the first one public static
specification and my specification is of
type author of course don't forget that
and let's call this one has age for
example and this going to be our first
filter so in first of all it's going to
be int Ag and then we need to return a
Lambda expression so you know when the
two predicate method that we checked
before it takes root of type author
let's call it root and then we have the
criteria query and this one as we
mentioned before it's going to be
interrogation mark this is our query and
we have our criteria Builder now let me
just inline these variables so so you
can see everything so here we have this
the these are the parameters that we
that we need as we explained before so
we have our root of type author we have
the criteria query and the criteria
Builder so here what I want to do or
like what we need to filter out is first
of all if this age right here so for
example this is just a check if uh it's
less than zero so I will just return
null because we know that we don't have
any age or any person having a negative
age otherwise I will return my criteria
Builder dot equal and then I need to
pass the expression so it's the root
that holds the information of the entity
do get and then I can pass the attribute
name that I want to filter on which is
age and then the age itself so here I'm
ensuring that this method has age right
here will add uh a criteria or will add
specification that the age of the author
right
here this this variable or this field
right
here should be equal the age that we
will pass as a
parameter so just I need I need to
remind you that what we are building
right here is not the query itself but
it's just or are just the filters that
we want to um to use so for example uh I
want to filter all the authors by age
and the name containing or starts with
okay so next one I will build a public
static again it's a specification of
author and
then let's say first name contains or
starts
with and here I need to pass my first
name and I will just copy paste this
one so here
if my first name is
null so I need to return null otherwise
here I want to do first
name and here of course I need the
parameter
so as you know in SQL contains is not um
we don't have such method called
contains but we have a method called
like so like I want to have this first
name to be like the parameter that I
want to pass so now we just built two uh
specifications or two predicates the
first one is has age and it will check
that this author has an age that we will
pass as a parameter and again we have
this first name contain or let's maybe
call it first name like to be more
consistent with this method right here
and this will check that the first name
that we will pass as a parameter
contains or is like the first name that
we have in the database so now let's
move on and let me show you how to use
this specification class that we just
created now let me show you how to
execute a specification but first of all
let's prepare a few things I will go to
the application yaml and here instead of
create drop I will make it just update
because I want to have some persistent
data and I want to check what we have in
the database so this is the first one
and then I will just uh keep this one
for the first time I will execute the
application and I will then just remove
all this one so I don't I don't want to
update uh the ages I don't want to find
anything all I need is just to execute
it for one time and make sure that I
have some data gets persisted so here we
see that we have all the inserts and if
I check again my table we have the data
inserted and then all I will do is
comment this out and now I can stop the
application and we can now implement or
run our specification so in order to run
the specification that we created first
of all we need to create an object of
type
specification having a type author and
let's call it spec or specification it's
as you like I will use spec as a short
name equals
specification and then do where so this
is our work close so the first filter of
our work close is this one this author
specification that we created so first
of all I want to filter by age and first
name okay so I want to get all the
authors having the age equals something
and first name equals something so here
I can use author
specification dot has age for example
let's say 34 let's just imagine and so
here we can use and or and or or or we
can even pass another predicate but we
can rely on and and or so let's say and
also again I want to use my other
specification and then first name
like so for the first name I will again
refresh this list and take for example
this one okay so I want to fetch all the
authors having the name for example
starting with or containing this Mitch
okay I will say Mi just Mi okay so then
once we are done with creating or
declaring our specification I will do my
Repository do find all and then within
the find all method I can now pass my
specification as a parameter because our
repository already
extends or implements the uh jpa
specification executor so here I will
just do for each and then
system.out do print Ln just to print out
our result so let's click and draw the
application and see what will happen so
we see here first of all we have we have
an exception and the first thing that we
see in here that could not resolve
attribute first name and let me show you
why so this first name here we said that
I want to have the first name like but
let's check our author so the author
it's first name with a capital N so this
is important to have exactly the same
thing all right so now I I will run
again and check so here we see that we
have the select but we don't have any
result and you may wonder why I can tell
you so when we use the keyword like when
uh in the SQL when we use this keyword
like we should always use like and then
it should be like this so it should be
percent percent and then our filter
right here okay so this is what we are
missing with the first name so we need
to do something like
this and then I will add percent in the
beginning and percent at the end so we
need to surround this first name the
variable that we want to pass with a
percent percent okay so whether we do it
here or you can do it when you pass this
parameter like this but it's better to
put it in the in the specification
because like means that we have
something like this okay now let's run
again
and we still can't see our data let's
first check uh the author so we have our
Mitch right here and let's go back yeah
but Mitch yes that was the the problem
but Mitch is 22 years old and we don't
have any other Mitch within the same age
so now I will just change this one to
22 and run again the
application so here we see that we have
at least one one result which is this
guy called Mitch Mitchell and so on so
forth and having the age 22 so now for
example I want to first to search only
for um I want to search only for the
authors that the age is 22 so I just can
comment this out and run my application
again or execute my query again and this
one it will filter all the users that
they are 22 years old or also I can do
something
else so here instead of and I can say or
so find all the authors uh that are 22
years old or the name is like or
contains Mi so let's run again and check
the specification return type so here we
see also that we have these two elements
so this guy is 22 and we have the first
one is Mitch and then we have this paita
so for example also if I just let's just
play a little bit with um with the
variables that we pass and here I want
to filter all the authors that the first
name contains the letter I and as you
can see here it's an i it's an i it's an
i and so on so forth so this is how you
can create Dynamic queries and also the
best part of specifications is you can
reuse all these methods that we created
all these predicates or all these
specifications are reusable and you can
reuse them to create Dynamic queries
okay so for example if you have a search
or complicated or complex uh search
query you can use specification in order
to prepare and in order to create your
query in
advance